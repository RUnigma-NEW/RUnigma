--- enigma2-nightly.org/tools/genmetaindex.py
+++ enigma2-nightly.patched/tools/genmetaindex.py
@@ -47,4 +47,4 @@
 
 indent(root)
 
-ElementTree(root).write(sys.stdout)
+ElementTree(root).write(sys.stdout.buffer)
 
\
--- enigma2-nightly.org/e2reactor.py
+++ enigma2-nightly.patched/e2reactor.py
@@ -55,12 +55,12 @@
 			pass
 
 		mask = 0
-		if reads.has_key(fd): mask = mask | select.POLLIN
-		if writes.has_key(fd): mask = mask | select.POLLOUT
+		if fd in reads: mask = mask | select.POLLIN
+		if fd in writes: mask = mask | select.POLLOUT
 		if mask != 0:
 			poller.register(fd, mask)
 		else:
-			if selectables.has_key(fd): del selectables[fd]
+			if fd in selectables: del selectables[fd]
 		
 		
 		poller.eApp.interruptPoll()
@@ -75,14 +75,14 @@
 		except:
 			# the hard way: necessary because fileno() may disappear at any
 			# moment, thanks to python's underlying sockets impl
-			for fd, fdes in selectables.items():
+			for fd, fdes in list(selectables.items()):
 				if selectable is fdes:
 					break
 			else:
 				# Hmm, maybe not the right course of action?  This method can't
 				# fail, because it happens inside error detection...
 				return
-		if mdict.has_key(fd):
+		if fd in mdict:
 			del mdict[fd]
 			self._updateRegistration(fd)
 
@@ -90,7 +90,7 @@
 		"""Add a FileDescriptor for notification of data available to read.
 		"""
 		fd = reader.fileno()
-		if not reads.has_key(fd):
+		if fd not in reads:
 			selectables[fd] = reader
 			reads[fd] =  1
 			self._updateRegistration(fd)
@@ -99,7 +99,7 @@
 		"""Add a FileDescriptor for notification of data available to write.
 		"""
 		fd = writer.fileno()
-		if not writes.has_key(fd):
+		if fd not in writes:
 			selectables[fd] = writer
 			writes[fd] =  1
 			self._updateRegistration(fd)
@@ -118,8 +118,8 @@
 		"""Remove all selectables, and return a list of them."""
 		if self.waker is not None:
 			self.removeReader(self.waker)
-		result = selectables.values()
-		fds = selectables.keys()
+		result = list(selectables.values())
+		fds = list(selectables.keys())
 		reads.clear()
 		writes.clear()
 		selectables.clear()
@@ -149,7 +149,7 @@
 				if self.running:
 					self.stop()
 				l = [ ]
-		except select.error, e:
+		except select.error as e:
 			if e[0] == errno.EINTR:
 				return
 			else:
--- enigma2-nightly.org/lib/actions/parseactions.py
+++ enigma2-nightly.patched/lib/actions/parseactions.py
@@ -4,13 +4,13 @@
 
 def filter(g):
 	while 1:
-		t = g.next()
+		t = next(g)
 		if t[1] == "/*":
-			while g.next()[1] != "*/":
+			while next(g)[1] != "*/":
 				pass
 			continue
 		if t[1] == "//":
-			while g.next()[1] != "\n":
+			while next(g)[1] != "\n":
 				pass
 			continue
 		
@@ -19,7 +19,7 @@
 			yield t[1]
 
 def do_file(f, mode):
-	tokens = filter(tokenize.generate_tokens(open(f, 'r').readline))
+	tokens = list(filter(tokenize.generate_tokens(open(f, 'r').readline)))
 	
 	sys.stderr.write("parsing %s\n" % f)
 	
@@ -31,12 +31,12 @@
 	
 	while 1:
 		try:
-			t = tokens.next()
+			t = next(tokens)
 		except:
 			break
 		
 		if t == "class":
-			classname = tokens.next()
+			classname = next(tokens)
 			classstate = state
 		
 		if t == "{":
@@ -46,22 +46,22 @@
 			state = state - 1
 		
 		if t == "enum" and state == classstate + 1:
-			actionname = tokens.next()
+			actionname = next(tokens)
 			
 			if actionname == "{":
-				while tokens.next() != "}":
+				while next(tokens) != "}":
 					pass
 				continue
 			
 			if actionname[-7:] == "Actions":
-				if tokens.next() != "{":
+				if next(tokens) != "{":
 					try:
-						print classname
+						print(classname)
 					except:
 						pass
 				
 					try:
-						print actionname
+						print(actionname)
 					except:
 						pass
 				
@@ -71,11 +71,11 @@
 			
 				while 1:
 	
-					t = tokens.next()
+					t = next(tokens)
 					
 					if t == "=":
-						tokens.next()
-						t = tokens.next()
+						next(tokens)
+						t = next(tokens)
 	
 					if t == "}":
 						break
@@ -83,20 +83,20 @@
 					if counter:
 						if t != ",":
 							raise Exception("no comma")
-						t = tokens.next()
+						t = next(tokens)
 				
 					if firsthit:
 
 						if mode == "include":
 							# hack hack hack!!
-							print "#include <lib/" + '/'.join(f.split('/')[-2:]) + ">"
+							print("#include <lib/" + '/'.join(f.split('/')[-2:]) + ">")
 						else:
-							print "\t// " + f
+							print("\t// " + f)
 
 						firsthit = 0
 
 					if mode == "parse":
-						print "{\"" + actionname + "\", \"" + t + "\", " + string.join((classname, t), "::") + "},"
+						print("{\"" + actionname + "\", \"" + t + "\", " + string.join((classname, t), "::") + "},")
 
 
 					counter = counter + 1
@@ -104,16 +104,16 @@
 mode = sys.argv[1]
 
 if mode == "parse":
-	print """
+	print("""
 	/* generated by parseactions.py - do not modify! */
 struct eActionList
 {
 	const char *m_context, *m_action;
 	int m_id;
-} actions[]={"""
+} actions[]={""")
 
 for x in sys.argv[2:]:
 	do_file(x, mode)
 
 if mode == "parse":
-	print "};"
+	print("};")
--- enigma2-nightly.org/lib/python/enigma_py_patcher.py
+++ enigma2-nightly.patched/lib/python/enigma_py_patcher.py
@@ -22,7 +22,7 @@
 			str = str[:pos]+str[pos+6:]
 
 	if oldstr != str:
-		print "!!! Patch enigma.py line %d\n%s\n%s" %(line, oldstr[:len(oldstr)-1], str)
+		print("!!! Patch enigma.py line %d\n%s\n%s" %(line, oldstr[:len(oldstr)-1], str))
 
 	dest.write(str)
 
--- enigma2-nightly.org/lib/python/Components/AVSwitch.py
+++ enigma2-nightly.patched/lib/python/Components/AVSwitch.py
@@ -1,7 +1,7 @@
-from config import config, ConfigSlider, ConfigSelection, ConfigYesNo, \
+from .config import config, ConfigSlider, ConfigSelection, ConfigYesNo, \
 	ConfigEnableDisable, ConfigSubsection, ConfigBoolean, ConfigSelectionNumber, ConfigNothing, NoSave
 from enigma import eAVSwitch, getDesktop
-from SystemInfo import SystemInfo
+from .SystemInfo import SystemInfo
 import os
 
 class AVSwitch:
@@ -176,11 +176,11 @@
 		def setScaler_sharpness(config):
 			myval = int(config.value)
 			try:
-				print "--> setting scaler_sharpness to: %0.8X" % myval
+				print("--> setting scaler_sharpness to: %0.8X" % myval)
 				open("/proc/stb/vmpeg/0/pep_scaler_sharpness", "w").write("%0.8X" % myval)
 				open("/proc/stb/vmpeg/0/pep_apply", "w").write("1")
 			except IOError:
-				print "couldn't write pep_scaler_sharpness"
+				print("couldn't write pep_scaler_sharpness")
 
 		config.av.scaler_sharpness = ConfigSlider(default=13, limits=(0,26))
 		config.av.scaler_sharpness.addNotifier(setScaler_sharpness)
--- enigma2-nightly.org/lib/python/Components/ActionMap.py
+++ enigma2-nightly.patched/lib/python/Components/ActionMap.py
@@ -41,14 +41,14 @@
 		self.checkBind()
 
 	def action(self, context, action):
-		print " ".join(("action -> ", context, action))
-		if self.actions.has_key(action):
+		print(" ".join(("action -> ", context, action)))
+		if action in self.actions:
 			res = self.actions[action]()
 			if res is not None:
 				return res
 			return 1
 		else:
-			print "unknown action %s/%s! typo in keymap?" % (context, action)
+			print("unknown action %s/%s! typo in keymap?" % (context, action))
 			return 0
 
 	def destroy(self):
@@ -57,7 +57,7 @@
 class NumberActionMap(ActionMap):
 	def action(self, contexts, action):
 		numbers = ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9")
-		if (action in numbers and self.actions.has_key(action)):
+		if (action in numbers and action in self.actions):
 			res = self.actions[action](int(action))
 			if res is not None:
 				return res
@@ -81,7 +81,7 @@
 	def __init__(self, parent, context, actions = { }, prio=0):
 		alist = [ ]
 		adict = { }
-		for (action, funchelp) in actions.iteritems():
+		for (action, funchelp) in actions.items():
 			# check if this is a tuple
 			if isinstance(funchelp, tuple):
 				alist.append((action, funchelp[1]))
--- enigma2-nightly.org/lib/python/Components/BlinkingPixmap.py
+++ enigma2-nightly.patched/lib/python/Components/BlinkingPixmap.py
@@ -1,5 +1,5 @@
-from Pixmap import PixmapConditional
-from ConditionalWidget import BlinkingWidgetConditional, BlinkingWidget
+from .Pixmap import PixmapConditional
+from .ConditionalWidget import BlinkingWidgetConditional, BlinkingWidget
 
 class BlinkingPixmap(BlinkingWidget):
 	def __init__(self):
--- enigma2-nightly.org/lib/python/Components/Button.py
+++ enigma2-nightly.patched/lib/python/Components/Button.py
@@ -1,6 +1,6 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
-from VariableText import VariableText
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
+from .VariableText import VariableText
 
 from enigma import eButton
 
--- enigma2-nightly.org/lib/python/Components/ChoiceList.py
+++ enigma2-nightly.patched/lib/python/Components/ChoiceList.py
@@ -1,4 +1,4 @@
-from MenuList import MenuList
+from .MenuList import MenuList
 from Tools.Directories import SCOPE_CURRENT_SKIN, resolveFilename
 from enigma import RT_HALIGN_LEFT, eListboxPythonMultiContent, gFont
 from Tools.LoadPixmap import LoadPixmap
--- enigma2-nightly.org/lib/python/Components/Clock.py
+++ enigma2-nightly.patched/lib/python/Components/Clock.py
@@ -1,6 +1,6 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
-from VariableText import VariableText
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
+from .VariableText import VariableText
 
 from enigma import eTimer, eLabel
 
--- enigma2-nightly.org/lib/python/Components/ConditionalWidget.py
+++ enigma2-nightly.patched/lib/python/Components/ConditionalWidget.py
@@ -1,4 +1,4 @@
-from GUIComponent import GUIComponent
+from .GUIComponent import GUIComponent
 from enigma import eTimer
 
 class ConditionalWidget(GUIComponent):
--- enigma2-nightly.org/lib/python/Components/ConfigList.py
+++ enigma2-nightly.patched/lib/python/Components/ConfigList.py
@@ -1,6 +1,6 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
-from config import KEY_LEFT, KEY_RIGHT, KEY_HOME, KEY_END, KEY_0, KEY_DELETE, KEY_BACKSPACE, KEY_OK, KEY_TOGGLEOW, KEY_ASCII, KEY_TIMEOUT, KEY_NUMBERS, ConfigElement, ConfigText, ConfigPassword
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
+from .config import KEY_LEFT, KEY_RIGHT, KEY_HOME, KEY_END, KEY_0, KEY_DELETE, KEY_BACKSPACE, KEY_OK, KEY_TOGGLEOW, KEY_ASCII, KEY_TIMEOUT, KEY_NUMBERS, ConfigElement, ConfigText, ConfigPassword
 from Components.ActionMap import NumberActionMap, ActionMap
 from enigma import eListbox, eListboxPythonConfigContent, eRCInput, eTimer
 from Screens.MessageBox import MessageBox
@@ -151,20 +151,20 @@
 	def handleInputHelpers(self):
 		if self["config"].getCurrent() is not None:
 			if isinstance(self["config"].getCurrent()[1], ConfigText) or isinstance(self["config"].getCurrent()[1], ConfigPassword):
-				if self.has_key("VKeyIcon"):
+				if "VKeyIcon" in self:
 					self["VirtualKB"].setEnabled(True)
 					self["VKeyIcon"].boolean = True
-				if self.has_key("HelpWindow"):
+				if "HelpWindow" in self:
 					if self["config"].getCurrent()[1].help_window.instance is not None:
 						helpwindowpos = self["HelpWindow"].getPosition()
 						from enigma import ePoint
 						self["config"].getCurrent()[1].help_window.instance.move(ePoint(helpwindowpos[0],helpwindowpos[1]))
 			else:
-				if self.has_key("VKeyIcon"):
+				if "VKeyIcon" in self:
 					self["VirtualKB"].setEnabled(False)
 					self["VKeyIcon"].boolean = False
 		else:
-			if self.has_key("VKeyIcon"):
+			if "VKeyIcon" in self:
 				self["VirtualKB"].setEnabled(False)
 				self["VKeyIcon"].boolean = False
 
--- enigma2-nightly.org/lib/python/Components/Console.py
+++ enigma2-nightly.patched/lib/python/Components/Console.py
@@ -11,10 +11,10 @@
 	def ePopen(self, cmd, callback=None, extra_args=[]):
 		name = cmd
 		i = 0
-		while self.appContainers.has_key(name):
+		while name in self.appContainers:
 			name = cmd +'_'+ str(i)
 			i += 1
-		print "[ePopen] command:", cmd
+		print("[ePopen] command:", cmd)
 		self.appResults[name] = ""
 		self.extra_args[name] = extra_args
 		self.callbacks[name] = callback
@@ -35,7 +35,7 @@
 	def eBatchCB(self, data, retval, _extra_args):
 		(cmds, callback, extra_args) = _extra_args
 		if self.debug:
-			print '[eBatch] retval=%s, cmds left=%d, data:\n%s' % (retval, len(cmds), data)
+			print('[eBatch] retval=%s, cmds left=%d, data:\n%s' % (retval, len(cmds), data))
 		if len(cmds):
 			cmd = cmds.pop(0)
 			self.ePopen(cmd, self.eBatchCB, [cmds, callback, extra_args])
@@ -58,7 +58,7 @@
 
 	def kill(self,name):
 		if name in self.appContainers:
-			print "[Console] killing: ",self.appContainers[name]
+			print("[Console] killing: ",self.appContainers[name])
 			self.appContainers[name].kill()
 
 	def killAll(self):
--- enigma2-nightly.org/lib/python/Components/DiskInfo.py
+++ enigma2-nightly.patched/lib/python/Components/DiskInfo.py
@@ -1,5 +1,5 @@
-from GUIComponent import GUIComponent
-from VariableText import VariableText
+from .GUIComponent import GUIComponent
+from .VariableText import VariableText
 from os import statvfs
 
 from enigma import eLabel
--- enigma2-nightly.org/lib/python/Components/Element.py
+++ enigma2-nightly.patched/lib/python/Components/Element.py
@@ -1,4 +1,5 @@
 from Tools.CList import CList
+from functools import reduce
 
 # down                       up
 # Render Converter Converter Source
--- enigma2-nightly.org/lib/python/Components/EpgList.py
+++ enigma2-nightly.patched/lib/python/Components/EpgList.py
@@ -1,5 +1,5 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
 
 from enigma import eEPGCache, eListbox, eListboxPythonMultiContent, gFont, \
 	RT_HALIGN_LEFT, RT_HALIGN_RIGHT, RT_HALIGN_CENTER, RT_VALIGN_CENTER
@@ -311,4 +311,4 @@
 			l.sort(key=lambda x: x[2])
 		self.l.setList(l)
 		self.selectionChanged()
-		print time() - t
+		print(time() - t)
--- enigma2-nightly.org/lib/python/Components/FanControl.py
+++ enigma2-nightly.patched/lib/python/Components/FanControl.py
@@ -21,14 +21,14 @@
 			cfg = self.getConfig(fanid)
 			self.setVoltage(fanid, cfg.vlt.value)
 			self.setPWM(fanid, cfg.pwm.value)
-			print "[FanControl]: setting fan values: fanid = %d, voltage = %d, pwm = %d" % (fanid, cfg.vlt.value, cfg.pwm.value)
+			print("[FanControl]: setting fan values: fanid = %d, voltage = %d, pwm = %d" % (fanid, cfg.vlt.value, cfg.pwm.value))
 
 	def setVoltage_PWM_Standby(self):
 		for fanid in range(self.getFanCount()):
 			cfg = self.getConfig(fanid)
 			self.setVoltage(fanid, cfg.vlt_standby.value)
 			self.setPWM(fanid, cfg.pwm_standby.value)
-			print "[FanControl]: setting fan values (standby mode): fanid = %d, voltage = %d, pwm = %d" % (fanid, cfg.vlt_standby.value, cfg.pwm_standby.value)
+			print("[FanControl]: setting fan values (standby mode): fanid = %d, voltage = %d, pwm = %d" % (fanid, cfg.vlt_standby.value, cfg.pwm_standby.value))
 
 	def getRecordEvent(self, recservice, event):
 		recordings = len(NavigationInstance.instance.getRecordings())
--- enigma2-nightly.org/lib/python/Components/FileList.py
+++ enigma2-nightly.patched/lib/python/Components/FileList.py
@@ -1,6 +1,6 @@
 import os
 import re
-from MenuList import MenuList
+from .MenuList import MenuList
 from Components.Harddisk import harddiskmanager
 from Tools.Directories import SCOPE_CURRENT_SKIN, resolveFilename, fileExists
 from enigma import RT_HALIGN_LEFT, eListboxPythonMultiContent, \
@@ -43,7 +43,7 @@
 	else:
 		extension = name.split('.')
 		extension = extension[-1].lower()
-		if EXTENSIONS.has_key(extension):
+		if extension in EXTENSIONS:
 			png = LoadPixmap(resolveFilename(SCOPE_CURRENT_SKIN, "extensions/" + EXTENSIONS[extension] + ".png"))
 		else:
 			png = None
@@ -274,7 +274,7 @@
 	else:
 		extension = name.split('.')
 		extension = extension[-1].lower()
-		if EXTENSIONS.has_key(extension):
+		if extension in EXTENSIONS:
 			png = LoadPixmap(resolveFilename(SCOPE_CURRENT_SKIN, "extensions/" + EXTENSIONS[extension] + ".png"))
 		else:
 			png = None
@@ -322,7 +322,7 @@
 				        try:
 						self.selectedFiles.remove(os.path.normpath(realPathname))
 					except:
-					        print "Couldn't remove:", realPathname
+					        print("Couldn't remove:", realPathname)
 			else:
 				SelectState = True
 				if (realPathname not in self.selectedFiles) and (os.path.normpath(realPathname) not in self.selectedFiles):
--- enigma2-nightly.org/lib/python/Components/GUISkin.py
+++ enigma2-nightly.patched/lib/python/Components/GUISkin.py
@@ -1,7 +1,7 @@
-from GUIComponent import GUIComponent
+from .GUIComponent import GUIComponent
 from skin import applyAllAttributes
 from Tools.CList import CList
-from Sources.StaticText import StaticText
+from .Sources.StaticText import StaticText
 
 class GUISkin:
 	__module__ = __name__
@@ -19,7 +19,7 @@
 				if not updateonly:
 					val.GUIcreate(parent)
 				if not val.applySkin(desktop, self):
-					print "warning, skin is missing renderer", val, "in", self
+					print("warning, skin is missing renderer", val, "in", self)
 
 		for key in self:
 			val = self[key]
@@ -29,10 +29,10 @@
 				depr = val.deprecationInfo
 				if val.applySkin(desktop, self):
 					if depr:
-						print "WARNING: OBSOLETE COMPONENT '%s' USED IN SKIN. USE '%s' INSTEAD!" % (key, depr[0])
-						print "OBSOLETE COMPONENT WILL BE REMOVED %s, PLEASE UPDATE!" % (depr[1])
+						print("WARNING: OBSOLETE COMPONENT '%s' USED IN SKIN. USE '%s' INSTEAD!" % (key, depr[0]))
+						print("OBSOLETE COMPONENT WILL BE REMOVED %s, PLEASE UPDATE!" % (depr[1]))
 				elif not depr:
-					print "warning, skin is missing element", key, "in", self
+					print("warning, skin is missing element", key, "in", self)
 
 		for w in self.additionalWidgets:
 			if not updateonly:
@@ -42,12 +42,12 @@
 
 		for f in self.onLayoutFinish:
 			if type(f) is not type(self.close): # is this the best way to do this?
-				exec(f) in globals(), locals()
+				exec((f), globals(), locals())
 			else:
 				f()
 
 	def deleteGUIScreen(self):
-		for (name, val) in self.items():
+		for (name, val) in list(self.items()):
 			if isinstance(val, GUIComponent):
 				val.GUIdelete()
 
--- enigma2-nightly.org/lib/python/Components/Harddisk.py
+++ enigma2-nightly.patched/lib/python/Components/Harddisk.py
@@ -1,9 +1,9 @@
 import os
 import time
 from Tools.CList import CList
-from SystemInfo import SystemInfo
+from .SystemInfo import SystemInfo
 from Components.Console import Console
-import Task
+from . import Task
 
 def readFile(filename):
 	file = open(filename)
@@ -14,8 +14,8 @@
 def getProcMounts():
 	try:
 		mounts = open("/proc/mounts", 'r')
-	except IOError, ex:
-		print "[Harddisk] Failed to open /proc/mounts", ex
+	except IOError as ex:
+		print("[Harddisk] Failed to open /proc/mounts", ex)
 		return []
 	result = [line.strip().split(' ') for line in mounts]
 	for item in result:
@@ -29,8 +29,8 @@
 			if fs.strip().endswith(filesystem):
 				return True
 		return False
-	except Exception, ex:
-		print "[Harddisk] Failed to read /proc/filesystems:", ex
+	except Exception as ex:
+		print("[Harddisk] Failed to read /proc/filesystems:", ex)
 
 def findMountPoint(path):
 	'Example: findMountPoint("/media/hdd/some/file") returns "/media/hdd"'
@@ -52,7 +52,7 @@
 		elif os.access("/dev/.devfsd", 0):
 			self.type = DEVTYPE_DEVFS
 		else:
-			print "Unable to determine structure of /dev"
+			print("Unable to determine structure of /dev")
 
 		self.max_idle_time = 0
 		self.idle_running = False
@@ -77,7 +77,7 @@
 			self.disk_path = self.dev_path
 #+++<
 
-		print "new Harddisk", self.device, '->', self.dev_path, '->', self.disk_path
+		print("new Harddisk", self.device, '->', self.dev_path, '->', self.disk_path)
 		if not removable:
 			self.startIdle()
 
@@ -140,9 +140,9 @@
 				model = readFile(self.sysfsPath('device/model'))
 				return vendor + '(' + model + ')'
 			else:
-				raise Exception, "no hdX or sdX"
-		except Exception, e:
-			print "[Harddisk] Failed to get model:", e
+				raise Exception("no hdX or sdX")
+		except Exception as e:
+			print("[Harddisk] Failed to get model:", e)
 			return "-?-"
 
 	def free(self):
@@ -198,7 +198,7 @@
 			# not mounted, return OK
 			return 0
 		cmd = 'umount ' + dev
-		print "[Harddisk]", cmd
+		print("[Harddisk]", cmd)
 		res = os.system(cmd)
 		return (res >> 8)
 
@@ -228,7 +228,7 @@
 			parts = line.strip().split(" ")
 			fspath = os.path.realpath(parts[0])
 			if fspath == dev:
-				print "[Harddisk] mounting:", fspath
+				print("[Harddisk] mounting:", fspath)
 				cmd = "mount -t auto " + fspath
 				res = os.system(cmd)
 				return (res >> 8)
@@ -265,7 +265,7 @@
 	def createInitializeJob(self):
 		job = Task.Job(_("Initializing storage device..."))
 		size = self.diskSize()
-		print "[HD] size: %s MB" % size
+		print("[HD] size: %s MB" % size)
 
 		task = UnmountTask(job, self)
 
@@ -314,7 +314,7 @@
 			task.args.append(self.disk_path)
 			if size > 128000:
 				# Start at sector 8 to better support 4k aligned disks
-				print "[HD] Detected >128GB disk, using 4k alignment"
+				print("[HD] Detected >128GB disk, using 4k alignment")
 				task.initial_input = "8,\n;0,0\n;0,0\n;0,0\ny\n"
 			else:
 				# Smaller disks (CF cards, sticks etc) don't need that
@@ -383,7 +383,7 @@
 
 	def createExt4ConversionJob(self):
 		if not isFileSystemSupported('ext4'):
-			raise Exception, _("You system does not support ext4")
+			raise Exception(_("You system does not support ext4"))
 		job = Task.Job(_("Converting ext3 to ext4..."))
 		if not os.path.exists('/sbin/tune2fs'):
 			addInstallTask(job, 'e2fsprogs-tune2fs')
@@ -501,7 +501,7 @@
 		if self.mountpoint:
 			return os.statvfs(self.mountpoint)
 		else:
-			raise OSError, "Device %s is not mounted" % self.device
+			raise OSError("Device %s is not mounted" % self.device)
 
 	def free(self):
 		try:
@@ -639,14 +639,14 @@
 		medium_found = True
 		try:
 			open("/dev/" + blockdev).close()
-		except IOError, err:
+		except IOError as err:
 			if err.errno == 159: # no medium present
 				medium_found = False
 
 		return error, blacklisted, removable, is_cdrom, partitions, medium_found
 
 	def enumerateBlockDevices(self):
-		print "[Harddisk] enumerating block devices..."
+		print("[Harddisk] enumerating block devices...")
 		for blockdev in os.listdir("/sys/block"):
 			error, blacklisted, removable, is_cdrom, partitions, medium_found = self.addHotplugPartition(blockdev)
 			if not error and not blacklisted and medium_found:
@@ -679,7 +679,7 @@
 				physdev = os.path.realpath('/sys/block/' + dev + '/device')[4:]
 			except OSError:
 				physdev = dev
-				print "couldn't determine blockdev physdev for device", device
+				print("couldn't determine blockdev physdev for device", device)
 		error, blacklisted, removable, is_cdrom, partitions, medium_found = self.getBlockDevInfo(device)
 		if not blacklisted and medium_found:
 			description = self.getUserfriendlyDeviceName(device, physdev)
@@ -759,10 +759,10 @@
 		description = "External Storage %s" % dev
 		try:
 			description = readFile("/sys" + phys + "/model")
-		except IOError, s:
-			print "couldn't read model: ", s
+		except IOError as s:
+			print("couldn't read model: ", s)
 		from Tools.HardwareInfo import HardwareInfo
-		for physdevprefix, pdescription in DEVICEDB.get(HardwareInfo().device_name,{}).items():
+		for physdevprefix, pdescription in list(DEVICEDB.get(HardwareInfo().device_name,{}).items()):
 			if phys.startswith(physdevprefix):
 				description = pdescription
 		# not wholedisk and not partition 1
@@ -792,8 +792,8 @@
 			cd = open(device)
 			ioctl(cd.fileno(), ioctl_flag, speed)
 			cd.close()
-		except Exception, ex:
-			print "[Harddisk] Failed to set %s speed to %s" % (device, speed), ex
+		except Exception as ex:
+			print("[Harddisk] Failed to set %s speed to %s" % (device, speed), ex)
 
 class UnmountTask(Task.LoggingTask):
 	def __init__(self, job, hdd):
@@ -804,8 +804,8 @@
 		try:
 			dev = self.hdd.disk_path.split('/')[-1]
 			open('/dev/nomount.%s' % dev, "wb").close()
-		except Exception, e:
-			print "ERROR: Failed to create /dev/nomount file:", e
+		except Exception as e:
+			print("ERROR: Failed to create /dev/nomount file:", e)
 		self.setTool('umount')
 		self.args.append('-f')
 		for dev in self.hdd.enumMountDevices():
@@ -813,15 +813,15 @@
 			self.postconditions.append(Task.ReturncodePostcondition())
 			self.mountpoints.append(dev)
 		if not self.mountpoints:
-			print "UnmountTask: No mountpoints found?"
+			print("UnmountTask: No mountpoints found?")
 			self.cmd = 'true'
 			self.args = [self.cmd]
 	def afterRun(self):
 		for path in self.mountpoints:
 			try:
 				os.rmdir(path)
-			except Exception, ex:
-				print "Failed to remove path '%s':" % path, ex
+			except Exception as ex:
+				print("Failed to remove path '%s':" % path, ex)
 
 class MountTask(Task.LoggingTask):
 	def __init__(self, job, hdd):
@@ -831,8 +831,8 @@
 		try:
 			dev = self.hdd.disk_path.split('/')[-1]
 			os.unlink('/dev/nomount.%s' % dev)
-		except Exception, e:
-			print "ERROR: Failed to remove /dev/nomount file:", e
+		except Exception as e:
+			print("ERROR: Failed to remove /dev/nomount file:", e)
 		# try mounting through fstab first
 		if self.hdd.mount_device is None:
 			dev = self.hdd.partitionPath("1")
@@ -861,7 +861,7 @@
 	def prepare(self):
 		self.fsck_state = None
 	def processOutput(self, data):
-		print "[Mkfs]", data
+		print("[Mkfs]", data)
 		if 'Writing inode tables:' in data:
 			self.fsck_state = 'inode'
 		elif 'Creating journal' in data:
@@ -876,8 +876,8 @@
 					if ('\x08' in d[1]):
 						d[1] = d[1].split('\x08',1)[0]
 					self.setProgress(80*int(d[0])/int(d[1]))
-				except Exception, e:
-					print "[Mkfs] E:", e
+				except Exception as e:
+					print("[Mkfs] E:", e)
 				return # don't log the progess
 		self.log.append(data)
 
--- enigma2-nightly.org/lib/python/Components/HdmiCec.py
+++ enigma2-nightly.patched/lib/python/Components/HdmiCec.py
@@ -1,6 +1,6 @@
 import struct
 import os
-from config import config, ConfigSelection, ConfigYesNo, ConfigSubsection, ConfigText
+from .config import config, ConfigSelection, ConfigYesNo, ConfigSubsection, ConfigText
 from enigma import eHdmiCEC, eRCInput
 from Tools.StbHardware import getFPWasTimerWakeup
 from enigma import eTimer
@@ -209,7 +209,7 @@
 			length = message.getData(data, len(data))
 			if cmd == 0x00: # feature abort
 				if data[0] == '\x44':
-					print 'eHdmiCec: volume forwarding not supported by device %02x'%(message.getAddress())
+					print('eHdmiCec: volume forwarding not supported by device %02x'%(message.getAddress()))
 					self.volumeForwardingEnabled = False;
 			elif cmd == 0x46: # request name
 				self.sendMessage(message.getAddress(), 'osdname')
@@ -219,7 +219,7 @@
 				else:
 					self.volumeForwardingDestination = 0; # off: send volume keys to tv
 				if config.hdmicec.volume_forwarding.value:
-					print 'eHdmiCec: volume forwarding to device %02x enabled'%(self.volumeForwardingDestination)
+					print('eHdmiCec: volume forwarding to device %02x enabled'%(self.volumeForwardingDestination))
 					self.volumeForwardingEnabled = True;
 			elif cmd == 0x8f: # request power status
 				if inStandby:
@@ -285,7 +285,7 @@
 		if not self.volumeForwardingEnabled: return
 		cmd = 0
 		data = ''
-		print "keyEvent hdmi: %d %d"%(keyCode, keyEvent)
+		print("keyEvent hdmi: %d %d"%(keyCode, keyEvent))
 		if keyEvent == 0:
 			if keyCode == 115:
 				cmd = 0x44
--- enigma2-nightly.org/lib/python/Components/HelpMenuList.py
+++ enigma2-nightly.patched/lib/python/Components/HelpMenuList.py
@@ -1,4 +1,4 @@
-from GUIComponent import GUIComponent
+from .GUIComponent import GUIComponent
 
 from enigma import eListboxPythonMultiContent, eListbox, gFont
 from Tools.KeyBindings import queryKeyBinding, getKeyDescription
@@ -42,7 +42,7 @@
 
 				if isinstance(help, list):
 					self.extendedHelp = True
-					print "extendedHelpEntry found"
+					print("extendedHelpEntry found")
 					entry.extend((
 						(eListboxPythonMultiContent.TYPE_TEXT, 0, 0, 500, 26, 0, 0, help[0]),
 						(eListboxPythonMultiContent.TYPE_TEXT, 0, 28, 500, 20, 1, 0, help[1])
--- enigma2-nightly.org/lib/python/Components/Input.py
+++ enigma2-nightly.patched/lib/python/Components/Input.py
@@ -1,6 +1,6 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
-from VariableText import VariableText
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
+from .VariableText import VariableText
 
 from enigma import eLabel
 
@@ -60,12 +60,12 @@
 	def setText(self, text):
 		if not len(text):
 			self.currPos = 0
-			self.Text = u""
+			self.Text = ""
 		else:
 			try:
 				self.Text = text.decode("utf-8")
 			except UnicodeDecodeError:
-				print "utf8 kaputt!"
+				print("utf8 kaputt!")
 				self.Text = text
 		self.update()
 
@@ -225,7 +225,7 @@
 		if self.allmarked:
 			self.deleteAllChars()
 			self.allmarked = False
-		self.insertChar(unichr(code), self.currPos, False, False);
+		self.insertChar(chr(code), self.currPos, False, False);
 		self.innerright()
 		self.update()
 
--- enigma2-nightly.org/lib/python/Components/InputDevice.py
+++ enigma2-nightly.patched/lib/python/Components/InputDevice.py
@@ -1,21 +1,21 @@
-from config import config, ConfigSlider, ConfigSubsection, ConfigYesNo, ConfigText, ConfigInteger
+from .config import config, ConfigSlider, ConfigSubsection, ConfigYesNo, ConfigText, ConfigInteger
 from os import listdir, open as os_open, close as os_close, write as os_write, O_RDWR, O_NONBLOCK
 from Tools.Directories import pathExists
 from fcntl import ioctl
 import struct
 
 # asm-generic/ioctl.h
-IOC_NRBITS = 8L
-IOC_TYPEBITS = 8L
-IOC_SIZEBITS = 13L
-IOC_DIRBITS = 3L
-
-IOC_NRSHIFT = 0L
+IOC_NRBITS = 8
+IOC_TYPEBITS = 8
+IOC_SIZEBITS = 13
+IOC_DIRBITS = 3
+
+IOC_NRSHIFT = 0
 IOC_TYPESHIFT = IOC_NRSHIFT+IOC_NRBITS
 IOC_SIZESHIFT = IOC_TYPESHIFT+IOC_TYPEBITS
 IOC_DIRSHIFT = IOC_SIZESHIFT+IOC_SIZEBITS
 
-IOC_READ = 2L
+IOC_READ = 2
 
 def EVIOCGNAME(length):
 	return (IOC_READ<<IOC_DIRSHIFT)|(length<<IOC_SIZESHIFT)|(0x45<<IOC_TYPESHIFT)|(0x06<<IOC_NRSHIFT)
@@ -38,8 +38,8 @@
 				self.name = ioctl(self.fd, EVIOCGNAME(256), buffer)
 				self.name = self.name[:self.name.find("\0")]
 				os_close(self.fd)
-			except (IOError,OSError), err:
-				print '[iInputDevices] getInputDevices  <ERROR: ioctl(EVIOCGNAME): ' + str(err) + ' >'
+			except (IOError,OSError) as err:
+				print('[iInputDevices] getInputDevices  <ERROR: ioctl(EVIOCGNAME): ' + str(err) + ' >')
 				self.name = None
 
 			if self.name:
@@ -54,26 +54,26 @@
 		elif name.find("mouse") != -1:
 			return "mouse"
 		else:
-			print "Unknown device type:",name
+			print("Unknown device type:",name)
 			return None
 
 	def getDeviceName(self, x):
-		if x in self.Devices.keys():
+		if x in list(self.Devices.keys()):
 			return self.Devices[x].get("name", x)
 		else:
 			return "Unknown device name"
 
 	def getDeviceList(self):
-		return sorted(self.Devices.iterkeys())
+		return sorted(self.Devices.keys())
 
 	def setDeviceAttribute(self, device, attribute, value):
 		#print "[iInputDevices] setting for device", device, "attribute", attribute, " to value", value
-		if self.Devices.has_key(device):
+		if device in self.Devices:
 			self.Devices[device][attribute] = value
 
 	def getDeviceAttribute(self, device, attribute):
-		if self.Devices.has_key(device):
-			if self.Devices[device].has_key(attribute):
+		if device in self.Devices:
+			if attribute in self.Devices[device]:
 				return self.Devices[device][attribute]
 		return None
 
@@ -96,7 +96,7 @@
 	#}; -> size = 16
 
 	def setDefaults(self, device):
-		print "[iInputDevices] setDefaults for device %s" % (device)
+		print("[iInputDevices] setDefaults for device %s" % (device))
 		self.setDeviceAttribute(device, 'configuredName', None)
 		event_repeat = struct.pack('iihhi', 0, 0, 0x14, 0x01, 100)
 		event_delay = struct.pack('iihhi', 0, 0, 0x14, 0x00, 700)
@@ -107,7 +107,7 @@
 
 	def setRepeat(self, device, value): #REP_PERIOD
 		if self.getDeviceAttribute(device, 'enabled') == True:
-			print "[iInputDevices] setRepeat for device %s to %d ms" % (device,value)
+			print("[iInputDevices] setRepeat for device %s to %d ms" % (device,value))
 			event = struct.pack('iihhi', 0, 0, 0x14, 0x01, int(value))
 			fd = os_open("/dev/input/" + device, O_RDWR)
 			os_write(fd, event)
@@ -115,7 +115,7 @@
 
 	def setDelay(self, device, value): #REP_DELAY
 		if self.getDeviceAttribute(device, 'enabled') == True:
-			print "[iInputDevices] setDelay for device %s to %d ms" % (device,value)
+			print("[iInputDevices] setDelay for device %s to %d ms" % (device,value))
 			event = struct.pack('iihhi', 0, 0, 0x14, 0x00, int(value))
 			fd = os_open("/dev/input/" + device, O_RDWR)
 			os_write(fd, event)
@@ -130,7 +130,7 @@
 
 	def createConfig(self, *args):
 		config.inputDevices = ConfigSubsection()
-		for device in sorted(iInputDevices.Devices.iterkeys()):
+		for device in sorted(iInputDevices.Devices.keys()):
 			self.currentDevice = device
 			#print "[InitInputDevices] -> creating config entry for device: %s -> %s  " % (self.currentDevice, iInputDevices.Devices[device]["name"])
 			self.setupConfigEntries(self.currentDevice)
--- enigma2-nightly.org/lib/python/Components/InputHotplug.py
+++ enigma2-nightly.patched/lib/python/Components/InputHotplug.py
@@ -1,4 +1,4 @@
-import Netlink
+from . import Netlink
 import enigma
 import os
 
@@ -16,17 +16,17 @@
 					devname = event['DEVNAME']
 					action = event['ACTION']
 					if action == 'add':
-						print "New input device detected:", devname
+						print("New input device detected:", devname)
 						enigma.addInputDevice(os.path.join('/dev', devname));
 					elif action == 'remove':
-						print "Removed input device:", devname
+						print("Removed input device:", devname)
 						enigma.removeInputDevice(os.path.join('/dev', devname));
 			except KeyError:
 				# Ignore "not found"
 				pass
 	def connectionLost(self, failure):
 		# Ignore...
-		print "connectionLost?", failure
+		print("connectionLost?", failure)
 		self.nls.close()
 	def logPrefix(self):
 		return 'NetlinkReader'
--- enigma2-nightly.org/lib/python/Components/Ipkg.py
+++ enigma2-nightly.patched/lib/python/Components/Ipkg.py
@@ -13,7 +13,7 @@
 	global opkgDestinations
 	if mountpoint not in opkgDestinations:
 		opkgDestinations.append(mountpoint)
-		print "[Ipkg] Added to OPKG destinations:", mountpoint
+		print("[Ipkg] Added to OPKG destinations:", mountpoint)
 
 def onPartitionChange(why, part):
 	global opkgDestinations
@@ -32,7 +32,7 @@
 		elif why == 'remove':
 			try:
 				opkgDestinations.remove(mountpoint)
-				print "[Ipkg] Removed from OPKG destinations:", mountpoint
+				print("[Ipkg] Removed from OPKG destinations:", mountpoint)
 			except:
 				pass
 
@@ -73,7 +73,7 @@
 		self.runCmd(opkgExtraDestinations() + ' ' + cmd)
 
 	def runCmd(self, cmd):
-		print "executing", self.ipkg, cmd
+		print("executing", self.ipkg, cmd)
 		self.cmd.appClosed.append(self.cmdFinished)
 		self.cmd.dataAvail.append(self.cmdData)
 		if self.cmd.execute(self.ipkg + " " + cmd):
@@ -108,7 +108,7 @@
 		self.cmd.dataAvail.remove(self.cmdData)
 
 	def cmdData(self, data):
-		print "data:", data
+		print("data:", data)
 		if self.cache is None:
 			self.cache = data
 		else:
@@ -154,9 +154,9 @@
 				# if we get multiple config file update questions, the next ones
 				# don't necessarily start at the beginning of a line
 				self.callCallbacks(self.EVENT_MODIFIED, data.split(' \'', 3)[1][:-1])
-		except Exception, ex:
-			print "[Ipkg] Failed to parse: '%s'" % data
-			print "[Ipkg]", ex
+		except Exception as ex:
+			print("[Ipkg] Failed to parse: '%s'" % data)
+			print("[Ipkg]", ex)
 
 	def callCallbacks(self, event, param = None):
 		for callback in self.callbackList:
--- enigma2-nightly.org/lib/python/Components/Keyboard.py
+++ enigma2-nightly.patched/lib/python/Components/Keyboard.py
@@ -29,12 +29,12 @@
 	def activateKeyboardMap(self, index):
 		try:
 			keymap = self.keyboardmaps[index]
-			print "Activating keymap:",keymap[1]
+			print("Activating keymap:",keymap[1])
 			keymappath = eEnv.resolve('${datadir}/keymaps/') + keymap[0]
 			if os_path.exists(keymappath):
 				Console().ePopen(("loadkmap < " + str(keymappath)))
 		except:
-			print "Selected keymap does not exist!"
+			print("Selected keymap does not exist!")
 
 	def getKeyboardMaplist(self):
 		return self.keyboardmaps
--- enigma2-nightly.org/lib/python/Components/Label.py
+++ enigma2-nightly.patched/lib/python/Components/Label.py
@@ -1,8 +1,8 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
-from VariableText import VariableText
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
+from .VariableText import VariableText
 from skin import parseColor
-from ConditionalWidget import ConditionalWidget, BlinkingWidget, BlinkingWidgetConditional
+from .ConditionalWidget import ConditionalWidget, BlinkingWidget, BlinkingWidgetConditional
 
 from enigma import eLabel
 
@@ -90,12 +90,12 @@
 			if len(self.foreColors) > x:
 				self.instance.setForegroundColor(self.foreColors[x])
 			else:
-				print "setForegroundColorNum(%d) failed! defined colors:" %(x), self.foreColors
+				print("setForegroundColorNum(%d) failed! defined colors:" %(x), self.foreColors)
 
 	def setBackgroundColorNum(self, x):
 		if self.instance:
 			if len(self.backColors) > x:
 				self.instance.setBackgroundColor(self.backColors[x])
 			else:
-				print "setBackgroundColorNum(%d) failed! defined colors:" %(x), self.backColors
+				print("setBackgroundColorNum(%d) failed! defined colors:" %(x), self.backColors)
 
--- enigma2-nightly.org/lib/python/Components/Language.py
+++ enigma2-nightly.patched/lib/python/Components/Language.py
@@ -7,7 +7,7 @@
 
 class Language:
 	def __init__(self):
-		gettext.install('enigma2', resolveFilename(SCOPE_LANGUAGE, ""), unicode=0, codeset="utf-8")
+		gettext.install('enigma2', resolveFilename(SCOPE_LANGUAGE, ""), str=0, codeset="utf-8")
 		self.activeLanguage = 0
 		self.catalog = None
 		self.lang = {}
@@ -57,19 +57,19 @@
 			self.lang[str(lang + "_" + country)] = ((name, lang, country))
 			self.langlist.append(str(lang + "_" + country))
 		except:
-			print "Language " + str(name) + " not found"
+			print("Language " + str(name) + " not found")
 
 	def activateLanguage(self, index):
 		try:
 			lang = self.lang[index]
-			print "Activating language " + lang[0]
+			print("Activating language " + lang[0])
 			self.catalog = gettext.translation('enigma2', resolveFilename(SCOPE_LANGUAGE, ""), languages=[index])
 			self.catalog.install(names=("ngettext", "pgettext"))
 			self.activeLanguage = index
 			for x in self.callbacks:
 				x()
 		except:
-			print "Selected language does not exist!"
+			print("Selected language does not exist!")
 		# NOTE: we do not use LC_ALL, because LC_ALL will not set any of the categories, when one of the categories fails.
 		# We'd rather try to set all available categories, and ignore the others
 		for category in [locale.LC_CTYPE, locale.LC_COLLATE, locale.LC_TIME, locale.LC_MONETARY, locale.LC_MESSAGES, locale.LC_NUMERIC]:
--- enigma2-nightly.org/lib/python/Components/Lcd.py
+++ enigma2-nightly.patched/lib/python/Components/Lcd.py
@@ -1,4 +1,4 @@
-from config import config, ConfigSubsection, ConfigSlider, ConfigYesNo, ConfigNothing
+from .config import config, ConfigSubsection, ConfigSlider, ConfigYesNo, ConfigNothing
 from enigma import eDBoxLCD
 from Components.SystemInfo import SystemInfo
 
--- enigma2-nightly.org/lib/python/Components/MediaPlayer.py
+++ enigma2-nightly.patched/lib/python/Components/MediaPlayer.py
@@ -1,4 +1,4 @@
-from MenuList import MenuList
+from .MenuList import MenuList
 
 from Tools.Directories import SCOPE_CURRENT_SKIN, resolveFilename
 from os import path
--- enigma2-nightly.org/lib/python/Components/MenuList.py
+++ enigma2-nightly.patched/lib/python/Components/MenuList.py
@@ -1,5 +1,5 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
 
 from enigma import eListboxPythonStringContent, eListbox
 
--- enigma2-nightly.org/lib/python/Components/MovieList.py
+++ enigma2-nightly.patched/lib/python/Components/MovieList.py
@@ -1,4 +1,4 @@
-from GUIComponent import GUIComponent
+from .GUIComponent import GUIComponent
 from Tools.FuzzyDate import FuzzyTime
 from ServiceReference import ServiceReference
 from Components.MultiContent import MultiContentEntryText, MultiContentEntryPixmapAlphaTest, MultiContentEntryProgress
@@ -241,17 +241,17 @@
 					if attrib == "fontName":
 						self.fontName = value
 					elif attrib == "fontSizesOriginal":
-						self.fontSizesOriginal = map(int, value.split(","))
+						self.fontSizesOriginal = list(map(int, value.split(",")))
 					elif attrib == "fontSizesCompact":
-						self.fontSizesCompact = map(int, value.split(","))
+						self.fontSizesCompact = list(map(int, value.split(",")))
 					elif attrib == "fontSizesMinimal":
-						self.fontSizesMinimal = map(int, value.split(","))
+						self.fontSizesMinimal = list(map(int, value.split(",")))
 					elif attrib == "itemHeights":
-						self.itemHeights = map(int, value.split(","))
+						self.itemHeights = list(map(int, value.split(",")))
 					else:
 						attribs.append((attrib, value))
-				except Exception, e:
-					print '[MovieList] Error "%s" parsing attribute: %s="%s"' % (str(e), attrib,value)					
+				except Exception as e:
+					print('[MovieList] Error "%s" parsing attribute: %s="%s"' % (str(e), attrib,value))					
 		self.skinAttributes = attribs
 		self.redrawList()
 		return GUIComponent.applySkin(self, desktop, parent)
@@ -523,7 +523,7 @@
 
 		reflist = serviceHandler.list(root)
 		if reflist is None:
-			print "listing of movies failed"
+			print("listing of movies failed")
 			return
 		realtags = set()
 		tags = {}
@@ -561,7 +561,7 @@
 			else:
 				realtags.update(this_tags)
 			for tag in this_tags:
-				if tags.has_key(tag):
+				if tag in tags:
 					tags[tag].append(name)
 				else:
 					tags[tag] = [name]
@@ -571,7 +571,7 @@
 			if filter_tags is not None:
 				this_tags = set(this_tags)
 				if not this_tags.issuperset(filter_tags):
-					print "Skipping", name, "tags=", this_tags, " filter=", filter_tags
+					print("Skipping", name, "tags=", this_tags, " filter=", filter_tags)
 					continue
 		
 			self.list.append((serviceref, info, begin, -1))
@@ -620,14 +620,14 @@
 		
 		# reverse the dictionary to see which unique movie each tag now references
 		rtags = {}
-		for tag, movies in tags.items():
+		for tag, movies in list(tags.items()):
 			if (len(movies) > 1) or (tag in realtags):
 				movies = tuple(movies) # a tuple can be hashed, but a list not
 				item = rtags.get(movies, [])
 				if not item: rtags[movies] = item
 				item.append(tag)
 		self.tags = {}
-		for movies, tags in rtags.items():
+		for movies, tags in list(rtags.items()):
 			movie = movies[0]
 			# format the tag lists so that they are in 'original' order
 			tags.sort(key = movie.find)
--- enigma2-nightly.org/lib/python/Components/Network.py
+++ enigma2-nightly.patched/lib/python/Components/Network.py
@@ -34,7 +34,7 @@
 
 	def onRemoteRootFS(self):
 		if self.remoteRootFS is None:
-			import Harddisk
+			from . import Harddisk
 			for parts in Harddisk.getProcMounts():
 				if parts[1] == '/' and parts[2] == 'nfs':
 					self.remoteRootFS = True
@@ -109,7 +109,7 @@
 					if bcast is not None:
 						data['bcast'] = self.convertIP(bcast)
 						
-		if not data.has_key('ip'):
+		if 'ip' not in data:
 			data['dhcp'] = True
 			data['ip'] = [0, 0, 0, 0]
 			data['netmask'] = [0, 0, 0, 0]
@@ -125,7 +125,7 @@
 		ipLinePattern = re_compile(ipRegexp)
 
 		for line in result.splitlines():
-			print line[0:7]
+			print(line[0:7])
 			if line[0:7] == "0.0.0.0":
 				gateway = self.regExpMatch(ipPattern, line[16:31])
 				if gateway:
@@ -140,7 +140,7 @@
 		fp.write("# automatically generated by enigma2\n# do NOT change manually!\n\n")
 		fp.write("auto lo\n")
 		fp.write("iface lo inet loopback\n\n")
-		for ifacename, iface in self.ifaces.items():
+		for ifacename, iface in list(self.ifaces.items()):
 			if iface['up'] == True:
 				fp.write("auto " + ifacename + "\n")
 				self.configuredInterfaces.append(ifacename)
@@ -148,17 +148,17 @@
 				fp.write("iface "+ ifacename +" inet dhcp\n")
 			if iface['dhcp'] == False:
 				fp.write("iface "+ ifacename +" inet static\n")
-				if iface.has_key('ip'):
-					print tuple(iface['ip'])
+				if 'ip' in iface:
+					print(tuple(iface['ip']))
 					fp.write("	address %d.%d.%d.%d\n" % tuple(iface['ip']))
 					fp.write("	netmask %d.%d.%d.%d\n" % tuple(iface['netmask']))
-					if iface.has_key('gateway'):
+					if 'gateway' in iface:
 						fp.write("	gateway %d.%d.%d.%d\n" % tuple(iface['gateway']))
-			if iface.has_key("configStrings"):
+			if "configStrings" in iface:
 				fp.write(iface["configStrings"])
-			if iface["preup"] is not False and not iface.has_key("configStrings"):
+			if iface["preup"] is not False and "configStrings" not in iface:
 				fp.write(iface["preup"])
-			if iface["predown"] is not False and not iface.has_key("configStrings"):
+			if iface["predown"] is not False and "configStrings" not in iface:
 				fp.write(iface["predown"])
 			fp.write("\n")				
 		fp.close()
@@ -179,7 +179,7 @@
 			interfaces = fp.readlines()
 			fp.close()
 		except:
-			print "[Network.py] interfaces - opening failed"
+			print("[Network.py] interfaces - opening failed")
 
 		ifaces = {}
 		currif = ""
@@ -194,29 +194,29 @@
 					ifaces[currif]["dhcp"] = False
 			if (currif == iface): #read information only for available interfaces
 				if (split[0] == "address"):
-					ifaces[currif]["address"] = map(int, split[1].split('.'))
-					if self.ifaces[currif].has_key("ip"):
+					ifaces[currif]["address"] = list(map(int, split[1].split('.')))
+					if "ip" in self.ifaces[currif]:
 						if self.ifaces[currif]["ip"] != ifaces[currif]["address"] and ifaces[currif]["dhcp"] == False:
-							self.ifaces[currif]["ip"] = map(int, split[1].split('.'))
+							self.ifaces[currif]["ip"] = list(map(int, split[1].split('.')))
 				if (split[0] == "netmask"):
-					ifaces[currif]["netmask"] = map(int, split[1].split('.'))
-					if self.ifaces[currif].has_key("netmask"):
+					ifaces[currif]["netmask"] = list(map(int, split[1].split('.')))
+					if "netmask" in self.ifaces[currif]:
 						if self.ifaces[currif]["netmask"] != ifaces[currif]["netmask"] and ifaces[currif]["dhcp"] == False:
-							self.ifaces[currif]["netmask"] = map(int, split[1].split('.'))
+							self.ifaces[currif]["netmask"] = list(map(int, split[1].split('.')))
 				if (split[0] == "gateway"):
-					ifaces[currif]["gateway"] = map(int, split[1].split('.'))
-					if self.ifaces[currif].has_key("gateway"):
+					ifaces[currif]["gateway"] = list(map(int, split[1].split('.')))
+					if "gateway" in self.ifaces[currif]:
 						if self.ifaces[currif]["gateway"] != ifaces[currif]["gateway"] and ifaces[currif]["dhcp"] == False:
-							self.ifaces[currif]["gateway"] = map(int, split[1].split('.'))
+							self.ifaces[currif]["gateway"] = list(map(int, split[1].split('.')))
 				if (split[0] == "pre-up"):
-					if self.ifaces[currif].has_key("preup"):
+					if "preup" in self.ifaces[currif]:
 						self.ifaces[currif]["preup"] = i
 				if (split[0] in ("pre-down","post-down")):
-					if self.ifaces[currif].has_key("predown"):
+					if "predown" in self.ifaces[currif]:
 						self.ifaces[currif]["predown"] = i
 
-		for ifacename, iface in ifaces.items():
-			if self.ifaces.has_key(ifacename):
+		for ifacename, iface in list(ifaces.items()):
+			if ifacename in self.ifaces:
 				self.ifaces[ifacename]["dhcp"] = iface["dhcp"]
 		if self.Console:
 			if len(self.Console.appContainers) == 0:
@@ -224,8 +224,8 @@
 				self.configuredNetworkAdapters = self.configuredInterfaces
 				# load ns only once	
 				self.loadNameserverConfig()
-				print "read configured interface:", ifaces
-				print "self.ifaces after loading:", self.ifaces
+				print("read configured interface:", ifaces)
+				print("self.ifaces after loading:", self.ifaces)
 				self.config_ready = True
 				self.msgPlugins()
 				if callback is not None:
@@ -243,7 +243,7 @@
 			fp.close()
 			self.nameservers = []
 		except:
-			print "[Network.py] resolv.conf - opening failed"
+			print("[Network.py] resolv.conf - opening failed")
 
 		for line in resolv:
 			if self.regExpMatch(nameserverPattern, line) is not None:
@@ -251,7 +251,7 @@
 				if ip:
 					self.nameservers.append(self.convertIP(ip))
 
-		print "nameservers:", self.nameservers
+		print("nameservers:", self.nameservers)
 
 	def getInstalledAdapters(self):
 		return [x for x in listdir('/sys/class/net') if not self.isBlacklisted(x)]
@@ -263,7 +263,7 @@
 		return len(self.ifaces)
 
 	def getFriendlyAdapterName(self, x):
-		if x in self.friendlyNames.keys():
+		if x in list(self.friendlyNames.keys()):
 			return self.friendlyNames.get(x, x)
 		self.friendlyNames[x] = self.getFriendlyAdapterNaming(x)
 		return self.friendlyNames.get(x, x) # when we have no friendly name, use adapter name
@@ -308,22 +308,22 @@
 		return iface
 
 	def getAdapterList(self):
-		return self.ifaces.keys()
+		return list(self.ifaces.keys())
 
 	def getAdapterAttribute(self, iface, attribute):
-		if self.ifaces.has_key(iface):
-			if self.ifaces[iface].has_key(attribute):
+		if iface in self.ifaces:
+			if attribute in self.ifaces[iface]:
 				return self.ifaces[iface][attribute]
 		return None
 
 	def setAdapterAttribute(self, iface, attribute, value):
-		print "setting for adapter", iface, "attribute", attribute, " to value", value
-		if self.ifaces.has_key(iface):
+		print("setting for adapter", iface, "attribute", attribute, " to value", value)
+		if iface in self.ifaces:
 			self.ifaces[iface][attribute] = value
 
 	def removeAdapterAttribute(self, iface, attribute):
-		if self.ifaces.has_key(iface):
-			if self.ifaces[iface].has_key(attribute):
+		if iface in self.ifaces:
+			if attribute in self.ifaces[iface]:
 				del self.ifaces[iface][attribute]
 
 	def getNameserverList(self):
@@ -353,7 +353,7 @@
 		self.resetNetworkConsole = Console()
 		self.commands = []
 		self.commands.append("/etc/init.d/avahi-daemon stop")
-		for iface in self.ifaces.keys():
+		for iface in list(self.ifaces.keys()):
 			if iface != 'eth0' or not self.onRemoteRootFS():
 				self.commands.append("ip addr flush dev " + iface)	
 		self.commands.append("/etc/init.d/networking stop")
@@ -433,7 +433,7 @@
 		self.msgPlugins()
 		self.commands = []
 		self.commands.append("/etc/init.d/avahi-daemon stop")
-		for iface in self.ifaces.keys():
+		for iface in list(self.ifaces.keys()):
 			if iface != 'eth0' or not self.onRemoteRootFS():
 				self.commands.append("ifdown " + iface)
 				self.commands.append("ip addr flush dev " + iface)
@@ -464,31 +464,31 @@
 	def stopPingConsole(self):
 		if self.PingConsole is not None:
 			if len(self.PingConsole.appContainers):
-				for name in self.PingConsole.appContainers.keys():
+				for name in list(self.PingConsole.appContainers.keys()):
 					self.PingConsole.kill(name)
 
 	def stopLinkStateConsole(self):
 		if self.LinkConsole is not None:
 			if len(self.LinkConsole.appContainers):
-				for name in self.LinkConsole.appContainers.keys():
+				for name in list(self.LinkConsole.appContainers.keys()):
 					self.LinkConsole.kill(name)
 					
 	def stopDNSConsole(self):
 		if self.DnsConsole is not None:
 			if len(self.DnsConsole.appContainers):
-				for name in self.DnsConsole.appContainers.keys():
+				for name in list(self.DnsConsole.appContainers.keys()):
 					self.DnsConsole.kill(name)
 					
 	def stopRestartConsole(self):
 		if self.restartConsole is not None:
 			if len(self.restartConsole.appContainers):
-				for name in self.restartConsole.appContainers.keys():
+				for name in list(self.restartConsole.appContainers.keys()):
 					self.restartConsole.kill(name)
 					
 	def stopGetInterfacesConsole(self):
 		if self.Console is not None:
 			if len(self.Console.appContainers):
-				for name in self.Console.appContainers.keys():
+				for name in list(self.Console.appContainers.keys()):
 					self.Console.kill(name)
 					
 	def stopDeactivateInterfaceConsole(self):
@@ -561,7 +561,7 @@
 	def deactivateInterfaceFinished(self,extra_args):
 		(ifaces, callback) = extra_args
 		def checkCommandResult(iface):
-			if self.deactivateInterfaceConsole and self.deactivateInterfaceConsole.appResults.has_key("ifdown " + iface):
+			if self.deactivateInterfaceConsole and "ifdown " + iface in self.deactivateInterfaceConsole.appResults:
 				result = str(self.deactivateInterfaceConsole.appResults.get("ifdown " + iface)).strip("\n")
 				if result == "ifdown: interface " + iface + " not configured":
 					return False
@@ -666,15 +666,15 @@
 	def calc_netmask(self,nmask):
 		from struct import pack, unpack
 		from socket import inet_ntoa, inet_aton
-		mask = 1L<<31
-		xnet = (1L<<32)-1
-		cidr_range = range(0, 32)
-		cidr = long(nmask)
+		mask = 1<<31
+		xnet = (1<<32)-1
+		cidr_range = list(range(0, 32))
+		cidr = int(nmask)
 		if cidr not in cidr_range:
-			print 'cidr invalid: %d' % cidr
+			print('cidr invalid: %d' % cidr)
 			return None
 		else:
-			nm = ((1L<<cidr)-1)<<(32-cidr)
+			nm = ((1<<cidr)-1)<<(32-cidr)
 			netmask = str(inet_ntoa(pack('>L', nm)))
 			return netmask
 	
--- enigma2-nightly.org/lib/python/Components/NimManager.py
+++ enigma2-nightly.patched/lib/python/Components/NimManager.py
@@ -1,7 +1,7 @@
 from Tools.HardwareInfo import HardwareInfo
 from Tools.BoundFunction import boundFunction
 
-from config import config, ConfigSubsection, ConfigSelection, ConfigFloat, \
+from .config import config, ConfigSubsection, ConfigSelection, ConfigFloat, \
 	ConfigSatlist, ConfigYesNo, ConfigInteger, ConfigSubList, ConfigNothing, \
 	ConfigSubDict, ConfigOnOff, ConfigDateTime
 
@@ -45,10 +45,10 @@
 		#simple defaults
 		sec.addLNB()
 		tunermask = 1 << slotid
-		if self.equal.has_key(slotid):
+		if slotid in self.equal:
 			for slot in self.equal[slotid]:
 				tunermask |= (1 << slot)
-		if self.linked.has_key(slotid):
+		if slotid in self.linked:
 			for slot in self.linked[slotid]:
 				tunermask |= (1 << slot)
 		sec.setLNBSatCR(-1)
@@ -81,7 +81,7 @@
 				sec.setVoltageMode(switchParam._14V)
 				sec.setToneMode(switchParam.OFF)
 		elif (diseqcmode == 3): # diseqc 1.2
-			if self.satposdepends.has_key(slotid):
+			if slotid in self.satposdepends:
 				for slot in self.satposdepends[slotid]:
 					tunermask |= (1 << slot)
 			sec.setLatitude(latitude)
@@ -93,7 +93,7 @@
 			sec.setRotorTurningSpeed(turningSpeed)
 
 			for x in self.NimManager.satList:
-				print "Add sat " + str(x[0])
+				print("Add sat " + str(x[0]))
 				self.addSatellite(sec, int(x[0]))
 				if diseqc13V:
 					sec.setVoltageMode(switchParam.HV_13)
@@ -105,7 +105,7 @@
 		sec.setLNBSlotMask(tunermask)
 
 	def setSatposDepends(self, sec, nim1, nim2):
-		print "tuner", nim1, "depends on satpos of", nim2
+		print("tuner", nim1, "depends on satpos of", nim2)
 		sec.setTunerDepends(nim1, nim2)
 
 	def linkInternally(self, slotid):
@@ -114,7 +114,7 @@
 			nim.setInternalLink()
 
 	def linkNIMs(self, sec, nim1, nim2):
-		print "link tuner", nim1, "to tuner", nim2
+		print("link tuner", nim1, "to tuner", nim2)
 		if nim2 == (nim1 - 1):
 			self.linkInternally(nim1)
 		sec.setTunerLinked(nim1, nim2)
@@ -135,7 +135,7 @@
 			if self.NimManager.nimInternallyConnectableTo(slotid) is not None:
 				self.NimManager.nimRemoveInternalLink(slotid)
 		sec.clear() ## this do unlinking NIMs too !!
-		print "sec config cleared"
+		print("sec config cleared")
 
 		self.linked = { }
 		self.satposdepends = { }
@@ -166,19 +166,19 @@
 				# this is stored in the *value* (not index!) of the config list
 				if nim.configMode.value == "equal":
 					connto = self.getRoot(x, int(nim.connectedTo.value))
-					if not self.equal.has_key(connto):
+					if connto not in self.equal:
 						self.equal[connto] = []
 					self.equal[connto].append(x)
 				elif nim.configMode.value == "loopthrough":
 					self.linkNIMs(sec, x, int(nim.connectedTo.value))
 					connto = self.getRoot(x, int(nim.connectedTo.value))
-					if not self.linked.has_key(connto):
+					if connto not in self.linked:
 						self.linked[connto] = []
 					self.linked[connto].append(x)
 				elif nim.configMode.value == "satposdepends":
 					self.setSatposDepends(sec, x, int(nim.connectedTo.value))
 					connto = self.getRoot(x, int(nim.connectedTo.value))
-					if not self.satposdepends.has_key(connto):
+					if connto not in self.satposdepends:
 						self.satposdepends[connto] = []
 					self.satposdepends[connto].append(x)
 
@@ -187,7 +187,7 @@
 			nim = slot.config
 			hw = HardwareInfo()
 			if slot.isCompatible("DVB-S"):
-				print "slot: " + str(x) + " configmode: " + str(nim.configMode.value)
+				print("slot: " + str(x) + " configmode: " + str(nim.configMode.value))
 				if nim.configMode.value in ( "loopthrough", "satposdepends", "nothing" ):
 					pass
 				else:
@@ -195,7 +195,7 @@
 					if nim.configMode.value == "equal":
 						pass
 					elif nim.configMode.value == "simple":		#simple config
-						print "diseqcmode: ", nim.diseqcMode.value
+						print("diseqcmode: ", nim.diseqcMode.value)
 						if nim.diseqcMode.value == "single":			#single
 							if nim.simpleSingleSendDiSEqC.value:
 								self.addLNBSimple(sec, slotid = x, orbpos = nim.diseqcA.orbital_position, toneburstmode = diseqcParam.NO, diseqcmode = diseqcParam.V1_0, diseqcpos = diseqcParam.AA, diseqc13V = nim.diseqc13V.value)
@@ -231,7 +231,7 @@
 							if nim.powerMeasurement.value:
 								useInputPower=True
 								turn_speed_dict = { "fast": rotorParam.FAST, "slow": rotorParam.SLOW }
-								if turn_speed_dict.has_key(nim.turningSpeed.value):
+								if nim.turningSpeed.value in turn_speed_dict:
 									turning_speed = turn_speed_dict[nim.turningSpeed.value]
 								else:
 									beg_time = localtime(nim.fastTurningBegin.value)
@@ -249,7 +249,7 @@
 								diseqc13V = nim.diseqc13V.value)
 					elif nim.configMode.value == "advanced": #advanced config
 						self.updateAdvanced(sec, x)
-		print "sec config completed"
+		print("sec config completed")
 
 	def updateAdvanced(self, sec, slotid):
 		try:
@@ -258,7 +258,7 @@
 					config.Nims[slotid].advanced.unicableconnectedTo.save_forced = True
 					self.linkNIMs(sec, slotid, int(config.Nims[slotid].advanced.unicableconnectedTo.value))
 					connto = self.getRoot(slotid, int(config.Nims[slotid].advanced.unicableconnectedTo.value))
-					if not self.linked.has_key(connto):
+					if connto not in self.linked:
 						self.linked[connto] = []
 					self.linked[connto].append(slotid)
 				else:
@@ -275,13 +275,13 @@
 			lnb = int(config.Nims[slotid].advanced.sat[x].lnb.value)
 			if lnb != 0:
 				for x in self.NimManager.satList:
-					print "add", x[0], "to", lnb
+					print("add", x[0], "to", lnb)
 					lnbSat[lnb].append(x[0])
 
 		for x in self.NimManager.satList:
 			lnb = int(config.Nims[slotid].advanced.sat[x[0]].lnb.value)
 			if lnb != 0:
-				print "add", x[0], "to", lnb
+				print("add", x[0], "to", lnb)
 				lnbSat[lnb].append(x[0])
 
 		for x in range(1,37):
@@ -293,10 +293,10 @@
 					sec.setLNBNum(x)
 
 				tunermask = 1 << slotid
-				if self.equal.has_key(slotid):
+				if slotid in self.equal:
 					for slot in self.equal[slotid]:
 						tunermask |= (1 << slot)
-				if self.linked.has_key(slotid):
+				if slotid in self.linked:
 					for slot in self.linked[slotid]:
 						tunermask |= (1 << slot)
 
@@ -363,7 +363,7 @@
 				elif dm == "1_2":
 					sec.setDiSEqCMode(diseqcParam.V1_2)
 
-					if self.satposdepends.has_key(slotid):
+					if slotid in self.satposdepends:
 						for slot in self.satposdepends[slotid]:
 							tunermask |= (1 << slot)
 
@@ -384,10 +384,10 @@
 						"BA": diseqcParam.BA,
 						"BB": diseqcParam.BB }
 
-					if c.has_key(cdc):
+					if cdc in c:
 						sec.setCommittedCommand(c[cdc])
 					else:
-						sec.setCommittedCommand(long(cdc))
+						sec.setCommittedCommand(int(cdc))
 
 					sec.setFastDiSEqC(currLnb.fastDiseqc.value)
 
@@ -436,7 +436,7 @@
 						sec.setUseInputpower(True)
 						sec.setInputpowerDelta(currLnb.powerThreshold.value)
 						turn_speed_dict = { "fast": rotorParam.FAST, "slow": rotorParam.SLOW }
-						if turn_speed_dict.has_key(currLnb.turningSpeed.value):
+						if currLnb.turningSpeed.value in turn_speed_dict:
 							turning_speed = turn_speed_dict[currLnb.turningSpeed.value]
 						else:
 							beg_time = localtime(currLnb.fastTurningBegin.value)
@@ -491,7 +491,7 @@
 		self.slot = slot
 
 		if type not in ("DVB-S", "DVB-C", "DVB-T", "DVB-S2", "DVB-T2", "DVB-C2", "ATSC", None):
-			print "warning: unknown NIM type %s, not using." % type
+			print("warning: unknown NIM type %s, not using." % type)
 			type = None
 
 		self.type = type
@@ -524,7 +524,7 @@
 			return False
 		if self.isCompatible(what):
 			return True
-		for type in self.multi_type.values():
+		for type in list(self.multi_type.values()):
 			if what in self.compatible[type]:
 				return True
 		return False
@@ -571,12 +571,12 @@
 
 	def setInternalLink(self):
 		if self.internally_connectable is not None:
-			print "setting internal link on frontend id", self.frontend_id
+			print("setting internal link on frontend id", self.frontend_id)
 			open("/proc/stb/frontend/%d/rf_switch" % self.frontend_id, "w").write("internal")
 
 	def removeInternalLink(self):
 		if self.internally_connectable is not None:
-			print "removing internal link on frontend id", self.frontend_id
+			print("removing internal link on frontend id", self.frontend_id)
 			open("/proc/stb/frontend/%d/rf_switch" % self.frontend_id, "w").write("external")
 
 	def isMultiType(self):
@@ -631,7 +631,7 @@
 		return self.sec.getConfiguredSats()
 
 	def getTransponders(self, pos):
-		if self.transponders.has_key(pos):
+		if pos in self.transponders:
 			return self.transponders[pos]
 		else:
 			return []
@@ -677,7 +677,7 @@
 		self.transpondersatsc = { }
 		db = eDVBDB.getInstance()
 		if self.hasNimType("DVB-S"):
-			print "Reading satellites.xml"
+			print("Reading satellites.xml")
 			db.readSatellites(self.satList, self.satellites, self.transponders)
 			self.satList.sort() # sort by orbpos
 			#print "SATLIST", self.satList
@@ -685,19 +685,19 @@
 			#print "TRANSPONDERS", self.transponders
 
 		if self.hasNimType("DVB-C"):
-			print "Reading cables.xml"
+			print("Reading cables.xml")
 			db.readCables(self.cablesList, self.transponderscable)
 #			print "CABLIST", self.cablesList
 #			print "TRANSPONDERS", self.transponders
 
 		if self.hasNimType("DVB-T"):
-			print "Reading terrestrial.xml"
+			print("Reading terrestrial.xml")
 			db.readTerrestrials(self.terrestrialsList, self.transpondersterrestrial)
 #			print "TERLIST", self.terrestrialsList
 #			print "TRANSPONDERS", self.transpondersterrestrial
 
 		if self.hasNimType("ATSC"):
-			print "Reading atsc.xml"
+			print("Reading atsc.xml")
 			#db.readATSC(self.atscList, self.transpondersatsc)
 
 	def enumerateNIMs(self):
@@ -774,22 +774,22 @@
 
 		from os import path
 
-		for id, entry in entries.items():
-			if not (entry.has_key("name") and entry.has_key("type")):
+		for id, entry in list(entries.items()):
+			if not ("name" in entry and "type" in entry):
 				entry["name"] =  _("N/A")
 				entry["type"] = None
-			if not (entry.has_key("i2c")):
+			if not ("i2c" in entry):
 				entry["i2c"] = None
-			if not (entry.has_key("has_outputs")):
+			if not ("has_outputs" in entry):
 				entry["has_outputs"] = True
-			if entry.has_key("frontend_device"): # check if internally connectable
+			if "frontend_device" in entry: # check if internally connectable
 				if path.exists("/proc/stb/frontend/%d/rf_switch" % entry["frontend_device"]):
 					entry["internally_connectable"] = entry["frontend_device"] - 1
 				else:
 					entry["internally_connectable"] = None
 			else:
 				entry["frontend_device"] = entry["internally_connectable"] = None
-			if not (entry.has_key("multi_type")):
+			if not ("multi_type" in entry):
 				entry["multi_type"] = {}
 			self.nim_slots.append(NIM(slot = id, description = entry["name"], type = entry["type"], has_outputs = entry["has_outputs"], internally_connectable = entry["internally_connectable"], multi_type = entry["multi_type"], frontend_id = entry["frontend_device"], i2c = entry["i2c"], is_empty = entry["isempty"]))
 
@@ -797,7 +797,7 @@
 		for slot in self.nim_slots:
 			if slot.isCompatible(chktype):
 				return True
-			for type in slot.getMultiTypeList().values():
+			for type in list(slot.getMultiTypeList().values()):
 				if chktype == type:
 					return True
 		return False
@@ -865,7 +865,7 @@
 		for testnim in slots[:]:
 			for nim in self.getNimListOfType("DVB-S", slotid):
 				nimConfig = self.getNimConfig(nim)
-				if nimConfig.content.items.has_key("configMode") and nimConfig.configMode.value == "loopthrough" and int(nimConfig.connectedTo.value) == testnim:
+				if "configMode" in nimConfig.content.items and nimConfig.configMode.value == "loopthrough" and int(nimConfig.connectedTo.value) == testnim:
 					slots.remove(testnim)
 					break
 		slots.sort()
@@ -896,7 +896,7 @@
 						nimHaveRotor = True
 						break
 				if not nimHaveRotor:
-					for sat in mode.advanced.sat.values():
+					for sat in list(mode.advanced.sat.values()):
 						lnb_num = int(sat.lnb.value)
 						diseqcmode = lnb_num and mode.advanced.lnb[lnb_num].diseqcMode.value or ""
 						if diseqcmode == "1_2":
@@ -1165,9 +1165,9 @@
 			m.update({product.get("name"):tuple(scr)})
 		unicablematrixproducts.update({manufacturer.get("name"):m})
 
-	UnicableLnbManufacturers = unicablelnbproducts.keys()
+	UnicableLnbManufacturers = list(unicablelnbproducts.keys())
 	UnicableLnbManufacturers.sort()
-	UnicableMatrixManufacturers = unicablematrixproducts.keys()
+	UnicableMatrixManufacturers = list(unicablematrixproducts.keys())
 	UnicableMatrixManufacturers.sort()
 
 	unicable_choices = {
@@ -1180,7 +1180,7 @@
 					("5", "SatCR 5"), ("6", "SatCR 6"), ("7", "SatCR 7"), ("8", "SatCR 8")]
 
 	prio_list = [ ("-1", _("Auto")) ]
-	prio_list += [(str(prio), str(prio)) for prio in range(65)+range(14000,14065)+range(19000,19065)]
+	prio_list += [(str(prio), str(prio)) for prio in list(range(65))+list(range(14000,14065))+list(range(19000,19065))]
 
 	advanced_lnb_csw_choices = [("none", _("None")), ("AA", _("AA")), ("AB", _("AB")), ("BA", _("BA")), ("BB", _("BB"))]
 	advanced_lnb_csw_choices += [(str(0xF0|y), "Input " + str(y+1)) for y in range(0, 16)]
@@ -1235,7 +1235,7 @@
 
 				def fillUnicableConf(sectionDict, unicableproducts, vco_null_check):
 					for y in unicableproducts:
-						products = unicableproducts[y].keys()
+						products = list(unicableproducts[y].keys())
 						products.sort()
 						tmp = ConfigSubsection()
 						tmp.product = ConfigSelection(choices = products, default = products[0])
@@ -1276,13 +1276,13 @@
 						sectionDict[y] = tmp
 
 				if lnb < 3:
-					print "MATRIX"
+					print("MATRIX")
 					section.unicableMatrix = ConfigSubDict()
 					section.unicableMatrixManufacturer = ConfigSelection(UnicableMatrixManufacturers, UnicableMatrixManufacturers[0])
 					fillUnicableConf(section.unicableMatrix, unicablematrixproducts, True)
 
 				if lnb < 2:
-					print "LNB"
+					print("LNB")
 					section.unicableLnb = ConfigSubDict()
 					section.unicableLnbManufacturer = ConfigSelection(UnicableLnbManufacturers, UnicableLnbManufacturers[0])
 					fillUnicableConf(section.unicableLnb, unicablelnbproducts, False)
@@ -1524,7 +1524,7 @@
 			empty_slots += 1
 			nim.configMode = ConfigSelection(choices = { "nothing": _("disabled") }, default="nothing");
 			if slot.type is not None:
-				print "pls add support for this frontend type!", slot.type
+				print("pls add support for this frontend type!", slot.type)
 #			assert False
 
 	nimmgr.sec = SecConfigure(nimmgr)
@@ -1536,13 +1536,13 @@
 		if os.path.exists("/proc/stb/frontend/%d/mode" % fe_id):
 			cur_type = int(open("/proc/stb/frontend/%d/mode" % (fe_id), "r").read())
 			if cur_type != int(configElement.value):
-				print "tunerTypeChanged feid %d from %d to mode %d" % (fe_id, cur_type, int(configElement.value))
+				print("tunerTypeChanged feid %d from %d to mode %d" % (fe_id, cur_type, int(configElement.value)))
 
 				try:
 					oldvalue = open("/sys/module/dvb_core/parameters/dvb_shutdown_timeout", "r").readline()
 					open("/sys/module/dvb_core/parameters/dvb_shutdown_timeout", "w").write("0")
 				except:
-					print "[info] no /sys/module/dvb_core/parameters/dvb_shutdown_timeout available"
+					print("[info] no /sys/module/dvb_core/parameters/dvb_shutdown_timeout available")
 
 				frontend = eDVBResourceManager.getInstance().allocateRawChannel(fe_id).getFrontend()
 				frontend.closeFrontend()
@@ -1551,10 +1551,10 @@
 				try:
 					open("/sys/module/dvb_core/parameters/dvb_shutdown_timeout", "w").write(oldvalue)
 				except:
-					print "[info] no /sys/module/dvb_core/parameters/dvb_shutdown_timeout available"
+					print("[info] no /sys/module/dvb_core/parameters/dvb_shutdown_timeout available")
 				nimmgr.enumerateNIMs()
 			else:
-				print "tuner type is already already %d" %cur_type
+				print("tuner type is already already %d" %cur_type)
 
 	empty_slots = 0
 	for slot in nimmgr.nim_slots:
@@ -1567,7 +1567,7 @@
 			addMultiType = True
 		if slot.isMultiType() and addMultiType:
 			typeList = []
-			for id in slot.getMultiTypeList().keys():
+			for id in list(slot.getMultiTypeList().keys()):
 				type = slot.getMultiTypeList()[id]
 				typeList.append((id, type))
 			nim.multiType = ConfigSelection(typeList, "0")
--- enigma2-nightly.org/lib/python/Components/PackageInfo.py
+++ enigma2-nightly.patched/lib/python/Components/PackageInfo.py
@@ -26,19 +26,19 @@
 		self.data = ""
 
 	def printError(self, error):
-		raise InfoHandlerParseError, error
+		raise InfoHandlerParseError(error)
 
 	def startElement(self, name, attrs):
 		self.elements.append(name)
 
 		if name in ("hardware", "bcastsystem", "satellite", "tag", "flag"):
-			if not attrs.has_key("type"):
+			if "type" not in attrs:
 					self.printError(str(name) + " tag with no type attribute")
 			if self.elements[-3] in ("default", "package"):
 				prerequisites = self.globalprerequisites
 			else:
 				prerequisites = self.prerequisites
-			if not prerequisites.has_key(name):
+			if name not in prerequisites:
 				prerequisites[name] = []
 			prerequisites[name].append(str(attrs["type"]))
 
@@ -47,7 +47,7 @@
 			self.data = ""
 
 		if name == "files":
-			if attrs.has_key("type"):
+			if "type" in attrs:
 				if attrs["type"] == "directories":
 					self.attributes["filestype"] = "directories"
 				elif attrs["type"] == "package":
@@ -55,13 +55,13 @@
 
 		if name == "file":
 			self.prerequisites = {}
-			if not attrs.has_key("type"):
+			if "type" not in attrs:
 				self.printError("file tag with no type attribute")
 			else:
-				if not attrs.has_key("name"):
+				if "name" not in attrs:
 					self.printError("file tag with no name attribute")
 				else:	
-					if not attrs.has_key("directory"):
+					if "directory" not in attrs:
 						directory = self.directory
 					type = attrs["type"]
 					if not type in self.validFileTypes:
@@ -71,30 +71,30 @@
 						self.fileattrs = attrs
 
 		if name == "package":
-			if attrs.has_key("details"):
+			if "details" in attrs:
 				self.attributes["details"] = str(attrs["details"])
-			if attrs.has_key("name"):
+			if "name" in attrs:
 				self.attributes["name"] = str(attrs["name"])
-			if attrs.has_key("packagename"):
+			if "packagename" in attrs:
 				self.attributes["packagename"] = str(attrs["packagename"])
-			if attrs.has_key("packagetype"):
+			if "packagetype" in attrs:
 				self.attributes["packagetype"] = str(attrs["packagetype"])
-			if attrs.has_key("needsRestart"):
+			if "needsRestart" in attrs:
 				self.attributes["needsRestart"] = str(attrs["needsRestart"])
-			if attrs.has_key("shortdescription"):
+			if "shortdescription" in attrs:
 				self.attributes["shortdescription"] = str(attrs["shortdescription"])
 
 		if name == "screenshot":
-			if attrs.has_key("src"):
+			if "src" in attrs:
 				self.attributes["screenshot"] = str(attrs["src"])
 
 	def endElement(self, name):
 		self.elements.pop()
 		if name == "file":
 			if len(self.prerequisites) == 0 or self.prerequisitesMet(self.prerequisites):
-				if not self.attributes.has_key(self.filetype):
+				if self.filetype not in self.attributes:
 					self.attributes[self.filetype] = []
-				if self.fileattrs.has_key("directory"):
+				if "directory" in self.fileattrs:
 					directory = str(self.fileattrs["directory"])
 					if len(directory) < 1 or directory[0] != "/":
 						directory = self.directory + directory
@@ -235,39 +235,39 @@
 	def prerequisiteMet(self, prerequisites):
 		met = True
 		if self.neededTag is None:
-			if prerequisites.has_key("tag"):
+			if "tag" in prerequisites:
 				return False
 		elif self.neededTag == 'ALL_TAGS':
 				return True
 		else:
-			if prerequisites.has_key("tag"):
+			if "tag" in prerequisites:
 				if not self.neededTag in prerequisites["tag"]:
 					return False
 			else:
 				return False
 
 		if self.neededFlag is None:
-			if prerequisites.has_key("flag"):
+			if "flag" in prerequisites:
 				return False
 		else:
-			if prerequisites.has_key("flag"):
+			if "flag" in prerequisites:
 				if not self.neededFlag in prerequisites["flag"]:
 					return False
 			else:
 				return True
 				
-		if prerequisites.has_key("satellite"):
+		if "satellite" in prerequisites:
 			for sat in prerequisites["satellite"]:
 				if int(sat) not in nimmanager.getConfiguredSats():
 					return False			
-		if prerequisites.has_key("bcastsystem"):
+		if "bcastsystem" in prerequisites:
 			has_system = False
 			for bcastsystem in prerequisites["bcastsystem"]:
 				if nimmanager.hasNimType(bcastsystem):
 					has_system = True
 			if not has_system:
 				return False
-		if prerequisites.has_key("hardware"):
+		if "hardware" in prerequisites:
 			hardware_found = False
 			for hardware in prerequisites["hardware"]:
 				if hardware == self.hardware_info.device_name:
@@ -321,7 +321,7 @@
 		
 		currentAttribute = self.attributeNames[self.currentAttributeIndex]
 		
-		if attributes.has_key(currentAttribute):
+		if currentAttribute in attributes:
 			if self.currentIndex >= len(attributes[currentAttribute]):
 				self.currentIndex = -1
 				self.currentAttributeIndex += 1
--- enigma2-nightly.org/lib/python/Components/ParentalControl.py
+++ enigma2-nightly.patched/lib/python/Components/ParentalControl.py
@@ -88,7 +88,7 @@
 		if self.configInitialized == False or self.storeServicePin != config.ParentalControl.storeservicepin.value:
 			self.getConfigValues()
 		service = ref.toCompareString()
-		if (config.ParentalControl.type.value == LIST_WHITELIST and not self.whitelist.has_key(service)) or (config.ParentalControl.type.value == LIST_BLACKLIST and self.blacklist.has_key(service)):
+		if (config.ParentalControl.type.value == LIST_WHITELIST and service not in self.whitelist) or (config.ParentalControl.type.value == LIST_BLACKLIST and service in self.blacklist):
 			#Check if the session pin is cached
 			if self.sessionPinCached == True:
 				return True
@@ -96,7 +96,7 @@
 			#Someone started to implement different levels of protection. Seems they were never completed
 			#I did not throw out this code, although it is of no use at the moment
 			levelNeeded = 0
-			if self.serviceLevel.has_key(service):
+			if service in self.serviceLevel:
 				levelNeeded = self.serviceLevel[service]
 			pinList = self.getPinList()[:levelNeeded + 1]
 			Notifications.AddNotificationWithCallback(boundFunction(self.servicePinEntered, ref), PinInput, triesEntry = config.ParentalControl.retries.servicepin, pinList = pinList, service = ServiceReference(ref).getServiceName(), title = _("this service is protected by a parental control pin"), windowTitle = _("Parental control"))
@@ -106,11 +106,11 @@
 		
 	def protectService(self, service):
 		if config.ParentalControl.type.value == LIST_WHITELIST:
-			if self.whitelist.has_key(service):
+			if service in self.whitelist:
 				self.serviceMethodWrapper(service, self.removeServiceFromList, self.whitelist)
 				#self.deleteWhitelistService(service)
 		else: # blacklist
-			if not self.blacklist.has_key(service):
+			if service not in self.blacklist:
 				self.serviceMethodWrapper(service, self.addServiceToList, self.blacklist)
 				#self.addBlacklistService(service)
 		#print "whitelist:", self.whitelist
@@ -120,19 +120,19 @@
 		#print "unprotect"
 		#print "config.ParentalControl.type.value:", config.ParentalControl.type.value
 		if config.ParentalControl.type.value == LIST_WHITELIST:
-			if not self.whitelist.has_key(service):
+			if service not in self.whitelist:
 				self.serviceMethodWrapper(service, self.addServiceToList, self.whitelist)
 				#self.addWhitelistService(service)
 		else: # blacklist
-			if self.blacklist.has_key(service):
+			if service in self.blacklist:
 				self.serviceMethodWrapper(service, self.removeServiceFromList, self.blacklist)
 				#self.deleteBlacklistService(service)
 		#print "whitelist:", self.whitelist
 		#print "blacklist:", self.blacklist
 
 	def getProtectionLevel(self, service):
-		if (config.ParentalControl.type.value == LIST_WHITELIST and not self.whitelist.has_key(service)) or (config.ParentalControl.type.value == LIST_BLACKLIST and self.blacklist.has_key(service)):
-			if self.serviceLevel.has_key(service):
+		if (config.ParentalControl.type.value == LIST_WHITELIST and service not in self.whitelist) or (config.ParentalControl.type.value == LIST_BLACKLIST and service in self.blacklist):
+			if service in self.serviceLevel:
 				return self.serviceLevel[service]
 			else:
 				return 0
@@ -144,13 +144,13 @@
 		#if a service is protected or not, it also returns, why (whitelist or blacklist, service or bouquet)
 		sImage = ""
 		if (config.ParentalControl.type.value == LIST_WHITELIST):
-			if self.whitelist.has_key(service):
+			if service in self.whitelist:
 				if TYPE_SERVICE in self.whitelist[service]:
 					sImage = IMG_WHITESERVICE
 				else:
 					sImage = IMG_WHITEBOUQUET
 		elif (config.ParentalControl.type.value == LIST_BLACKLIST):
-			if self.blacklist.has_key(service):
+			if service in self.blacklist:
 				if TYPE_SERVICE in self.blacklist[service]:
 					sImage = IMG_BLACKSERVICE
 				else:
@@ -218,7 +218,7 @@
 		#Replaces saveWhiteList and saveBlackList: 
 		#I don't like to have two functions with identical code...
 		file = open(resolveFilename(SCOPE_CONFIG, sWhichList), 'w')
-		for sService,sType in vList.iteritems():
+		for sService,sType in vList.items():
 			#Only Services that are selected directly and Bouqets are saved. 
 			#Services that are added by a bouquet are not saved. 
 			#This is the reason for the change in self.whitelist and self.blacklist
@@ -242,7 +242,7 @@
 		#Replaces addWhitelistService and addBlacklistService
 		#The lists are not only lists of service references any more. 
 		#They are named lists with the service as key and an array of types as value:
-		if vList.has_key(service):
+		if service in vList:
 			if not type in vList[service]:
 				vList[service].append(type)
 		else:
@@ -250,12 +250,12 @@
 	
 	def removeServiceFromList(self, service, type, vList):
 		#Replaces deleteWhitelistService and deleteBlacklistService
-		if vList.has_key(service):
+		if service in vList:
 			if type in vList[service]:
 				vList[service].remove(type)
 			if not vList[service]:
 				del vList[service]
-		if self.serviceLevel.has_key(service):
+		if service in self.serviceLevel:
 			self.serviceLevel.remove(service)
 		
 	def readServicesFromBouquet(self,sBouquetSelection,formatstring):
@@ -286,6 +286,6 @@
 			if not self.filesOpened:
 				self.open()
 				return getattr(self, name)
-		raise AttributeError, name
+		raise AttributeError(name)
 			
 
--- enigma2-nightly.org/lib/python/Components/ParentalControlList.py
+++ enigma2-nightly.patched/lib/python/Components/ParentalControlList.py
@@ -1,4 +1,4 @@
-from MenuList import MenuList
+from .MenuList import MenuList
 from Components.ParentalControl import IMG_WHITESERVICE, IMG_WHITEBOUQUET, IMG_BLACKSERVICE, IMG_BLACKBOUQUET
 from Tools.Directories import SCOPE_SKIN_IMAGE, resolveFilename
 
@@ -33,8 +33,8 @@
 
 	def toggleSelectedLock(self):
 		from Components.ParentalControl import parentalControl
-		print "self.l.getCurrentSelection():", self.l.getCurrentSelection()
-		print "self.l.getCurrentSelectionIndex():", self.l.getCurrentSelectionIndex()
+		print("self.l.getCurrentSelection():", self.l.getCurrentSelection())
+		print("self.l.getCurrentSelectionIndex():", self.l.getCurrentSelectionIndex())
 		curSel = self.l.getCurrentSelection()
 		if curSel[0][2]:
 			parentalControl.unProtectService(self.l.getCurrentSelection()[0][0])
--- enigma2-nightly.org/lib/python/Components/PerServiceDisplay.py
+++ enigma2-nightly.patched/lib/python/Components/PerServiceDisplay.py
@@ -1,6 +1,6 @@
-from GUIComponent import GUIComponent
-from VariableText import VariableText
-from VariableValue import VariableValue
+from .GUIComponent import GUIComponent
+from .VariableText import VariableText
+from .VariableValue import VariableValue
 
 from enigma import iPlayableService
 from enigma import eLabel, eSlider, eTimer
@@ -31,7 +31,7 @@
 			self.navcore.event.append(PerServiceBase.event)
 
 		EventMap = EventMap.setdefault
-		for x in eventmap.iteritems():
+		for x in eventmap.items():
 			EventMap(x[0], []).append((with_event, x[1]))
 
 		# start with stopped state, so simulate that
@@ -44,7 +44,7 @@
 
 	def destroy(self):
 		EventMap = PerServiceBase.EventMap.setdefault
-		for x in self.eventmap.iteritems():
+		for x in self.eventmap.items():
 			EventMap(x[0], []).remove((self.with_event, x[1]))
 
 	def enablePolling(self, interval=60000):
--- enigma2-nightly.org/lib/python/Components/Pixmap.py
+++ enigma2-nightly.patched/lib/python/Components/Pixmap.py
@@ -1,5 +1,5 @@
-from ConditionalWidget import ConditionalWidget
-from GUIComponent import GUIComponent
+from .ConditionalWidget import ConditionalWidget
+from .GUIComponent import GUIComponent
 
 from enigma import ePixmap, eTimer
 
@@ -112,4 +112,4 @@
 			if len(self.pixmaps) > x:
 				self.instance.setPixmap(self.pixmaps[x])
 			else:
-				print "setPixmapNum(%d) failed! defined pixmaps:" %(x), self.pixmaps
+				print("setPixmapNum(%d) failed! defined pixmaps:" %(x), self.pixmaps)
--- enigma2-nightly.org/lib/python/Components/Playlist.py
+++ enigma2-nightly.patched/lib/python/Components/Playlist.py
@@ -57,7 +57,7 @@
 		return self.list
 		
 	def save(self, filename = None):
-		print "Writing playlist into file", filename
+		print("Writing playlist into file", filename)
 		file = open(filename, "w")
 		for x in self.list:
 			file.write(str(x) + "\n")
--- enigma2-nightly.org/lib/python/Components/PluginComponent.py
+++ enigma2-nightly.patched/lib/python/Components/PluginComponent.py
@@ -51,8 +51,8 @@
 						try:
 							plugin = my_import('.'.join(["Plugins", c, pluginname, "plugin"]))
 							plugins = plugin.Plugins(path=path)
-						except Exception, exc:
-							print "Plugin ", c + "/" + pluginname, "failed to load:", exc
+						except Exception as exc:
+							print("Plugin ", c + "/" + pluginname, "failed to load:", exc)
 							# supress errors due to missing plugin.py* files (badly removed plugin)
 							for fn in ('plugin.py', 'plugin.pyc', 'plugin.pyo'):
 								if os.path.exists(os.path.join(path, fn)):
@@ -61,7 +61,7 @@
 									print_exc()
 									break
 							else:
-								print "Plugin probably removed, but not cleanly in", path
+								print("Plugin probably removed, but not cleanly in", path)
 								try:
 									os.rmdir(path)
 								except:
@@ -81,8 +81,8 @@
 						if fileExists(keymap):
 							try:
 								keymapparser.readKeymap(keymap)
-							except Exception, exc:
-								print "keymap for plugin %s/%s failed to load: " % (c, pluginname), exc
+							except Exception as exc:
+								print("keymap for plugin %s/%s failed to load: " % (c, pluginname), exc)
 								self.warnings.append( (c + "/" + pluginname, str(exc)) )
 
 		# build a diff between the old list of plugins and the new one
--- enigma2-nightly.org/lib/python/Components/PluginList.py
+++ enigma2-nightly.patched/lib/python/Components/PluginList.py
@@ -1,4 +1,4 @@
-from MenuList import MenuList
+from .MenuList import MenuList
 
 from Tools.Directories import resolveFilename, SCOPE_SKIN_IMAGE
 from Components.MultiContent import MultiContentEntryText, MultiContentEntryPixmapAlphaTest
--- enigma2-nightly.org/lib/python/Components/ProgressBar.py
+++ enigma2-nightly.patched/lib/python/Components/ProgressBar.py
@@ -1,6 +1,6 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
-from VariableValue import VariableValue
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
+from .VariableValue import VariableValue
 
 from enigma import eSlider
 
--- enigma2-nightly.org/lib/python/Components/RFmod.py
+++ enigma2-nightly.patched/lib/python/Components/RFmod.py
@@ -1,4 +1,4 @@
-from config import config, ConfigSelection, ConfigSubsection, ConfigOnOff, ConfigSlider
+from .config import config, ConfigSelection, ConfigSubsection, ConfigOnOff, ConfigSlider
 from enigma import eRFmod
 from Components.SystemInfo import SystemInfo
 
--- enigma2-nightly.org/lib/python/Components/RecordingConfig.py
+++ enigma2-nightly.patched/lib/python/Components/RecordingConfig.py
@@ -1,4 +1,4 @@
-from config import ConfigNumber, ConfigYesNo, ConfigSubsection, ConfigSelection, config
+from .config import ConfigNumber, ConfigYesNo, ConfigSubsection, ConfigSelection, config
 
 def InitRecordingConfig():
 	config.recording = ConfigSubsection();
--- enigma2-nightly.org/lib/python/Components/ResourceManager.py
+++ enigma2-nightly.patched/lib/python/Components/ResourceManager.py
@@ -3,9 +3,9 @@
 		self.resourceList = {}
 		
 	def addResource(self, name, resource):
-		print "adding Resource", name
+		print("adding Resource", name)
 		self.resourceList[name] = resource
-		print "resources:", self.resourceList
+		print("resources:", self.resourceList)
 		
 		
 	def getResource(self, name):
@@ -14,7 +14,7 @@
 		return self.resourceList[name]
 	
 	def hasResource(self, name):
-		return self.resourceList.has_key(name)
+		return name in self.resourceList
 	
 	def removeResource(self, name):
 		if self.hasResource(name):
--- enigma2-nightly.org/lib/python/Components/Scanner.py
+++ enigma2-nightly.patched/lib/python/Components/Scanner.py
@@ -85,7 +85,7 @@
 		return "<ScanFile " + self.path + " (" + str(self.mimetype) + ", " + str(self.size) + " MB)>"
 
 def execute(option):
-	print "execute", option
+	print("execute", option)
 	if option is None:
 		return
 
@@ -101,7 +101,7 @@
 			l = [l]
 		scanner += l
 
-	print "scanner:", scanner
+	print("scanner:", scanner)
 
 	res = { }
 
@@ -157,7 +157,7 @@
 			l = [l]
 		scanner += l
 
-	print "scanner:", scanner
+	print("scanner:", scanner)
 
 	res = { }
 
--- enigma2-nightly.org/lib/python/Components/ScrollLabel.py
+++ enigma2-nightly.patched/lib/python/Components/ScrollLabel.py
@@ -1,6 +1,6 @@
 import skin
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
 from enigma import eLabel, eWidget, eSlider, fontRenderClass, ePoint, eSize
 
 class ScrollLabel(HTMLComponent, GUIComponent):
--- enigma2-nightly.org/lib/python/Components/SelectionList.py
+++ enigma2-nightly.patched/lib/python/Components/SelectionList.py
@@ -1,4 +1,4 @@
-from MenuList import MenuList
+from .MenuList import MenuList
 from Tools.Directories import resolveFilename, SCOPE_CURRENT_SKIN
 from enigma import eListboxPythonMultiContent, eListbox, gFont, RT_HALIGN_LEFT
 from Tools.LoadPixmap import LoadPixmap
--- enigma2-nightly.org/lib/python/Components/Sensors.py
+++ enigma2-nightly.patched/lib/python/Components/Sensors.py
@@ -23,7 +23,7 @@
 	# returns a list of sensorids of type "type"
 	def getSensorsList(self, type = None):
 		if type is None:
-			return range(len(self.sensors_list))
+			return list(range(len(self.sensors_list)))
 		list = []
 		for sensorid in range(len(self.sensors_list)):
 			if self.sensors_list[sensorid][0] == type:
--- enigma2-nightly.org/lib/python/Components/ServiceEventTracker.py
+++ enigma2-nightly.patched/lib/python/Components/ServiceEventTracker.py
@@ -106,11 +106,11 @@
 			screen.session.nav.event.append(ServiceEventTracker.event)
 			ServiceEventTracker.navcore = screen.session.nav
 		EventMap = EventMap.setdefault
-		for x in eventmap.iteritems():
+		for x in eventmap.items():
 			EventMap(x[0], []).append((self.__passall, screen, x[1]))
 		screen.onClose.append(self.__del_event)
 
 	def __del_event(self):
 		EventMap = ServiceEventTracker.EventMap.setdefault
-		for x in self.__eventmap.iteritems():
+		for x in self.__eventmap.items():
 			EventMap(x[0], []).remove((self.__passall, self.__screen, x[1]))
--- enigma2-nightly.org/lib/python/Components/ServiceList.py
+++ enigma2-nightly.patched/lib/python/Components/ServiceList.py
@@ -1,5 +1,5 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
 from skin import parseColor, parseFont
 
 from enigma import eListboxServiceContent, eListbox, eServiceCenter, eServiceReference, gFont, eRect
@@ -139,7 +139,7 @@
 
 	def moveToChar(self, char):
 		# TODO fill with life
-		print "Next char: "
+		print("Next char: ")
 		index = self.l.getNextBeginningWithChar(char)
 		indexup = self.l.getNextBeginningWithChar(char.upper())
 		if indexup != 0:
@@ -147,7 +147,7 @@
 				index = indexup
 
 		self.instance.moveSelectionTo(index)
-		print "Moving to character " + str(char)
+		print("Moving to character " + str(char))
 
 	def moveToNextMarker(self):
 		idx = self.l.getNextMarkerPos()
--- enigma2-nightly.org/lib/python/Components/ServicePosition.py
+++ enigma2-nightly.patched/lib/python/Components/ServicePosition.py
@@ -1,4 +1,4 @@
-from PerServiceDisplay import PerServiceDisplay, PerServiceBase
+from .PerServiceDisplay import PerServiceDisplay, PerServiceBase
 from Components.GUIComponent import GUIComponent
 from enigma import eTimer, iPlayableService, ePositionGauge
 import time
@@ -157,10 +157,10 @@
 		return self.__seek_position
 	
 	def setSeekPosition(self, pos):
-		print "set seek position:", pos
+		print("set seek position:", pos)
 		self.__seek_position = pos
 		if self.instance is not None:
-			print "set instance."
+			print("set instance.")
 			self.instance.setSeekPosition(pos)
 	
 	seek_pointer_position = property(getSeekPosition, setSeekPosition)
--- enigma2-nightly.org/lib/python/Components/ServiceScan.py
+++ enigma2-nightly.patched/lib/python/Components/ServiceScan.py
@@ -104,7 +104,7 @@
 								tp.Bandwidth_1_712MHz : "Bw 1.712MHz", tp.Bandwidth_10MHz : "Bw 10MHz"
 							}.get(tp.bandwidth, ""))
 					else:
-						print "unknown transponder type in scanStatusChanged"
+						print("unknown transponder type in scanStatusChanged")
 				self.network.setText(network)
 				self.transponder.setText(tp_text)
 
@@ -141,7 +141,7 @@
 		self.feid = self.scanList[self.run]["feid"]
 		self.flags = self.scanList[self.run]["flags"]
 		self.networkid = 0
-		if self.scanList[self.run].has_key("networkid"):
+		if "networkid" in self.scanList[self.run]:
 			self.networkid = self.scanList[self.run]["networkid"]
 		self.state = self.Idle
 		self.scanStatusChanged()
@@ -172,7 +172,7 @@
 		self.scan.statusChanged.get().remove(self.scanStatusChanged)
 		self.scan.newService.get().remove(self.newService)
 		if not self.isDone():
-			print "*** warning *** scan was not finished!"
+			print("*** warning *** scan was not finished!")
 
 		del self.scan
 
--- enigma2-nightly.org/lib/python/Components/SetupDevices.py
+++ enigma2-nightly.patched/lib/python/Components/SetupDevices.py
@@ -1,4 +1,4 @@
-from config import config, ConfigSelection, ConfigSubsection, ConfigOnOff, ConfigText
+from .config import config, ConfigSelection, ConfigSubsection, ConfigOnOff, ConfigText
 from Components.Timezones import timezones
 from Components.Language import language
 from Components.Keyboard import keyboard
--- enigma2-nightly.org/lib/python/Components/Slider.py
+++ enigma2-nightly.patched/lib/python/Components/Slider.py
@@ -1,6 +1,6 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
-from VariableValue import VariableValue
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
+from .VariableValue import VariableValue
 
 from enigma import eSlider
 
--- enigma2-nightly.org/lib/python/Components/Task.py
+++ enigma2-nightly.patched/lib/python/Components/Task.py
@@ -4,7 +4,7 @@
 from Tools.CList import CList
 
 class Job(object):
-	NOT_STARTED, IN_PROGRESS, FINISHED, FAILED = range(4)
+	NOT_STARTED, IN_PROGRESS, FINISHED, FAILED = list(range(4))
 	def __init__(self, name):
 		self.tasks = [ ]
 		self.resident_tasks = [ ]
@@ -68,7 +68,7 @@
 				self.callback(self, None, [])
 				self.callback = None
 			else:
-				print "still waiting for %d resident task(s) %s to finish" % (len(self.resident_tasks), str(self.resident_tasks))
+				print("still waiting for %d resident task(s) %s to finish" % (len(self.resident_tasks), str(self.resident_tasks)))
 		else:
 			self.tasks[self.current_task].run(self.taskCallback)
 			self.state_changed()
@@ -78,18 +78,18 @@
 		if stay_resident:
 			if cb_idx not in self.resident_tasks:
 				self.resident_tasks.append(self.current_task)
-				print "task going resident:", task
+				print("task going resident:", task)
 			else:
-				print "task keeps staying resident:", task
+				print("task keeps staying resident:", task)
 				return
 		if len(res):
-			print ">>> Error:", res
+			print(">>> Error:", res)
 			self.status = self.FAILED
 			self.state_changed()
 			self.callback(self, task, res)
 		if cb_idx != self.current_task:
 			if cb_idx in self.resident_tasks:
-				print "resident task finished:", task
+				print("resident task finished:", task)
 				self.resident_tasks.remove(cb_idx)
 		if res == []:
 			self.state_changed()
@@ -169,26 +169,26 @@
 		if self.cwd is not None:
 			self.container.setCWD(self.cwd)
 		if not self.cmd and self.cmdline:
-			print "execute:", self.container.execute(self.cmdline), self.cmdline
+			print("execute:", self.container.execute(self.cmdline), self.cmdline)
 		else:
 			assert self.cmd is not None
 			assert len(self.args) >= 1
-			print "execute:", self.container.execute(self.cmd, *self.args), ' '.join(self.args)
+			print("execute:", self.container.execute(self.cmd, *self.args), ' '.join(self.args))
 		if self.initial_input:
 			self.writeInput(self.initial_input)
 
 	def run(self, callback):
 		failed_preconditions = self.checkPreconditions(True) + self.checkPreconditions(False)
 		if failed_preconditions:
-			print "[Task] preconditions failed"
+			print("[Task] preconditions failed")
 			callback(self, failed_preconditions)
 			return
 		self.callback = callback
 		try:
 			self.prepare()
 			self._run()
-		except Exception, ex:
-			print "[Task] exception:", ex
+		except Exception as ex:
+			print("[Task] exception:", ex)
 			self.postconditions = [FailedPostcondition(ex)]
 			self.finish()
 
@@ -214,7 +214,7 @@
 			self.output_line = self.output_line[i+1:]
 
 	def processOutputLine(self, line):
-		print "[Task %s]" % self.name, line[:-1]
+		print("[Task %s]" % self.name, line[:-1])
 		pass
 
 	def processFinished(self, returncode):
@@ -266,7 +266,7 @@
 		Task.__init__(self, job, name)
 		self.log = []
 	def processOutput(self, data):
-		print "[%s]" % self.name, data,
+		print("[%s]" % self.name, data, end=' ')
 		self.log.append(data)
 
 
@@ -281,7 +281,7 @@
 		self.timer.callback.append(self.onTimer)
 		self.timer.start(5)
 	def work(self):
-		raise NotImplemented, "work"
+		raise NotImplemented("work")
 	def abort(self):
 		self.aborted = True
 		if self.callback is None:
@@ -324,9 +324,9 @@
 		self.triggerCount += 1
 		try:
 			if (self.timeoutCount is not None) and (self.triggerCount > self.timeoutCount):
-				raise Exception, "Timeout elapsed, sorry"
+				raise Exception("Timeout elapsed, sorry")
 			res = self.check()
-		except Exception, e:
+		except Exception as e:
 			self.postconditions.append(FailedPostcondition(e))
 			res = True
 		if res:
@@ -372,7 +372,7 @@
 			return False
 
 	def jobDone(self, job, task, problems):
-		print "job", job, "completed with", problems, "in", task
+		print("job", job, "completed with", problems, "in", task)
 		if problems:
 			if not job.onFail(job, task, problems):
 				self.errorCB(False)
@@ -392,10 +392,10 @@
 
 	def errorCB(self, answer):
 		if answer:
-			print "retrying job"
+			print("retrying job")
 			self.active_job.retry()
 		else:
-			print "not retrying job."
+			print("not retrying job.")
 			self.failed_jobs.append(self.active_job)
 			self.active_job = None
 			self.kick()
@@ -474,13 +474,13 @@
 		import os
 		if task.cmd[0]=='/':
 			self.realpath = task.cmd
-			print "[Task.py][ToolExistsPrecondition] WARNING: usage of absolute paths for tasks should be avoided!" 
+			print("[Task.py][ToolExistsPrecondition] WARNING: usage of absolute paths for tasks should be avoided!") 
 			return os.access(self.realpath, os.X_OK)
 		else:
 			self.realpath = task.cmd
 			path = os.environ.get('PATH', '').split(os.pathsep)
 			path.append(task.cwd + '/')
-			absolutes = filter(lambda file: os.access(file, os.X_OK), map(lambda directory, file = task.cmd: os.path.join(directory, file), path))
+			absolutes = [file for file in map(lambda directory, file = task.cmd: os.path.join(directory, file), path) if os.access(file, os.X_OK)]
 			if absolutes:
 				self.realpath = absolutes[0]
 				return True
--- enigma2-nightly.org/lib/python/Components/TimerList.py
+++ enigma2-nightly.patched/lib/python/Components/TimerList.py
@@ -1,5 +1,5 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
 
 from Tools.FuzzyDate import FuzzyTime
 
--- enigma2-nightly.org/lib/python/Components/TimerSanityCheck.py
+++ enigma2-nightly.patched/lib/python/Components/TimerSanityCheck.py
@@ -216,7 +216,7 @@
 					if entry[1] == timer:
 						overlaplist.remove(entry)
 			else:
-				print "Bug: unknown flag!"
+				print("Bug: unknown flag!")
 			self.nrep_eventlist[idx] = (event[0],event[1],event[2],cnt,overlaplist[:]) # insert a duplicate into current overlaplist
 			idx += 1
 
@@ -258,7 +258,7 @@
 								break
 
 		if len(self.simultimer) < 2:
-			print "Possible Bug: unknown Conflict!"
+			print("Possible Bug: unknown Conflict!")
 			return True
 
 		return False # conflict detected!
--- enigma2-nightly.org/lib/python/Components/TuneTest.py
+++ enigma2-nightly.patched/lib/python/Components/TuneTest.py
@@ -9,7 +9,7 @@
 	#                    0         1             2         3       4         5       6        7          8       9      10    11
 	def tune(self, transponder):
 		if self.frontend:
-			print "tuning to transponder with data", transponder
+			print("tuning to transponder with data", transponder)
 			parm = eDVBFrontendParametersSatellite()
 			parm.frequency = transponder[0] * 1000
 			parm.symbol_rate = transponder[1] * 1000
@@ -47,7 +47,7 @@
 		self.feid = feid
 		self.transponderlist = []
 		self.currTuned = None
-		print "TuneTest for feid %d" % self.feid
+		print("TuneTest for feid %d" % self.feid)
 		if not self.openFrontend():
 			self.oldref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
 			self.session.nav.stopService() # try to disable foreground service
@@ -62,7 +62,7 @@
 		self.timer.callback.append(self.updateStatus)
 		
 	def gotTsidOnid(self, tsid, onid):
-		print "******** got tsid, onid:", tsid, onid
+		print("******** got tsid, onid:", tsid, onid)
 		if tsid is not None and onid is not None:
 			self.pidStatus = self.INTERNAL_PID_STATUS_SUCCESSFUL
 			self.tsid = tsid
@@ -78,21 +78,21 @@
 		self.frontend.getFrontendStatus(dict)
 		stop = False
 		
-		print "status:", dict
+		print("status:", dict)
 		if dict["tuner_state"] == "TUNING":
-			print "TUNING"
+			print("TUNING")
 			self.timer.start(100, True)
 			self.progressCallback((self.getProgressLength(), self.tuningtransponder, self.STATUS_TUNING, self.currTuned))
 		elif self.checkPIDs and self.pidStatus == self.INTERNAL_PID_STATUS_NOOP:
-			print "2nd choice"
+			print("2nd choice")
 			if dict["tuner_state"] == "LOCKED":
-				print "acquiring TSID/ONID"
+				print("acquiring TSID/ONID")
 				self.raw_channel.requestTsidOnid(self.gotTsidOnid)
 				self.pidStatus = self.INTERNAL_PID_STATUS_WAITING
 			else:
 				self.pidStatus = self.INTERNAL_PID_STATUS_FAILED
 		elif self.checkPIDs and self.pidStatus == self.INTERNAL_PID_STATUS_WAITING:
-			print "waiting for pids"			
+			print("waiting for pids")			
 		else:
 			if dict["tuner_state"] == "LOSTLOCK" or dict["tuner_state"] == "FAILED":
 				self.tuningtransponder = self.nextTransponder()
@@ -116,7 +116,7 @@
 								stop = True
 				self.tuningtransponder = self.nextTransponder()
 			else:
-				print "************* tuner_state:", dict["tuner_state"]
+				print("************* tuner_state:", dict["tuner_state"])
 				
 			self.progressCallback((self.getProgressLength(), self.tuningtransponder, self.STATUS_NOOP, self.currTuned))
 			
@@ -125,45 +125,45 @@
 		if self.tuningtransponder < len(self.transponderlist) and not stop:
 			if self.pidStatus != self.INTERNAL_PID_STATUS_WAITING:
 				self.timer.start(100, True)
-				print "restart timer"
-			else:
-				print "not restarting timers (waiting for pids)"
+				print("restart timer")
+			else:
+				print("not restarting timers (waiting for pids)")
 		else:
 			self.progressCallback((self.getProgressLength(), len(self.transponderlist), self.STATUS_DONE, self.currTuned))
-			print "finishedChecking"
+			print("finishedChecking")
 			self.finishedChecking()
 				
 	def firstTransponder(self):
-		print "firstTransponder:"
+		print("firstTransponder:")
 		index = 0
 		if self.checkPIDs:
-			print "checkPIDs-loop"
+			print("checkPIDs-loop")
 			# check for tsid != -1 and onid != -1 
-			print "index:", index
-			print "len(self.transponderlist):", len(self.transponderlist)
+			print("index:", index)
+			print("len(self.transponderlist):", len(self.transponderlist))
 			while (index < len(self.transponderlist) and (self.transponderlist[index][10] == -1 or self.transponderlist[index][11] == -1)):
 			 	index += 1
-		print "FirstTransponder final index:", index
+		print("FirstTransponder final index:", index)
 		return index
 	
 	def nextTransponder(self):
-		print "getting next transponder", self.tuningtransponder
+		print("getting next transponder", self.tuningtransponder)
 		index = self.tuningtransponder + 1
 		if self.checkPIDs:
-			print "checkPIDs-loop"
+			print("checkPIDs-loop")
 			# check for tsid != -1 and onid != -1 
-			print "index:", index
-			print "len(self.transponderlist):", len(self.transponderlist)
+			print("index:", index)
+			print("len(self.transponderlist):", len(self.transponderlist))
 			while (index < len(self.transponderlist) and (self.transponderlist[index][10] == -1 or self.transponderlist[index][11] == -1)):
 			 	index += 1
 
-		print "next transponder index:", index
+		print("next transponder index:", index)
 		return index
 	
 	def finishedChecking(self):
-		print "finished testing"
-		print "successfull:", self.successfullyTune
-		print "failed:", self.failedTune
+		print("finished testing")
+		print("successfull:", self.successfullyTune)
+		print("failed:", self.failedTune)
 	
 	def openFrontend(self):
 		res_mgr = eDVBResourceManager.getInstance()
@@ -174,15 +174,15 @@
 				if self.frontend:
 					return True
 				else:
-					print "getFrontend failed"
-			else:
-				print "getRawChannel failed"
-		else:
-			print "getResourceManager instance failed"
+					print("getFrontend failed")
+			else:
+				print("getRawChannel failed")
+		else:
+			print("getResourceManager instance failed")
 		return False
 
 	def tune(self):
-		print "tuning to", self.tuningtransponder
+		print("tuning to", self.tuningtransponder)
 		if self.tuningtransponder < len(self.transponderlist):
 			self.pidStatus = self.INTERNAL_PID_STATUS_NOOP
 			self.oldTuned = self.currTuned
--- enigma2-nightly.org/lib/python/Components/TunerInfo.py
+++ enigma2-nightly.patched/lib/python/Components/TunerInfo.py
@@ -1,4 +1,4 @@
-from GUIComponent import GUIComponent
+from .GUIComponent import GUIComponent
 
 from enigma import eLabel, eSlider, iFrontendInformation
 
@@ -44,7 +44,7 @@
 		if not val:
 			return 0
 		if val < 2500:
-			return (long)(log(val)/log(2))
+			return (int)(log(val)/log(2))
 		return val*100/65535
 
 	def update(self):
--- enigma2-nightly.org/lib/python/Components/UsageConfig.py
+++ enigma2-nightly.patched/lib/python/Components/UsageConfig.py
@@ -1,12 +1,12 @@
 from Components.Harddisk import harddiskmanager
-from config import ConfigSubsection, ConfigYesNo, config, ConfigSelection, ConfigText, ConfigNumber, ConfigSet, ConfigLocations, ConfigSelectionNumber
+from .config import ConfigSubsection, ConfigYesNo, config, ConfigSelection, ConfigText, ConfigNumber, ConfigSet, ConfigLocations, ConfigSelectionNumber
 from Tools.Directories import resolveFilename, SCOPE_HDD
 from enigma import setTunerTypePriorityOrder, setPreferredTuner, setSpinnerOnOff, setEnableTtCachingOnOff;
 from enigma import Misc_Options, eEnv;
 from Components.NimManager import nimmanager
 from Components.Harddisk import harddiskmanager
 from Components.ServiceList import refreshServiceList
-from SystemInfo import SystemInfo
+from .SystemInfo import SystemInfo
 import os
 import enigma
 
@@ -403,7 +403,7 @@
 				if x < val:
 					defval = str(x)
 					break
-		sel.setChoices(map(str, choices), defval)
+		sel.setChoices(list(map(str, choices)), defval)
 
 def preferredPath(path):
 	if config.usage.setup_level.index < 2 or path == "<default>":
--- enigma2-nightly.org/lib/python/Components/VariableValue.py
+++ enigma2-nightly.patched/lib/python/Components/VariableValue.py
@@ -16,8 +16,8 @@
 		return self.__value
 
 	def postWidgetCreate(self, instance):
-		print self
-		print self.GUI_WIDGET
+		print(self)
+		print(self.GUI_WIDGET)
 		self.instance.setValue(self.__value)
 
 	value = property(getValue, setValue)
--- enigma2-nightly.org/lib/python/Components/VideoWindow.py
+++ enigma2-nightly.patched/lib/python/Components/VideoWindow.py
@@ -1,4 +1,4 @@
-from GUIComponent import GUIComponent
+from .GUIComponent import GUIComponent
 from enigma import eVideoWidget, eSize
 
 class VideoWindow(GUIComponent):
--- enigma2-nightly.org/lib/python/Components/VolumeBar.py
+++ enigma2-nightly.patched/lib/python/Components/VolumeBar.py
@@ -1,6 +1,6 @@
-from HTMLComponent import HTMLComponent
-from GUIComponent import GUIComponent
-from VariableValue import VariableValue
+from .HTMLComponent import HTMLComponent
+from .GUIComponent import GUIComponent
+from .VariableValue import VariableValue
 
 from enigma import eSlider
 
--- enigma2-nightly.org/lib/python/Components/VolumeControl.py
+++ enigma2-nightly.patched/lib/python/Components/VolumeControl.py
@@ -3,7 +3,7 @@
 from Screens.Volume import Volume
 from Screens.Mute import Mute
 from GlobalActions import globalActionMap
-from config import config, ConfigSubsection, ConfigInteger
+from .config import config, ConfigSubsection, ConfigInteger
 from Components.HdmiCec import HdmiCec
 
 profile("VolumeControl")
--- enigma2-nightly.org/lib/python/Components/config.py
+++ enigma2-nightly.patched/lib/python/Components/config.py
@@ -5,6 +5,7 @@
 from copy import copy as copy_copy
 from os import path as os_path
 from time import localtime, strftime
+import collections
 
 # ConfigElement, the base class of all ConfigElements.
 
@@ -113,7 +114,7 @@
 				x(self)
 
 	def addNotifier(self, notifier, initial_call = True, immediate_feedback = True):
-		assert callable(notifier), "notifiers must be callable"
+		assert isinstance(notifier, collections.Callable), "notifiers must be callable"
 		if immediate_feedback:
 			self.notifiers.append(notifier)
 		else:
@@ -153,7 +154,7 @@
 KEY_TOGGLEOW = 7
 KEY_ASCII = 8
 KEY_TIMEOUT = 9
-KEY_NUMBERS = range(12, 12+10)
+KEY_NUMBERS = list(range(12, 12+10))
 KEY_0 = 12
 KEY_9 = 12+9
 
@@ -181,7 +182,7 @@
 		if self.type == choicesList.LIST_TYPE_LIST:
 			ret = [not isinstance(x, tuple) and x or x[0] for x in self.choices]
 		else:
-			ret = self.choices.keys()
+			ret = list(self.choices.keys())
 		return ret or [""]
 
 	def __iter__(self):
@@ -200,7 +201,7 @@
 			if isinstance(ret, tuple):
 				ret = ret[0]
 			return ret
-		return self.choices.keys()[index]
+		return list(self.choices.keys())[index]
 
 	def index(self, value):
 		try:
@@ -217,7 +218,7 @@
 			else:
 				self.choices[index] = value
 		else:
-			key = self.choices.keys()[index]
+			key = list(self.choices.keys())[index]
 			orig = self.choices[key]
 			del self.choices[key]
 			self.choices[value] = orig
@@ -231,7 +232,7 @@
 			if isinstance(default, tuple):
 				default = default[0]
 		else:
-			default = choices.keys()[0]
+			default = list(choices.keys())[0]
 		return default
 
 class descriptionList(choicesList): # XXX: we might want a better name for this
@@ -239,7 +240,7 @@
 		if self.type == choicesList.LIST_TYPE_LIST:
 			ret = [not isinstance(x, tuple) and x or x[1] for x in self.choices]
 		else:
-			ret = self.choices.values()
+			ret = list(self.choices.values())
 		return ret or [""]
 
 	def __iter__(self):
@@ -712,7 +713,7 @@
 			value += str(i)
 		leftPos = sum(block_strlen[:(self.marked_block)])+self.marked_block
 		rightPos = sum(block_strlen[:(self.marked_block+1)])+self.marked_block
-		mBlock = range(leftPos, rightPos)
+		mBlock = list(range(leftPos, rightPos))
 		return (value, mBlock)
 
 	def getMulti(self, selected):
@@ -920,7 +921,7 @@
 			self.overwrite = not self.overwrite
 		elif key == KEY_ASCII:
 			self.timeout()
-			newChar = unichr(getPrevAsciiCode())
+			newChar = chr(getPrevAsciiCode())
 			if not self.useableChars or newChar in self.useableChars:
 				if self.allmarked:
 					self.deleteAllChars()
@@ -954,7 +955,7 @@
 		try:
 			return self.text.encode("utf-8")
 		except UnicodeDecodeError:
-			print "Broken UTF8!"
+			print("Broken UTF8!")
 			return self.text
 
 	def setValue(self, val):
@@ -962,7 +963,7 @@
 			self.text = val.decode("utf-8")
 		except UnicodeDecodeError:
 			self.text = val.decode("utf-8", "ignore")
-			print "Broken UTF8!"
+			print("Broken UTF8!")
 
 	value = property(getValue, setValue)
 	_value = property(getValue, setValue)
@@ -973,13 +974,13 @@
 	def getMulti(self, selected):
 		if self.visible_width:
 			if self.allmarked:
-				mark = range(0, min(self.visible_width, len(self.text)))
+				mark = list(range(0, min(self.visible_width, len(self.text))))
 			else:
 				mark = [self.marked_pos-self.offset]
 			return ("mtext"[1-selected:], self.text[self.offset:self.offset+self.visible_width].encode("utf-8")+" ", mark)
 		else:
 			if self.allmarked:
-				mark = range(0, len(self.text))
+				mark = list(range(0, len(self.text)))
 			else:
 				mark = [self.marked_pos]
 			return ("mtext"[1-selected:], self.text.encode("utf-8")+" ", mark)
@@ -1099,7 +1100,7 @@
 					return
 			else:
 				ascii = getKeyNumber(key) + 48
-  			newChar = unichr(ascii)
+  			newChar = chr(ascii)
 			if self.allmarked:
 				self.deleteAllChars()
 				self.allmarked = False
@@ -1144,7 +1145,7 @@
 
 	def getMulti(self, selected):
 		if self.text == "":
-			return ("mtext"[1-selected:], _("List of storage devices"), range(0))
+			return ("mtext"[1-selected:], _("List of storage devices"), list(range(0)))
 		else:
 			return ConfigText.getMulti(self, selected)
 
@@ -1272,7 +1273,7 @@
 			else:
 				chstr = "("+self.description[ch]+")"
 			len_val1 = len(val1)
-			return ("mtext", val1+chstr+val2, range(len_val1, len_val1 + len(chstr)))
+			return ("mtext", val1+chstr+val2, list(range(len_val1, len_val1 + len(chstr))))
 
 	def onDeselect(self, session):
 		self.pos = -1
@@ -1427,9 +1428,9 @@
 					off = 0
 				else:
 					off = min(ind1+1-self.visible_width/2, len(valstr)-self.visible_width)
-				return ("mtext", valstr[off:off+self.visible_width], range(ind1-off,ind2-off))
-			else:
-				return ("mtext", valstr, range(ind1,ind2))
+				return ("mtext", valstr[off:off+self.visible_width], list(range(ind1-off,ind2-off)))
+			else:
+				return ("mtext", valstr, list(range(ind1,ind2)))
 
 	def onDeselect(self, session):
 		self.pos = -1
@@ -1486,7 +1487,7 @@
 
 	def setSavedValue(self, values):
 		self.stored_values = dict(values)
-		for (key, val) in self.stored_values.items():
+		for (key, val) in list(self.stored_values.items()):
 			if int(key) < len(self):
 				self[int(key)].saved_value = val
 
@@ -1512,16 +1513,16 @@
 		self.stored_values = {}
 
 	def save(self):
-		for x in self.values():
+		for x in list(self.values()):
 			x.save()
 
 	def load(self):
-		for x in self.values():
+		for x in list(self.values()):
 			x.load()
 
 	def getSavedValue(self):
 		res = {}
-		for (key, val) in self.items():
+		for (key, val) in list(self.items()):
 			sv = val.saved_value
 			if sv is not None:
 				res[str(key)] = sv
@@ -1529,7 +1530,7 @@
 
 	def setSavedValue(self, values):
 		self.stored_values = dict(values)
-		for (key, val) in self.items():
+		for (key, val) in list(self.items()):
 			if str(key) in self.stored_values:
 				val.saved_value = self.stored_values[str(key)]
 
@@ -1578,7 +1579,7 @@
 
 	def getSavedValue(self):
 		res = self.content.stored_values
-		for (key, val) in self.content.items.items():
+		for (key, val) in list(self.content.items.items()):
 			sv = val.saved_value
 			if sv is not None:
 				res[key] = sv
@@ -1589,7 +1590,7 @@
 	def setSavedValue(self, values):
 		values = dict(values)
 		self.content.stored_values = values
-		for (key, val) in self.content.items.items():
+		for (key, val) in list(self.content.items.items()):
 			value = values.get(key, None)
 			if value is not None:
 				val.saved_value = value
@@ -1597,11 +1598,11 @@
 	saved_value = property(getSavedValue, setSavedValue)
 
 	def save(self):
-		for x in self.content.items.values():
+		for x in list(self.content.items.values()):
 			x.save()
 
 	def load(self):
-		for x in self.content.items.values():
+		for x in list(self.content.items.values()):
 			x.load()
 
 	def dict(self):
@@ -1619,7 +1620,7 @@
 		ConfigSubsection.__init__(self)
 
 	def pickle_this(self, prefix, topickle, result):
-		for (key, val) in topickle.items():
+		for (key, val) in list(topickle.items()):
 			name = '.'.join((prefix, key))
 			if isinstance(val, dict):
 				self.pickle_this(name, val, result)
@@ -1679,7 +1680,7 @@
 			f.close()
 			os.rename(filename + ".writing", filename)
 		except IOError:
-			print "Config: Couldn't write %s" % filename
+			print("Config: Couldn't write %s" % filename)
 
 	def loadFromFile(self, filename, base_file=True):
 		f = open(filename, "r")
@@ -1695,8 +1696,8 @@
 	def load(self):
 		try:
 			config.loadFromFile(self.CONFIG_FILE, True)
-		except IOError, e:
-			print "unable to load config (%s), assuming defaults..." % str(e)
+		except IOError as e:
+			print("unable to load config (%s), assuming defaults..." % str(e))
 
 	def save(self):
 #		config.save()
@@ -1704,7 +1705,7 @@
 
 	def __resolveValue(self, pickles, cmap):
 		key = pickles[0]
-		if cmap.has_key(key):
+		if key in cmap:
 			if len(pickles) > 1:
 				return self.__resolveValue(pickles[1:], cmap[key].dict())
 			else:
@@ -1718,7 +1719,7 @@
 				ret=self.__resolveValue(names[1:], config.content.items)
 				if ret and len(ret):
 					return ret
-		print "getResolvedKey", key, "failed !! (Typo??)"
+		print("getResolvedKey", key, "failed !! (Typo??)")
 		return ""
 
 def NoSave(element):
--- enigma2-nightly.org/lib/python/Components/opkg.py
+++ enigma2-nightly.patched/lib/python/Components/opkg.py
@@ -46,4 +46,4 @@
 
 if __name__ == '__main__':
 	for p in enumPlugins('enigma'):
-		print p
+		print(p)
--- enigma2-nightly.org/lib/python/Components/Converter/ClockToText.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/ClockToText.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from time import localtime, strftime
 from Components.Element import cached
 
--- enigma2-nightly.org/lib/python/Components/Converter/Combine.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/Combine.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from Components.Element import cached
 
 class Combine(Converter, object):
--- enigma2-nightly.org/lib/python/Components/Converter/ConditionalShowHide.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/ConditionalShowHide.py
@@ -1,5 +1,5 @@
 from enigma import eTimer
-from Converter import Converter
+from .Converter import Converter
 
 class ConditionalShowHide(Converter, object):
 	def __init__(self, argstr):
--- enigma2-nightly.org/lib/python/Components/Converter/ConfigEntryTest.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/ConfigEntryTest.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from Components.Element import cached
 
 from Components.config import configfile
@@ -35,12 +35,12 @@
 			else:
 				self.argerror = True
 		if self.argerror:
-			print "ConfigEntryTest Converter got incorrect arguments", args, "!!!\narg[0] must start with 'config.',\narg[1] is the compare string,\narg[2],arg[3] are optional arguments and must be 'Invert' or 'CheckSourceBoolean'"
+			print("ConfigEntryTest Converter got incorrect arguments", args, "!!!\narg[0] must start with 'config.',\narg[1] is the compare string,\narg[2],arg[3] are optional arguments and must be 'Invert' or 'CheckSourceBoolean'")
 
 	@cached
 	def getBoolean(self):
 		if self.argerror:
-			print "ConfigEntryTest got invalid arguments", self.converter_arguments, "force True!!"
+			print("ConfigEntryTest got invalid arguments", self.converter_arguments, "force True!!")
 			return True
 		if self.checkSourceBoolean and not self.source.boolean:
 			return False
--- enigma2-nightly.org/lib/python/Components/Converter/CryptoInfo.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/CryptoInfo.py
@@ -2,7 +2,7 @@
 from Components.Element import cached
 from Components.config import config
 from Tools.GetEcmInfo import GetEcmInfo 
-from Poll import Poll
+from .Poll import Poll
 
 
 class CryptoInfo(Poll, Converter, object):
--- enigma2-nightly.org/lib/python/Components/Converter/EventTime.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/EventTime.py
@@ -1,5 +1,5 @@
-from Converter import Converter
-from Poll import Poll
+from .Converter import Converter
+from .Poll import Poll
 from time import time
 from Components.Element import cached, ElementError
 
--- enigma2-nightly.org/lib/python/Components/Converter/PliExtraInfo.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/PliExtraInfo.py
@@ -6,7 +6,7 @@
 from Components.config import config
 from Tools.Transponder import ConvertToHumanReadable
 from Tools.GetEcmInfo import GetEcmInfo
-from Poll import Poll
+from .Poll import Poll
 
 def addspace(text):
 	if text:
--- enigma2-nightly.org/lib/python/Components/Converter/RdsInfo.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/RdsInfo.py
@@ -25,7 +25,7 @@
 			elif self.type == self.RTP_TEXT_CHANGED:
 				text = decoder.getText(iRdsDecoder.RtpText)
 			else:
-				print "unknown RdsInfo Converter type", self.type
+				print("unknown RdsInfo Converter type", self.type)
 		return text
 
 	text = property(getText)
--- enigma2-nightly.org/lib/python/Components/Converter/ServicePosition.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/ServicePosition.py
@@ -1,5 +1,5 @@
-from Converter import Converter
-from Poll import Poll
+from .Converter import Converter
+from .Poll import Poll
 from enigma import iPlayableService
 from Components.Element import cached, ElementError
 
--- enigma2-nightly.org/lib/python/Components/Converter/ServiceTime.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/ServiceTime.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from Components.Element import cached, ElementError
 from enigma import iServiceInformation
 
--- enigma2-nightly.org/lib/python/Components/Converter/StaticMultiList.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/StaticMultiList.py
@@ -20,5 +20,5 @@
 		if self.source:
 			self.content.setList(self.source.list)
 
-		print "downstream_elements:", self.downstream_elements
+		print("downstream_elements:", self.downstream_elements)
 		self.downstream_elements.changed(what)
--- enigma2-nightly.org/lib/python/Components/Converter/Streaming.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/Streaming.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from Components.Element import cached
 
 # the protocol works as the following:
--- enigma2-nightly.org/lib/python/Components/Converter/StringList.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/StringList.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from enigma import eListboxPythonStringContent
 from Components.Element import cached
 
@@ -21,11 +21,11 @@
 
 	def setIndex(self, index):
 		# update all non-master targets
-		print "changed selection in listbox!"
+		print("changed selection in listbox!")
 		for x in self.downstream_elements:
-			print "downstream element", x
+			print("downstream element", x)
 			if x is not self.master:
-				print "is not master, so update to index", index
+				print("is not master, so update to index", index)
 				x.index = index
 
 	def getIndex(self, index):
--- enigma2-nightly.org/lib/python/Components/Converter/TextCase.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/TextCase.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from Components.Element import cached
 
 class TextCase(Converter):
--- enigma2-nightly.org/lib/python/Components/Converter/ValueBitTest.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/ValueBitTest.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from Components.Element import cached
 
 class ValueBitTest(Converter, object):
--- enigma2-nightly.org/lib/python/Components/Converter/ValueRange.py
+++ enigma2-nightly.patched/lib/python/Components/Converter/ValueRange.py
@@ -1,4 +1,4 @@
-from Converter import Converter
+from .Converter import Converter
 from Components.Element import cached
 
 class ValueRange(Converter, object):
--- enigma2-nightly.org/lib/python/Components/Renderer/Canvas.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Canvas.py
@@ -1,4 +1,4 @@
-from Renderer import Renderer
+from .Renderer import Renderer
 
 from enigma import eCanvas, eRect, ePoint, gRGB
 
@@ -36,7 +36,7 @@
 			elif l[0] == 3:
 				self.instance.drawLine(l[1], l[2], l[3], l[4], gRGB(l[5]))
 			else:
-				print "drawlist entry:", l
+				print("drawlist entry:", l)
 				raise RuntimeError("invalid drawlist entry")
 
 	def changed(self, what):
--- enigma2-nightly.org/lib/python/Components/Renderer/ChannelNumber.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/ChannelNumber.py
@@ -1,6 +1,6 @@
 from Components.VariableText import VariableText
 from enigma import eLabel, iPlayableService
-from Renderer import Renderer
+from .Renderer import Renderer
 
 class ChannelNumber(Renderer, VariableText):
 	def __init__(self):
--- enigma2-nightly.org/lib/python/Components/Renderer/FixedLabel.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/FixedLabel.py
@@ -1,4 +1,4 @@
-from Renderer import Renderer
+from .Renderer import Renderer
 
 from enigma import eLabel
 
--- enigma2-nightly.org/lib/python/Components/Renderer/Label.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Label.py
@@ -1,5 +1,5 @@
 from Components.VariableText import VariableText
-from Renderer import Renderer
+from .Renderer import Renderer
 
 from enigma import eLabel
 
--- enigma2-nightly.org/lib/python/Components/Renderer/Listbox.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Listbox.py
@@ -1,4 +1,4 @@
-from Renderer import Renderer
+from .Renderer import Renderer
 from enigma import eListbox
 
 # the listbox renderer is the listbox, but no listbox content.
--- enigma2-nightly.org/lib/python/Components/Renderer/NextEpgInfo.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/NextEpgInfo.py
@@ -1,5 +1,5 @@
 from Components.VariableText import VariableText
-from Renderer import Renderer
+from .Renderer import Renderer
 from enigma import eLabel, eEPGCache
 from time import localtime
 
--- enigma2-nightly.org/lib/python/Components/Renderer/NextEvent.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/NextEvent.py
@@ -1,6 +1,6 @@
 from Components.VariableText import VariableText
 from enigma import eLabel, eEPGCache
-from Renderer import Renderer
+from .Renderer import Renderer
 from time import localtime
 
 class NextEvent(Renderer, VariableText):
--- enigma2-nightly.org/lib/python/Components/Renderer/Picon.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Picon.py
@@ -1,5 +1,5 @@
 import os
-from Renderer import Renderer
+from .Renderer import Renderer
 from enigma import ePixmap
 from Tools.Alternatives import GetWithAlternative
 from Tools.Directories import pathExists, SCOPE_SKIN_IMAGE, SCOPE_CURRENT_SKIN, resolveFilename
@@ -23,18 +23,18 @@
 		if os.path.isdir(path) and path not in searchPaths:
 			for fn in os.listdir(path):
 				if fn.endswith('.png'):
-					print "[Picon] adding path:", path
+					print("[Picon] adding path:", path)
 					searchPaths.append(path)
 					break
-	except Exception, ex:
-		print "[Picon] Failed to investigate %s:" % mountpoint, ex
+	except Exception as ex:
+		print("[Picon] Failed to investigate %s:" % mountpoint, ex)
 
 def onMountpointRemoved(mountpoint):
 	global searchPaths
 	path = os.path.join(mountpoint, 'picon') + '/'
 	try:
 		searchPaths.remove(path)
-		print "[Picon] removed path:", path
+		print("[Picon] removed path:", path)
 	except:
 		pass
 
--- enigma2-nightly.org/lib/python/Components/Renderer/Pig.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Pig.py
@@ -1,7 +1,7 @@
 ##
 ## P(icture)i(n)g(raphics) renderer
 ##
-from Renderer import Renderer
+from .Renderer import Renderer
 from enigma import eVideoWidget, eSize, ePoint, getDesktop
 
 class Pig(Renderer):
--- enigma2-nightly.org/lib/python/Components/Renderer/Pixmap.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Pixmap.py
@@ -1,4 +1,4 @@
-from Renderer import Renderer
+from .Renderer import Renderer
 
 from enigma import ePixmap
 
--- enigma2-nightly.org/lib/python/Components/Renderer/PositionGauge.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/PositionGauge.py
@@ -1,4 +1,4 @@
-from Renderer import Renderer
+from .Renderer import Renderer
 from enigma import ePositionGauge
 
 class PositionGauge(Renderer):
--- enigma2-nightly.org/lib/python/Components/Renderer/Progress.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Progress.py
@@ -1,5 +1,5 @@
 from Components.VariableValue import VariableValue
-from Renderer import Renderer
+from .Renderer import Renderer
 
 from enigma import eSlider
 
--- enigma2-nightly.org/lib/python/Components/Renderer/SingleEpgList.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/SingleEpgList.py
@@ -1,6 +1,6 @@
 from Components.VariableText import VariableText
 from enigma import eLabel, eEPGCache
-from Renderer import Renderer
+from .Renderer import Renderer
 from time import localtime
 
 class SingleEpgList(Renderer, VariableText):
--- enigma2-nightly.org/lib/python/Components/Renderer/VideoSize.py
+++ enigma2-nightly.patched/lib/python/Components/Renderer/VideoSize.py
@@ -1,6 +1,6 @@
 from Components.VariableText import VariableText
 from enigma import eLabel, iServiceInformation
-from Renderer import Renderer
+from .Renderer import Renderer
 
 #
 # borrowed from vali, addapter for openpli
--- enigma2-nightly.org/lib/python/Components/Sources/Boolean.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/Boolean.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 from Components.Element import cached
 from enigma import eTimer
 
--- enigma2-nightly.org/lib/python/Components/Sources/CanvasSource.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/CanvasSource.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 
 class CanvasSource(Source):
 	def __init__(self):
--- enigma2-nightly.org/lib/python/Components/Sources/Clock.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/Clock.py
@@ -2,7 +2,7 @@
 from enigma import eTimer
 from time import time as getTime
 
-from Source import Source
+from .Source import Source
 
 class Clock(Source):
 	def __init__(self):
--- enigma2-nightly.org/lib/python/Components/Sources/Config.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/Config.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 
 class Config(Source):
 	def __init__(self, config):
@@ -11,9 +11,9 @@
 	config = property(getConfig)
 
 	def getHTML(self, id):
-		print "getHTML", self, id
+		print("getHTML", self, id)
 		return self.__config.getHTML(id)
 
 	def handleCommand(self, cmd):
-		print "ASSIGN:", cmd
+		print("ASSIGN:", cmd)
 		self.__config.unsafeAssign(cmd)
--- enigma2-nightly.org/lib/python/Components/Sources/CurrentService.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/CurrentService.py
@@ -1,6 +1,6 @@
 from Components.PerServiceDisplay import PerServiceBase
 from enigma import iPlayableService
-from Source import Source
+from .Source import Source
 from Components.Element import cached
 import NavigationInstance
 
--- enigma2-nightly.org/lib/python/Components/Sources/Event.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/Event.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 
 class Event(Source, object):
 	def __init__(self):
--- enigma2-nightly.org/lib/python/Components/Sources/EventInfo.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/EventInfo.py
@@ -1,7 +1,7 @@
 from Components.PerServiceDisplay import PerServiceBase
 from Components.Element import cached
 from enigma import iPlayableService, iServiceInformation, eServiceReference, eEPGCache
-from Source import Source
+from .Source import Source
 
 class EventInfo(PerServiceBase, Source, object):
 	NOW = 0
--- enigma2-nightly.org/lib/python/Components/Sources/FrontendInfo.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/FrontendInfo.py
@@ -1,5 +1,5 @@
 from enigma import iPlayableService
-from Source import Source
+from .Source import Source
 from Components.PerServiceDisplay import PerServiceBase
 
 class FrontendInfo(Source, PerServiceBase):
--- enigma2-nightly.org/lib/python/Components/Sources/FrontendStatus.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/FrontendStatus.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 from enigma import eTimer
 
 class FrontendStatus(Source):
--- enigma2-nightly.org/lib/python/Components/Sources/List.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/List.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 from Components.Element import cached
 
 class List(Source, object):
--- enigma2-nightly.org/lib/python/Components/Sources/Progress.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/Progress.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 
 class Progress(Source):
 	def __init__(self, value = 0, range = 100):
--- enigma2-nightly.org/lib/python/Components/Sources/RdsDecoder.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/RdsDecoder.py
@@ -1,7 +1,7 @@
 from Components.PerServiceDisplay import PerServiceBase
 from Components.Element import cached
 from enigma import iPlayableService
-from Source import Source
+from .Source import Source
 
 class RdsDecoder(PerServiceBase, Source, object):
 	def __init__(self, navcore):
--- enigma2-nightly.org/lib/python/Components/Sources/RecordState.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/RecordState.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 from Components.Element import cached
 from enigma import iRecordableService
 
--- enigma2-nightly.org/lib/python/Components/Sources/Sensor.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/Sensor.py
@@ -2,7 +2,7 @@
 
 from enigma import eTimer
 
-from Source import Source
+from .Source import Source
 
 class SensorSource(Source):
 	def __init__(self, update_interval = 500, sensorid = None):
--- enigma2-nightly.org/lib/python/Components/Sources/ServiceEvent.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/ServiceEvent.py
@@ -1,6 +1,6 @@
 from Components.Element import cached
 from enigma import eServiceCenter, eServiceReference as Ref
-from Source import Source
+from .Source import Source
 
 class ServiceEvent(Source, object):
 	def __init__(self):
--- enigma2-nightly.org/lib/python/Components/Sources/ServiceList.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/ServiceList.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 from enigma import eServiceCenter, eServiceReference
 
 class ServiceList(Source):
@@ -33,10 +33,10 @@
 	root = property(getRoot, setRoot)
 
 	def handleCommand(self, cmd):
-		print "ServiceList handle command"
+		print("ServiceList handle command")
 		
 		if self.validate_commands and not self.validateReference(cmd):
-			print "Service reference did not validate!"
+			print("Service reference did not validate!")
 			return
 
 		ref = eServiceReference(cmd)
--- enigma2-nightly.org/lib/python/Components/Sources/StaticText.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/StaticText.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 
 class StaticText(Source):
 	# filter is a function which filters external, untrusted strings
--- enigma2-nightly.org/lib/python/Components/Sources/StreamService.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/StreamService.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 from Components.Element import cached
 from enigma import eServiceReference
 
@@ -19,20 +19,20 @@
 	service = property(getService)
 
 	def handleCommand(self, cmd):
-		print "StreamService handle command", cmd
+		print("StreamService handle command", cmd)
 		self.ref = eServiceReference(cmd)
 
 	def recordEvent(self, service, event):
 		if service is self.__service:
 			return
-		print "RECORD event for us:", service
+		print("RECORD event for us:", service)
 		self.changed((self.CHANGED_ALL, ))
 
 	def execBegin(self):
 		if self.ref is None:
-			print "StreamService has no service ref set."
+			print("StreamService has no service ref set.")
 			return
-		print "StreamService execBegin", self.ref.toString()
+		print("StreamService execBegin", self.ref.toString())
 		self.__service = self.navcore.recordService(self.ref)
 		self.navcore.record_event.append(self.recordEvent)
 		if self.__service is not None:
@@ -40,7 +40,7 @@
 			self.__service.start()
 
 	def execEnd(self):
-		print "StreamService execEnd", self.ref.toString()
+		print("StreamService execEnd", self.ref.toString())
 		self.navcore.record_event.remove(self.recordEvent)
 		if self.__service is not None:
 			self.navcore.stopRecordService(self.__service)
--- enigma2-nightly.org/lib/python/Components/Sources/TunerInfo.py
+++ enigma2-nightly.patched/lib/python/Components/Sources/TunerInfo.py
@@ -1,4 +1,4 @@
-from Source import Source
+from .Source import Source
 from enigma import eDVBResourceManager
 
 class TunerInfo(Source):
@@ -11,7 +11,7 @@
 		if res_mgr:
 			res_mgr.frontendUseMaskChanged.get().append(self.tunerUseMaskChanged)
 		else:
-			print "no res_mgr!!"
+			print("no res_mgr!!")
 
 	def tunerUseMaskChanged(self, mask):
 		self.tuner_use_mask = mask
@@ -25,5 +25,5 @@
 		if res_mgr:
 			res_mgr.frontendUseMaskChanged.get().remove(self.tunerUseMaskChanged)
 		else:
-			print "no res_mgr!!"
+			print("no res_mgr!!")
 		Source.destroy(self)
--- enigma2-nightly.org/lib/python/Plugins/newplugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/newplugin.py
@@ -3,30 +3,30 @@
 import os
 
 os.system("clear")
-internalname = raw_input("Internal plugin name (no whitespaces, plugin directory): ")
-name = raw_input("Visible plugin name: ")
-print
+internalname = input("Internal plugin name (no whitespaces, plugin directory): ")
+name = input("Visible plugin name: ")
+print()
 
 os.system("clear")
 dirlist = []
 count = 0
-print "Plugin categories:"
+print("Plugin categories:")
 for dir in os.listdir("."):
 	if os.path.isdir(dir):
 		count += 1
 		dirlist.append(dir)
-		print count, dir
+		print(count, dir)
 		
-category = raw_input("Select plugin category: ")
+category = input("Select plugin category: ")
 category = dirlist[int(category) - 1]
 
 def add_where_extensionsmenu(name, fnc):
-	description = raw_input("Plugin description: ")
+	description = input("Plugin description: ")
 	return 'PluginDescriptor(name = "%s", description = _("%s"), where = PluginDescriptor.WHERE_EXTENSIONSMENU, fnc = %s)' % (name, description, fnc) 
 
 def add_where_pluginmenu(name, fnc):
-	description = raw_input("Plugin description: ")
-	icon = raw_input("Icon (default: 'plugin.png': ")
+	description = input("Plugin description: ")
+	icon = input("Icon (default: 'plugin.png': ")
 	if icon == "":
 		icon = "plugin.png"
 	return 'PluginDescriptor(name = "%s", description = _("%s"), icon = "%s", where = PluginDescriptor.WHERE_PLUGINMENU, fnc = %s)' % (name, description, icon, fnc) 
@@ -41,19 +41,19 @@
 
 while not stop:
 	os.system("clear")
-	print "selected targets:"
+	print("selected targets:")
 	for where in targetlist:
-		print where[0]
+		print(where[0])
 	
-	print
-	print "available targets:"
+	print()
+	print("available targets:")
 	count = 0
 	for where in wherelist:
 		count += 1
-		print count, where[0]
-	print "x break"
+		print(count, where[0])
+	print("x break")
 		
-	target = raw_input("Select WHERE-target: ")
+	target = input("Select WHERE-target: ")
 	if target == "x":
 		stop = True
 	else:
@@ -78,7 +78,7 @@
 makefile.close()
 
 lines = []
-print "open"
+print("open")
 configure = open("../../../configure.ac", "r")
 while True:
 	line = configure.readline()
@@ -88,7 +88,7 @@
 	if line.strip() == "lib/python/Plugins/" + category + "/Makefile":
 		lines.append("lib/python/Plugins/" + pluginpath + "/Makefile\n")
 configure.close()
-print "close"
+print("close")
 
 configure = open("../../../configure.ac", "w")
 configure.writelines(lines)
@@ -121,7 +121,7 @@
 for count in range(len(targetlist)):
 	os.system("clear")
 	where = targetlist[count]
-	print "Options for target %s" % where[0]
+	print("Options for target %s" % where[0])
 	descriptorlist.append(where[1](name, mainlist[count]))
 	
 if len(descriptorlist) == 1:
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CutListEditor/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/CutListEditor/plugin.py
@@ -2,7 +2,7 @@
 
 
 def CutListEditor(session, service=None):
-	import ui
+	from . import ui
 	return ui.CutListEditor(session, service)
 
 def main(session, service, **kwargs):
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CutListEditor/ui.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/CutListEditor/ui.py
@@ -153,7 +153,7 @@
 		cue = service and service.cueSheet()
 		if cue is not None:
 			# disable cutlists. we want to freely browse around in the movie
-			print "cut lists disabled!"
+			print("cut lists disabled!")
 			cue.setCutListEnable(0)
 
 		self.downloadCuesheet()
@@ -249,17 +249,17 @@
 		if not self.inhibit_seek:
 			where = self["cutlist"].getCurrent()
 			if where is None:
-				print "no selection"
+				print("no selection")
 				return
 			pts = where[0][0]
 			seek = self.getSeek()
 			if seek is None:
-				print "no seek"
+				print("no seek")
 				return
 			seek.seekTo(pts)
 
 	def refillList(self):
-		print "cue sheet changed, refilling"
+		print("cue sheet changed, refilling")
 		self.downloadCuesheet()
 
 		# get the first changed entry, counted from the end, and select it
@@ -301,13 +301,13 @@
 
 		cur_state = self.getStateForPosition(curpos)
 		if cur_state == 0:
-			print "currently in 'IN'"
+			print("currently in 'IN'")
 			if self.cut_start is None or self.context_position < self.cut_start:
 				state = CutListContextMenu.SHOW_STARTCUT
 			else:
 				state = CutListContextMenu.SHOW_ENDCUT
 		else:
-			print "currently in 'OUT'"
+			print("currently in 'OUT'")
 			state = CutListContextMenu.SHOW_DELETECUT
 
 		if self.context_nearest_mark is None:
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/DVDProject.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/DVDProject.py
@@ -1,6 +1,6 @@
 from Tools.Directories import fileExists
 from Components.config import config, ConfigSubsection, ConfigInteger, ConfigText, ConfigSelection, getConfigListEntry, ConfigSequence, ConfigSubList
-import DVDTitle
+from . import DVDTitle
 import xml.dom.minidom
 from Tools.Directories import resolveFilename, SCOPE_PLUGINS, SCOPE_FONTS
 
@@ -18,7 +18,7 @@
 		cut_len = min(len(self.text),40)
 		filename = (self.text.rstrip("/").rsplit("/",1))[1].encode("utf-8")[:cut_len] + " "
 		if self.allmarked:
-			mark = range(0, len(filename))
+			mark = list(range(0, len(filename)))
 		else:
 			mark = [filename]
 		return ("mtext"[1-selected:], filename, mark)
@@ -55,7 +55,7 @@
 		list.append('<?xml version="1.0" encoding="utf-8" ?>\n')
 		list.append('<DreamDVDBurnerProject>\n')
 		list.append('\t<settings ')
-		for key, val in self.settings.dict().iteritems():
+		for key, val in self.settings.dict().items():
 			list.append( key + '="' + str(val.getValue()) + '" ' )
 		list.append('/>\n')
 		list.append('\t<titles>\n')
@@ -66,12 +66,12 @@
 			list.append('</path>\n')
 			list.append('\t\t\t<properties ')
 			audiotracks = []
-			for key, val in title.properties.dict().iteritems():
+			for key, val in title.properties.dict().items():
 				if type(val) is ConfigSubList:
 					audiotracks.append('\t\t\t<audiotracks>\n')
 					for audiotrack in val:
 						audiotracks.append('\t\t\t\t<audiotrack ')
-						for subkey, subval in audiotrack.dict().iteritems():
+						for subkey, subval in audiotrack.dict().items():
 							audiotracks.append( subkey + '="' + str(subval.getValue()) + '" ' )
 						audiotracks.append(' />\n')
 					audiotracks.append('\t\t\t</audiotracks>\n')
@@ -116,7 +116,7 @@
 			file.close()
 			projectfiledom = xml.dom.minidom.parseString(data)
 			for node in projectfiledom.childNodes[0].childNodes:
-			  print "node:", node
+			  print("node:", node)
 			  if node.nodeType == xml.dom.minidom.Element.nodeType:
 			    if node.tagName == 'settings':
 				self.xmlAttributesToConfig(node, self.settings)
@@ -155,11 +155,11 @@
 				except (NameError, SyntaxError):
 					val = item.nodeValue.encode("utf-8")
 				try:
-					print "config[%s].setValue(%s)" % (key, val)
+					print("config[%s].setValue(%s)" % (key, val))
 					config.dict()[key].setValue(val)
 				except (KeyError):
 					self.error = "unknown attribute '%s'" % (key)
-					print "KeyError", self.error
+					print("KeyError", self.error)
 					raise AttributeError
 				i += 1
 		except AttributeError:
@@ -167,10 +167,10 @@
 			return False
 
 	def xmlGetTitleNodeRecursive(self, node, title_idx = -1):
-		print "[xmlGetTitleNodeRecursive]", title_idx, node
-		print node.childNodes
+		print("[xmlGetTitleNodeRecursive]", title_idx, node)
+		print(node.childNodes)
 		for subnode in node.childNodes:
-		  print "xmlGetTitleNodeRecursive subnode:", subnode
+		  print("xmlGetTitleNodeRecursive subnode:", subnode)
 		  if subnode.nodeType == xml.dom.minidom.Element.nodeType:
 		    if subnode.tagName == 'title':
 			title_idx += 1
@@ -178,7 +178,7 @@
 			self.titles.append(title)
 			self.xmlGetTitleNodeRecursive(subnode, title_idx)
 		    if subnode.tagName == 'path':
-			print "path:", subnode.firstChild.data
+			print("path:", subnode.firstChild.data)
 			filename = subnode.firstChild.data
 			self.titles[title_idx].addFile(filename.encode("utf-8"))
 		    if subnode.tagName == 'properties':
@@ -186,7 +186,7 @@
 		    if subnode.tagName == 'audiotracks':
 			self.xmlGetTitleNodeRecursive(subnode, title_idx)
 		    if subnode.tagName == 'audiotrack':
-			print "audiotrack...", subnode.toxml()
+			print("audiotrack...", subnode.toxml())
 
 	def getSize(self):
 		totalsize = 0
@@ -231,7 +231,7 @@
 		self.settings.thumb_size = ConfigSequence(seperator = ',', default = [200,158], limits = [(0,576),(-1,720)])
 		self.settings.thumb_border = ConfigInteger(default = 2, limits = (0, 20))
 		self.filekeys = ["menubg", "menuaudio", "fontface_headline", "fontface_title", "fontface_subtitle"]
-		from TitleProperties import languageChoices
+		from .TitleProperties import languageChoices
 		self.settings.menulang = ConfigSelection(choices = languageChoices.choices, default=languageChoices.choices[1][0])
 		self.error = ""
 
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/DVDTitle.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/DVDTitle.py
@@ -1,5 +1,5 @@
 from Components.config import config, ConfigSubsection, ConfigSubList, ConfigInteger, ConfigText, ConfigSelection, getConfigListEntry, ConfigSequence, ConfigYesNo
-import TitleCutter
+from . import TitleCutter
 
 class ConfigFixedText(ConfigText):
 	def __init__(self, text, visible_width=60):
@@ -78,14 +78,14 @@
 		template = template.replace("$C", self.DVBchannel)
 		
 		#if template.find("$A") >= 0:
-		from TitleProperties import languageChoices
+		from .TitleProperties import languageChoices
 		audiolist = [ ]
 		for audiotrack in self.properties.audiotracks:
 			active = audiotrack.active.getValue()
 			if active:
 				trackstring = audiotrack.format.getValue()
 				language = audiotrack.language.getValue()
-				if languageChoices.langdict.has_key(language):
+				if language in languageChoices.langdict:
 					trackstring += ' (' + languageChoices.langdict[language] + ')'
 				audiolist.append(trackstring)
 		audiostring = ', '.join(audiolist)
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/DVDToolbox.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/DVDToolbox.py
@@ -97,13 +97,13 @@
 					self.formattable = False
 			elif line.find("Legacy lead-out at:") > -1:
 				used = int(line.rsplit('=',1)[1]) / 1048576.0
-				print "[dvd+rw-mediainfo] lead out used =", used
+				print("[dvd+rw-mediainfo] lead out used =", used)
 			elif line.find("formatted:") > -1:
 				formatted_capacity = int(line.rsplit('=',1)[1]) / 1048576.0
-				print "[dvd+rw-mediainfo] formatted capacity =", formatted_capacity
+				print("[dvd+rw-mediainfo] formatted capacity =", formatted_capacity)
 			elif formatted_capacity == 0 and line.find("READ CAPACITY:") > -1:
 				read_capacity = int(line.rsplit('=',1)[1]) / 1048576.0
-				print "[dvd+rw-mediainfo] READ CAPACITY =", read_capacity
+				print("[dvd+rw-mediainfo] READ CAPACITY =", read_capacity)
 		for line in mediuminfo.splitlines():
 			if line.find("Free Blocks:") > -1:
 				try:
@@ -114,14 +114,14 @@
 					capacity = size / 1048576
 					if used:
 						used = capacity-used
-					print "[dvd+rw-mediainfo] free blocks capacity=%d, used=%d" % (capacity, used)
+					print("[dvd+rw-mediainfo] free blocks capacity=%d, used=%d" % (capacity, used))
 			elif line.find("Disc status:") > -1:
 				if line.find("blank") > -1:
-					print "[dvd+rw-mediainfo] Disc status blank capacity=%d, used=0" % (capacity)
+					print("[dvd+rw-mediainfo] Disc status blank capacity=%d, used=0" % (capacity))
 					capacity = used
 					used = 0
 				elif line.find("complete") > -1 and formatted_capacity == 0:
-					print "[dvd+rw-mediainfo] Disc status complete capacity=0, used=%d" % (capacity)
+					print("[dvd+rw-mediainfo] Disc status complete capacity=0, used=%d" % (capacity))
 					used = read_capacity
 					capacity = 1
 				else:
@@ -181,7 +181,7 @@
 		}[task.error]
 
 class DVDformatTask(Task):
-	ERROR_ALREADYFORMATTED, ERROR_NOTWRITEABLE, ERROR_UNKNOWN = range(3)
+	ERROR_ALREADYFORMATTED, ERROR_NOTWRITEABLE, ERROR_UNKNOWN = list(range(3))
 	def __init__(self, job, extra_args=[]):
 		Task.__init__(self, job, ("RW medium format"))
 		self.toolbox = job.toolbox
@@ -205,7 +205,7 @@
 			self.error = self.ERROR_NOTWRITEABLE
 
 	def processOutput(self, data):
-		print "[DVDformatTask processOutput]  ", data
+		print("[DVDformatTask processOutput]  ", data)
 		if data.endswith('%'):
 			data= data.replace('\x08','')
 			self.progress = int(float(data[:-1])*10)
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/Process.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/Process.py
@@ -17,7 +17,7 @@
 		self.container.dumpToFile(self.dumpFile)
 
 	def processStderr(self, data):
-		print "[png2yuvTask]", data[:-1]
+		print("[png2yuvTask]", data[:-1])
 
 class mpeg2encTask(Task):
 	def __init__(self, job, inputfile, outputfile):
@@ -32,7 +32,7 @@
 		self.container.readFromFile(self.inputFile)
 
 	def processOutputLine(self, line):
-		print "[mpeg2encTask]", line[:-1]
+		print("[mpeg2encTask]", line[:-1])
 
 class spumuxTask(Task):
 	def __init__(self, job, xmlfile, inputfile, outputfile):
@@ -50,7 +50,7 @@
 		self.container.readFromFile(self.inputFile)
 
 	def processStderr(self, data):
-		print "[spumuxTask]", data[:-1]
+		print("[spumuxTask]", data[:-1])
 
 class MakeFifoNode(Task):
 	def __init__(self, job, number):
@@ -130,10 +130,10 @@
 			try:
 				self.currentPID = str(int(line.split(': PID 0x',1)[1].split(' ',1)[0],16))
 			except ValueError:
-				print "[DemuxTask] ERROR: couldn't detect Audio PID (projectx too old?)"
+				print("[DemuxTask] ERROR: couldn't detect Audio PID (projectx too old?)")
 
 	def haveNewFile(self, file):
-		print "[DemuxTask] produced file:", file, self.currentPID
+		print("[DemuxTask] produced file:", file, self.currentPID)
 		self.generated_files.append(file)
 		if self.currentPID in self.relevantAudioPIDs:
 			self.mplex_audiofiles[self.currentPID] = file
@@ -172,12 +172,12 @@
 		f.close()
 
 	def cleanup(self, failed):
-		print "[DemuxTask::cleanup]"
+		print("[DemuxTask::cleanup]")
 		self.mplex_streamfiles = [ self.mplex_videofile ]
 		for pid in self.relevantAudioPIDs:
 			if pid in self.mplex_audiofiles:
 				self.mplex_streamfiles.append(self.mplex_audiofiles[pid])
-		print self.mplex_streamfiles
+		print(self.mplex_streamfiles)
 
 		if failed:
 			import os
@@ -200,7 +200,7 @@
 		}[task.error]
 
 class MplexTask(Task):
-	ERROR_UNDERRUN, ERROR_UNKNOWN = range(2)
+	ERROR_UNDERRUN, ERROR_UNKNOWN = list(range(2))
 	def __init__(self, job, outputfile, inputfiles=None, demux_task=None, weighting = 500):
 		Task.__init__(self, job, "Mux ES into PS")
 		self.weighting = weighting
@@ -223,7 +223,7 @@
 			self.args += self.demux_task.mplex_streamfiles
 
 	def processOutputLine(self, line):
-		print "[MplexTask] ", line[:-1]
+		print("[MplexTask] ", line[:-1])
 		if line.startswith("**ERROR:"):
 			if line.find("Frame data under-runs detected") != -1:
 				self.error = self.ERROR_UNDERRUN
@@ -250,7 +250,7 @@
 		self.args += ["-t", "DVD", "-j", "-o", outputfile, inputfile]
 
 	def processOutputLine(self, line):
-		print "[ReplexTask] ", line[:-1]
+		print("[ReplexTask] ", line[:-1])
 
 class DVDAuthorTask(Task):
 	def __init__(self, job):
@@ -262,7 +262,7 @@
 		self.menupreview = job.menupreview
 
 	def processOutputLine(self, line):
-		print "[DVDAuthorTask] ", line[:-1]
+		print("[DVDAuthorTask] ", line[:-1])
 		if not self.menupreview and line.startswith("STAT: Processing"):
 			self.callback(self, [], stay_resident=True)
 		elif line.startswith("STAT: VOBU"):
@@ -270,9 +270,9 @@
 				progress = int(line.split("MB")[0].split(" ")[-1])
 				if progress:
 					self.job.mplextask.progress = progress
-					print "[DVDAuthorTask] update mplextask progress:", self.job.mplextask.progress, "of", self.job.mplextask.end
+					print("[DVDAuthorTask] update mplextask progress:", self.job.mplextask.progress, "of", self.job.mplextask.end)
 			except:
-				print "couldn't set mux progress"
+				print("couldn't set mux progress")
 
 class DVDAuthorFinalTask(Task):
 	def __init__(self, job):
@@ -285,7 +285,7 @@
 		Task.__init__(self, job, "waiting for dvdauthor to finalize")
 		
 	def run(self, callback):
-		print "waiting for %d resident task(s) %s to finish..." % (len(self.job.resident_tasks),str(self.job.resident_tasks))
+		print("waiting for %d resident task(s) %s to finish..." % (len(self.job.resident_tasks),str(self.job.resident_tasks)))
 		self.callback = callback
 		if self.job.resident_tasks == 0:
 			callback(self, [])
@@ -313,7 +313,7 @@
 		}[task.error]
 
 class BurnTask(Task):
-	ERROR_NOTWRITEABLE, ERROR_LOAD, ERROR_SIZE, ERROR_WRITE_FAILED, ERROR_DVDROM, ERROR_ISOFS, ERROR_FILETOOLARGE, ERROR_ISOTOOLARGE, ERROR_MINUSRWBUG, ERROR_UNKNOWN = range(10)
+	ERROR_NOTWRITEABLE, ERROR_LOAD, ERROR_SIZE, ERROR_WRITE_FAILED, ERROR_DVDROM, ERROR_ISOFS, ERROR_FILETOOLARGE, ERROR_ISOTOOLARGE, ERROR_MINUSRWBUG, ERROR_UNKNOWN = list(range(10))
 	def __init__(self, job, extra_args=[], tool="growisofs"):
 		Task.__init__(self, job, job.name)
 		self.weighting = 500
@@ -327,10 +327,10 @@
 
 	def processOutputLine(self, line):
 		line = line[:-1]
-		print "[GROWISOFS] %s" % line
+		print("[GROWISOFS] %s" % line)
 		if line[8:14] == "done, ":
 			self.progress = float(line[:6])
-			print "progress:", self.progress
+			print("progress:", self.progress)
 		elif line.find("flushing cache") != -1:
 			self.progress = 100
 		elif line.find("closing disc") != -1:
@@ -344,12 +344,12 @@
 				self.error = self.ERROR_MINUSRWBUG
 			else:
 				self.error = self.ERROR_UNKNOWN
-				print "BurnTask: unknown error %s" % line
+				print("BurnTask: unknown error %s" % line)
 		elif line.startswith(":-("):
 			if line.find("No space left on device") != -1:
 				self.error = self.ERROR_SIZE
 			elif self.error == self.ERROR_MINUSRWBUG:
-				print "*sigh* this is a known bug. we're simply gonna assume everything is fine."
+				print("*sigh* this is a known bug. we're simply gonna assume everything is fine.")
 				self.postconditions = []
 			elif line.find("write failed") != -1:
 				self.error = self.ERROR_WRITE_FAILED
@@ -359,13 +359,13 @@
 				self.error = self.ERROR_NOTWRITEABLE
 			else:
 				self.error = self.ERROR_UNKNOWN
-				print "BurnTask: unknown error %s" % line
+				print("BurnTask: unknown error %s" % line)
 		elif line.startswith("FATAL:"):
 			if line.find("already carries isofs!"):
 				self.error = self.ERROR_ISOFS
 			else:
 				self.error = self.ERROR_UNKNOWN
-				print "BurnTask: unknown error %s" % line
+				print("BurnTask: unknown error %s" % line)
 		elif line.find("-allow-limited-size was not specified. There is no way do represent this file size. Aborting.") != -1:
 			self.error = self.ERROR_FILETOOLARGE
 		elif line.startswith("genisoimage: File too large."):
@@ -890,7 +890,7 @@
 			PreviewTask(self, self.workspace + "/dvd/VIDEO_TS/")
 		else:
 			hasProjectX = os.path.exists('/usr/bin/projectx')
-			print "[DVDJob] hasProjectX=", hasProjectX
+			print("[DVDJob] hasProjectX=", hasProjectX)
 			for self.i in range(nr_titles):
 				self.title = self.project.titles[self.i]
 				link_name =  self.workspace + "/source_title_%d.ts" % (self.i+1)
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/ProjectSettings.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/ProjectSettings.py
@@ -176,9 +176,9 @@
 		
 		self["config"].setList(self.list)
 		self.keydict = {}
-		for key, val in self.settings.dict().iteritems():
+		for key, val in self.settings.dict().items():
 			self.keydict[val] = key
-		for key, val in self.project.menutemplate.settings.dict().iteritems():
+		for key, val in self.project.menutemplate.settings.dict().items():
 			self.keydict[val] = key
 
 	def keyLeft(self):
@@ -203,7 +203,7 @@
 		
 	def ok(self):
 		key = self.keydict[self["config"].getCurrent()[1]]
-		from DVDProject import ConfigFilename
+		from .DVDProject import ConfigFilename
 		if type(self["config"].getCurrent()[1]) == ConfigFilename:
 			self.session.openWithCallback(self.FileBrowserClosed, FileBrowser, key, self["config"].getCurrent()[1])
 
@@ -227,14 +227,14 @@
 	def FileBrowserClosed(self, path, scope, configRef):
 		if scope == "menutemplate":
 			if self.project.menutemplate.loadTemplate(path):
-				print "[ProjectSettings] menu template loaded"
+				print("[ProjectSettings] menu template loaded")
 				configRef.setValue(path)
 				self.initConfigList()
 			else:
 				self.session.open(MessageBox,self.project.error,MessageBox.TYPE_ERROR)
 		elif scope == "project":
 			self.path = path
-			print "len(self.titles)", len(self.project.titles)
+			print("len(self.titles)", len(self.project.titles))
 			if len(self.project.titles):
 				self.session.openWithCallback(self.askLoadCB, MessageBox,text = _("Your current collection will get lost!") + "\n" + _("Do you want to restore your settings?"), type = MessageBox.TYPE_YESNO)
 			else:
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/TitleCutter.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/TitleCutter.py
@@ -21,8 +21,8 @@
 		audio = service and service.audioTracks()
 		n = audio and audio.getNumberOfTracks() or 0
 		if n > 0:
-			from DVDTitle import ConfigFixedText
-			from TitleProperties import languageChoices
+			from .DVDTitle import ConfigFixedText
+			from .TitleProperties import languageChoices
 			from Components.config import config, ConfigSubsection, ConfigSubList, ConfigSelection, ConfigYesNo
 			self.t.properties.audiotracks = ConfigSubList()
 			for x in range(n):
@@ -32,7 +32,7 @@
 				pid = str(i.getPID())
 				if description == "MPEG":
 					description = "MP2"
-				print "[audiotrack] pid:", pid, "description:", description, "language:", DVB_lang, "count:", x, "active:", (x < 8)
+				print("[audiotrack] pid:", pid, "description:", description, "language:", DVB_lang, "count:", x, "active:", (x < 8))
 				self.t.properties.audiotracks.append(ConfigSubsection())
 				self.t.properties.audiotracks[-1].active = ConfigYesNo(default = (x < 8))
 				self.t.properties.audiotracks[-1].format = ConfigFixedText(description)
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/TitleList.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/TitleList.py
@@ -1,4 +1,4 @@
-import DVDProject, TitleList, TitleCutter, TitleProperties, ProjectSettings, DVDToolbox, Process
+from . import DVDProject, TitleList, TitleCutter, TitleProperties, ProjectSettings, DVDToolbox, Process
 from Screens.Screen import Screen
 from Screens.ChoiceBox import ChoiceBox
 from Screens.InputBox import InputBox
@@ -103,8 +103,8 @@
 
 	def checkBackgroundJobs(self):
 		for job in job_manager.getPendingJobs():
-			print "type(job):", type(job)
-			print "Process.DVDJob:", Process.DVDJob
+			print("type(job):", type(job))
+			print("Process.DVDJob:", Process.DVDJob)
 			if type(job) == Process.DVDJob:
 				self.backgroundJob = job
 				return
@@ -195,7 +195,7 @@
 			def updateTags(self):
 				pass
 			def doContext(self):
-				print "context menu forbidden inside DVDBurn to prevent calling multiple instances"
+				print("context menu forbidden inside DVDBurn to prevent calling multiple instances")
 			def updateButtons(self):
 				# the original will hide red/green, and crash...
 				pass
@@ -305,7 +305,7 @@
 		size = self.project.size/(1024*1024)
 		MAX_DL = self.project.MAX_DL-100
 		MAX_SL = self.project.MAX_SL-100
-		print "updateSize:", size, "MAX_DL:", MAX_DL, "MAX_SL:", MAX_SL
+		print("updateSize:", size, "MAX_DL:", MAX_DL, "MAX_SL:", MAX_SL)
 		if size > MAX_DL:
 			percent = 100 * size / float(MAX_DL)
 			self["space_label_dual"].text = "%d MB (%.2f%%)" % (size, percent)
@@ -379,6 +379,6 @@
 			self.session.openWithCallback(self.exitCB, MessageBox,text = _("Your current collection will get lost!") + "\n" + _("Do you really want to exit?"), type = MessageBox.TYPE_YESNO)
 
 	def exitCB(self, answer):
-		print "exitCB", answer
+		print("exitCB", answer)
 		if answer is not None and answer:
 			self.close()
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/TitleProperties.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/TitleProperties.py
@@ -14,7 +14,7 @@
 from Components.config import config, getConfigListEntry, ConfigInteger, ConfigSubsection, ConfigSelection
 from Components.ConfigList import ConfigListScreen
 from Components.AVSwitch import AVSwitch
-import DVDTitle
+from . import DVDTitle
 
 class TitleProperties(Screen,ConfigListScreen):
 	skin = """
@@ -109,7 +109,7 @@
 		self.parent.editTitle()
 
 	def update(self):
-		print "[onShown]"
+		print("[onShown]")
 		self.initConfigList()
 		self.loadThumb()
 
@@ -137,7 +137,7 @@
 		current_pos = self.title_idx+1
 		new_pos = self.properties.position.getValue()
 		if new_pos != current_pos:
-			print "title got repositioned from ", current_pos, "to", new_pos
+			print("title got repositioned from ", current_pos, "to", new_pos)
 			swaptitle = self.project.titles.pop(current_pos-1)
 			self.project.titles.insert(new_pos-1, swaptitle)
 
@@ -157,10 +157,10 @@
 		syslang = syslanguage.getLanguage()[:2]
 		self.langdict = { }
 		self.choices = []
-		for key, val in LanguageCodes.iteritems():
+		for key, val in LanguageCodes.items():
 			if len(key) == 2:
 				self.langdict[key] = val[0]
-		for key, val in self.langdict.iteritems():
+		for key, val in self.langdict.items():
 			if key not in (syslang, 'en'):
 				self.langdict[key] = val
 				self.choices.append((key, val))
@@ -174,7 +174,7 @@
 		DVB_lang = DVB_lang.lower()
 		for word in ("stereo", "audio", "description", "2ch", "dolby digital"):
 			DVB_lang = DVB_lang.replace(word,"").strip()
-		for key, val in LanguageCodes.iteritems():
+		for key, val in LanguageCodes.items():
 			if DVB_lang.find(key.lower()) == 0:
 				if len(key) == 2:
 					return key
@@ -185,7 +185,7 @@
 					return key
 				else:
 					DVB_lang = (LanguageCodes[key])[0]
-		for key, val in self.langdict.iteritems():
+		for key, val in self.langdict.items():
 			if val == DVB_lang:
 				return key
 		return "nolang"
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDBurn/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDBurn/plugin.py
@@ -1,8 +1,8 @@
 from Plugins.Plugin import PluginDescriptor
 
 def main(session, **kwargs):
-	import TitleList
-	import DVDProject
+	from . import TitleList
+	from . import DVDProject
 	#project = DVDProject.DVDProject()
 	#project.addService(service)
 	return session.open(TitleList.TitleList)
--- enigma2-nightly.org/lib/python/Plugins/Extensions/DVDPlayer/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/DVDPlayer/plugin.py
@@ -28,13 +28,13 @@
 	from Screens import DVD
 	if len(list) == 1 and list[0].mimetype == "video/x-dvd":
 		splitted = list[0].path.split('/')
-		print "splitted", splitted
+		print("splitted", splitted)
 		if len(splitted) > 2:
 			if splitted[1] == 'autofs':
 				session.open(DVD.DVDPlayer, dvd_device="/dev/%s" %(splitted[2]))
 				return
 			else:
-				print "splitted[0]", splitted[1]
+				print("splitted[0]", splitted[1])
 	else:
 		dvd_filelist = []
 		for x in list:
@@ -66,14 +66,14 @@
 		)]
 
 def onPartitionChange(action, partition):
-	print "[@] onPartitionChange", action, partition
+	print("[@] onPartitionChange", action, partition)
 	if partition != harddiskmanager.getCD():
 		global detected_DVD
 		if action == 'remove':
-			print "[@] DVD removed"
+			print("[@] DVD removed")
 			detected_DVD = False
 		elif action == 'add':
-			print "[@] DVD Inserted"
+			print("[@] DVD Inserted")
 			detected_DVD = None
 		
 def menu(menuid, **kwargs):
--- enigma2-nightly.org/lib/python/Plugins/Extensions/GraphMultiEPG/GraphMultiEpg.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/GraphMultiEPG/GraphMultiEpg.py
@@ -26,7 +26,7 @@
 from enigma import eEPGCache, eListbox, ePicLoad, gFont, eListboxPythonMultiContent, \
 	RT_HALIGN_LEFT, RT_HALIGN_RIGHT, RT_HALIGN_CENTER, RT_VALIGN_CENTER, RT_WRAP, \
 	eSize, eRect, eTimer
-from GraphMultiEpgSetup import GraphMultiEpgSetup
+from .GraphMultiEpgSetup import GraphMultiEpgSetup
 from time import localtime, time, strftime
 
 MAX_TIMELINES = 6
@@ -959,7 +959,7 @@
 			self.session.openWithCallback(self.finishedTimerAdd, TimerEntry, newEntry)
 
 	def finishedTimerAdd(self, answer):
-		print "finished add"
+		print("finished add")
 		if answer[0]:
 			entry = answer[1]
 			simulTimerList = self.session.nav.RecordTimer.record(entry)
@@ -975,7 +975,7 @@
 		else:
 			self["key_green"].setText(_("Add timer"))
 			self.key_green_choice = self.ADD_TIMER
-			print "Timeredit aborted"
+			print("Timeredit aborted")
 	
 	def finishSanityCorrection(self, answer):
 		self.finishedTimerAdd(answer)
--- enigma2-nightly.org/lib/python/Plugins/Extensions/GraphMultiEPG/GraphMultiEpgSetup.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/GraphMultiEPG/GraphMultiEpgSetup.py
@@ -44,7 +44,7 @@
 		self.createSetup()
 
 	def createSetup(self):
-		print "Creating Graph Epg Setup"
+		print("Creating Graph Epg Setup")
 		self.list = [ ]
 		self.list.append(getConfigListEntry(_("Event font size (relative to skin size)"), config.misc.graph_mepg.ev_fontsize))
 		self.list.append(getConfigListEntry(_("Time scale"), config.misc.graph_mepg.prev_time_period))
--- enigma2-nightly.org/lib/python/Plugins/Extensions/GraphMultiEPG/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/GraphMultiEPG/plugin.py
@@ -1,5 +1,5 @@
 from Plugins.Plugin import PluginDescriptor
-from GraphMultiEpg import GraphMultiEPG
+from .GraphMultiEpg import GraphMultiEPG
 from Screens.ChannelSelection import BouquetSelector
 from enigma import eServiceCenter, eServiceReference
 from ServiceReference import ServiceReference
--- enigma2-nightly.org/lib/python/Plugins/Extensions/MediaPlayer/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/MediaPlayer/plugin.py
@@ -23,7 +23,7 @@
 from Components.Harddisk import harddiskmanager
 from Components.config import config
 from Tools.Directories import fileExists, pathExists, resolveFilename, SCOPE_CONFIG, SCOPE_PLAYLIST, SCOPE_CURRENT_SKIN
-from settings import MediaPlayerSettings
+from .settings import MediaPlayerSettings
 import random
 
 class MyPlayList(PlayList):
@@ -86,7 +86,7 @@
 		self.instance.setPixmap(self.noCoverPixmap)
 
 	def embeddedCoverArt(self):
-		print "[embeddedCoverArt] found"
+		print("[embeddedCoverArt] found")
 		self.coverArtFileName = "/tmp/.id3coverart"
 		self.picload.startDecode(self.coverArtFileName)
 
@@ -145,8 +145,8 @@
 		try:
 			from Plugins.SystemPlugins.Hotplug.plugin import hotplugNotifier
 			hotplugNotifier.append(self.hotplugCB)
-		except Exception, ex:
-			print "[MediaPlayer] No hotplug support", ex
+		except Exception as ex:
+			print("[MediaPlayer] No hotplug support", ex)
 
 		class MoviePlayerActionMap(NumberActionMap):
 			def __init__(self, player, contexts = [ ], actions = { }, prio=0):
@@ -252,7 +252,7 @@
 			try:
 				self.playlistIOInternal.save(resolveFilename(SCOPE_CONFIG, "playlist.e2pls"))
 			except IOError:
-				print "couldn't save playlist.e2pls"
+				print("couldn't save playlist.e2pls")
 		if config.mediaplayer.saveDirOnExit.getValue():
 			config.mediaplayer.defaultDir.setValue(self.filelist.getCurrentDirectory())
 			config.mediaplayer.defaultDir.save()
@@ -268,7 +268,7 @@
 		self.updatedSeekState()
 
 	def doEofInternal(self, playing):
-		print "--- eofint mediaplayer---"
+		print("--- eofint mediaplayer---")
 		if playing:
 			if not self.MoviePlayerOpen:
 				self.nextEntry()
@@ -283,25 +283,25 @@
 		sTagTrackNumber = currPlay.info().getInfo(iServiceInformation.sTagTrackNumber)
 		sTagTrackCount = currPlay.info().getInfo(iServiceInformation.sTagTrackCount)
 		sTagTitle = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
-		print "[__evUpdatedInfo] title %d of %d (%s)" % (sTagTrackNumber, sTagTrackCount, sTagTitle)
+		print("[__evUpdatedInfo] title %d of %d (%s)" % (sTagTrackNumber, sTagTrackCount, sTagTitle))
 		self.readTitleInformation()
 
 	def __evAudioDecodeError(self):
 		currPlay = self.session.nav.getCurrentService()
 		sTagAudioCodec = currPlay.info().getInfoString(iServiceInformation.sTagAudioCodec)
-		print "[__evAudioDecodeError] audio-codec %s can't be decoded by hardware" % (sTagAudioCodec)
+		print("[__evAudioDecodeError] audio-codec %s can't be decoded by hardware" % (sTagAudioCodec))
 		self.session.open(MessageBox, _("This receiver cannot decode %s streams!") % sTagAudioCodec, type = MessageBox.TYPE_INFO,timeout = 20 )
 
 	def __evVideoDecodeError(self):
 		currPlay = self.session.nav.getCurrentService()
 		sTagVideoCodec = currPlay.info().getInfoString(iServiceInformation.sTagVideoCodec)
-		print "[__evVideoDecodeError] video-codec %s can't be decoded by hardware" % (sTagVideoCodec)
+		print("[__evVideoDecodeError] video-codec %s can't be decoded by hardware" % (sTagVideoCodec))
 		self.session.open(MessageBox, _("This receiver cannot decode %s streams!") % sTagVideoCodec, type = MessageBox.TYPE_INFO,timeout = 20 )
 
 	def __evPluginError(self):
 		currPlay = self.session.nav.getCurrentService()
 		message = currPlay.info().getInfoString(iServiceInformation.sUser+12)
-		print "[__evPluginError]" , message
+		print("[__evPluginError]" , message)
 		self.session.open(MessageBox, message, type = MessageBox.TYPE_INFO,timeout = 20 )
 
 	def delMPTimer(self):
@@ -638,8 +638,8 @@
 		try:
 			for i in os.listdir(playlistdir):
 				listpath.append((i,playlistdir + i))
-		except IOError,e:
-			print "Error while scanning subdirs ",e
+		except IOError as e:
+			print("Error while scanning subdirs ",e)
 		if config.mediaplayer.sortPlaylists.value:
 			listpath.sort()
 		self.session.openWithCallback(self.PlaylistSelected, ChoiceBox, title=_("Please select a playlist..."), list = listpath)
@@ -649,7 +649,7 @@
 			self.playlistname = path[0].rsplit('.',1)[-2]
 			self.clear_playlist()
 			extension = path[0].rsplit('.',1)[-1]
-			if self.playlistparsers.has_key(extension):
+			if extension in self.playlistparsers:
 				playlist = self.playlistparsers[extension]()
 				list = playlist.open(path[1])
 				for x in list:
@@ -662,8 +662,8 @@
 		try:
 			for i in os.listdir(playlistdir):
 				listpath.append((i,playlistdir + i))
-		except IOError,e:
-			print "Error while scanning subdirs ",e
+		except IOError as e:
+			print("Error while scanning subdirs ",e)
 		if config.mediaplayer.sortPlaylists.value:
 			listpath.sort()
 		self.session.openWithCallback(self.DeletePlaylistSelected, ChoiceBox, title=_("Please select a playlist to delete..."), list = listpath)
@@ -677,8 +677,8 @@
 		if confirmed:
 			try:
 				os.remove(self.delname)
-			except OSError,e:
-				print "delete failed:", e
+			except OSError as e:
+				print("delete failed:", e)
 				self.session.open(MessageBox, _("Delete failed!"), MessageBox.TYPE_ERROR)
 
 	def clear_playlist(self):
@@ -688,9 +688,9 @@
 		self.switchToFileList()
 
 	def copyDirectory(self, directory, recursive = True):
-		print "copyDirectory", directory
+		print("copyDirectory", directory)
 		if directory == '/':
-			print "refusing to operate on /"
+			print("refusing to operate on /")
 			return
 		filelist = FileList(directory, useServiceRef = True, showMountpoints = False, isTop = True)
 
@@ -765,7 +765,7 @@
 		if self.filelist.getServiceRef().type == 4098: # playlist
 			ServiceRef = self.filelist.getServiceRef()
 			extension = ServiceRef.getPath()[ServiceRef.getPath().rfind('.') + 1:]
-			if self.playlistparsers.has_key(extension):
+			if extension in self.playlistparsers:
 				playlist = self.playlistparsers[extension]()
 				list = playlist.open(ServiceRef.getPath())
 				for x in list:
@@ -900,7 +900,7 @@
 			self.readTitleInformation()
 
 	def leaveMoviePlayer(self, answer):
-		print "leaveMoviePlayer: ", answer
+		print("leaveMoviePlayer: ", answer)
 		self.MoviePlayerOpen = False
 		if answer == 1:
 			self.session.nav.playService(None)
@@ -1027,7 +1027,7 @@
 			self.setSeekState(self.SEEK_STATE_PLAY)
 
 	def doEofInternal(self, playing):
-		print "--- eofint movieplayer ---"
+		print("--- eofint movieplayer ---")
 		self.is_closing = True
 		self.close(1)
 
--- enigma2-nightly.org/lib/python/Plugins/Extensions/MediaPlayer/settings.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/MediaPlayer/settings.py
@@ -88,7 +88,7 @@
 		self.setTitle(self.setup_title)
 
 	def initConfigList(self, element=None):
-		print "[initConfigList]", element
+		print("[initConfigList]", element)
 		try:
 			self.list = []
 			self.list.append(getConfigListEntry(_("repeat playlist"), config.mediaplayer.repeat))
@@ -100,7 +100,7 @@
 			self.list.append(getConfigListEntry(_("show mediaplayer on mainmenu"), config.mediaplayer.onMainMenu))
 			self["config"].setList(self.list)
 		except KeyError:
-			print "keyError"
+			print("keyError")
 
 	def changedConfigList(self):
 		self.initConfigList()
@@ -110,7 +110,7 @@
 			self.session.openWithCallback(self.DirectoryBrowserClosed, DirectoryBrowser, self.parent.filelist.getCurrentDirectory())
 
 	def DirectoryBrowserClosed(self, path):
-		print "PathBrowserClosed:" + str(path)
+		print("PathBrowserClosed:" + str(path))
 		if path != False:
 			config.mediaplayer.defaultDir.setValue(path)
 
--- enigma2-nightly.org/lib/python/Plugins/Extensions/MediaScanner/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/MediaScanner/plugin.py
@@ -4,7 +4,7 @@
 import os
 
 def execute(option):
-	print "execute", option
+	print("execute", option)
 	if option is None:
 		return
 
@@ -17,7 +17,7 @@
 
 	from Screens.ChoiceBox import ChoiceBox
 
-	print "scanning", option
+	print("scanning", option)
 	(description, mountpoint, session) = option
 	res = scanDevice(mountpoint)
 
@@ -28,7 +28,7 @@
 		if os.access(mountpoint, os.F_OK|os.R_OK):
 			session.open(MessageBox, _("No displayable files on this medium found!"), MessageBox.TYPE_ERROR, simple = True, timeout = 5)
 		else:
-			print "ignore", mountpoint, "because its not accessible"
+			print("ignore", mountpoint, "because its not accessible")
 		return
 
 	session.openWithCallback(execute, ChoiceBox, 
@@ -61,14 +61,14 @@
 	if InfoBar.instance:
 		if InfoBar.instance.execing:
 			if action == 'add' and device.is_hotplug:
-				print "mountpoint", device.mountpoint
-				print "description", device.description
-				print "force_mounted", device.force_mounted
+				print("mountpoint", device.mountpoint)
+				print("description", device.description)
+				print("force_mounted", device.force_mounted)
 				mountpoint_choosen((device.description, device.mountpoint, global_session))
 		else:
-			print "main infobar is not execing... so we ignore hotplug event!"
+			print("main infobar is not execing... so we ignore hotplug event!")
 	else:
-			print "hotplug event.. but no infobar"
+			print("hotplug event.. but no infobar")
 
 def sessionstart(reason, session):
 	global global_session
--- enigma2-nightly.org/lib/python/Plugins/Extensions/Modem/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/Modem/plugin.py
@@ -75,7 +75,7 @@
 
 def pppdClosed(ret):
 	global gateway
-	print "modem disconnected", ret
+	print("modem disconnected", ret)
 	if gateway:
 		#FIXMEEE... hardcoded for little endian!!
 		system("route add default gw %d.%d.%d.%d" %(gateway&0xFF, (gateway>>8)&0xFF, (gateway>>16)&0xFF, (gateway>>24)&0xFF))
@@ -96,7 +96,7 @@
 		</screen>"""
 
 	def nothing(self):
-		print "nothing!"
+		print("nothing!")
 
 	def __init__(self, session, args = None):
 		global connected
@@ -108,7 +108,7 @@
 		self.username = ConfigText(user, fixed_size=False)
 		self.password = ConfigPassword(password, fixed_size=False)
 		self.phone = ConfigText(getTelephone(), fixed_size=False)
-		self.phone.setUseableChars(u"0123456789")
+		self.phone.setUseableChars("0123456789")
 		lst = [ (_("Username"), self.username),
 			(_("Password"), self.password),
 			(_("Phone number"), self.phone) ]
@@ -194,7 +194,7 @@
 			setSecretString(self.username.getText() + ' * ' + self.password.getText())
 			ret = conn.execute("pppd", "pppd", "-d", "-detach")
 			if ret:
-				print "execute pppd failed!"
+				print("execute pppd failed!")
 				self.pppdClosed(ret)
 				pppdClosed(ret)
 			self.green_function = NONE
--- enigma2-nightly.org/lib/python/Plugins/Extensions/ModemSettings/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/ModemSettings/plugin.py
@@ -50,7 +50,7 @@
 					settings.append(line)
 				f.close()
 			except:
-				print "[ModemSettings] ERROR in open configuration file"
+				print("[ModemSettings] ERROR in open configuration file")
 			for line in settings:
 				data = line.replace(' ', '').replace('\t', '')
 				name = data.upper()
@@ -177,7 +177,7 @@
 				settings.close()
 				self.mbox = self.session.open(MessageBox, _("Configuration saved!"), MessageBox.TYPE_INFO, timeout = 3 )
 			except:
-				print "[ModemSettings] ERROR in save settings"
+				print("[ModemSettings] ERROR in save settings")
 			self.close()
 
 def main(session, **kwargs):
--- enigma2-nightly.org/lib/python/Plugins/Extensions/PicturePlayer/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/PicturePlayer/plugin.py
@@ -3,21 +3,21 @@
 #------------------------------------------------------------------------------------------
 
 def Pic_Thumb(*args, **kwa):
-	import ui
+	from . import ui
 	return ui.Pic_Thumb(*args, **kwa)
 
 def picshow(*args, **kwa):
-	import ui
+	from . import ui
 	return ui.picshow(*args, **kwa)
 
 def main(session, **kwargs):
-	from ui import picshow
+	from .ui import picshow
 	session.open(picshow)
 
 def filescan_open(list, session, **kwargs):
 	# Recreate List as expected by PicView
 	filelist = [((file.path, False), None) for file in list]
-	from ui import Pic_Full_View
+	from .ui import Pic_Full_View
 	session.open(Pic_Full_View, filelist, 0, file.path)
 
 def filescan(**kwargs):
--- enigma2-nightly.org/lib/python/Plugins/Extensions/PicturePlayer/ui.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/PicturePlayer/ui.py
@@ -524,7 +524,7 @@
 			self["pic"].instance.setPixmap(self.currPic[2].__deref__())
 			self.currPic = []
 
-			self.next()
+			next(self)
 			self.start_decode()
 
 	def finish_decode(self, picInfo=""):
@@ -547,7 +547,7 @@
 		self.picload.startDecode(self.filelist[self.index])
 		self["point"].show()
 
-	def next(self):
+	def __next__(self):
 		self.index += 1
 		if self.index > self.maxentry:
 			self.index = 0
@@ -558,7 +558,7 @@
 			self.index = self.maxentry
 
 	def slidePic(self):
-		print "slide to next Picture index=" + str(self.lastindex)
+		print("slide to next Picture index=" + str(self.lastindex))
 		if config.pic.loop.value==False and self.lastindex == self.maxentry:
 			self.PlayPause()
 		self.shownow = True
--- enigma2-nightly.org/lib/python/Plugins/Extensions/SocketMMI/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/SocketMMI/plugin.py
@@ -1,5 +1,5 @@
 from Plugins.Plugin import PluginDescriptor
-from SocketMMI import SocketMMIMessageHandler
+from .SocketMMI import SocketMMIMessageHandler
 
 socketHandler = None
 
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TuxboxPlugins/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/TuxboxPlugins/plugin.py
@@ -2,7 +2,7 @@
 from Tools.BoundFunction import boundFunction
 from Tools.Directories import pathExists
 from Plugins.Plugin import PluginDescriptor
-from pluginrunner import PluginRunner
+from .pluginrunner import PluginRunner
 
 from os import listdir
 
@@ -30,13 +30,13 @@
 			params[split[0]] = split[1]
 		file.close()
 	except IOError:
-		print "no tuxbox plugins found"
+		print("no tuxbox plugins found")
 
 	return params
 
 def main(session, plugin, **kwargs):
-	print "Running plugin " + plugin[:-4] + ".so with config file", plugin
-	print getPluginParams(plugin)
+	print("Running plugin " + plugin[:-4] + ".so with config file", plugin)
+	print(getPluginParams(plugin))
 	session.open(PluginRunner, plugin[:-4].split(".so")[0])
 	
 def Plugins(**kwargs):
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TuxboxPlugins/pluginrunner.py
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/TuxboxPlugins/pluginrunner.py
@@ -17,12 +17,12 @@
 		eDBoxLCD.getInstance().lock()
 		eRCInput.getInstance().lock()
 		fbClass.getInstance().lock()
-		print "executing:", ("pluginlauncher -x %s" % pluginname)
+		print("executing:", ("pluginlauncher -x %s" % pluginname))
 		if self.container.execute("pluginlauncher -x %s" % pluginname):
 			self.finishedExecution(None)
 			
 	def finishedExecution(self, retval = 1):
-		print "PluginRunner retval:", retval
+		print("PluginRunner retval:", retval)
 		fbClass.getInstance().unlock()
 		eRCInput.getInstance().unlock()
 		eDBoxLCD.getInstance().unlock()
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/plugin.py
@@ -43,7 +43,7 @@
 
 		NUM_CI=eDVBCIInterfaces.getInstance().getNumOfSlots()
 
-		print "[CI_Wizzard] FOUND %d CI Slots " % NUM_CI
+		print("[CI_Wizzard] FOUND %d CI Slots " % NUM_CI)
 
 		self.dlg = None
 		self.state = { }
@@ -76,9 +76,9 @@
 			action = cur[2]
 			slot = cur[3]
 			if action == 1:
-				print "[CI_Wizzard] there is no CI Slot in your receiver"
+				print("[CI_Wizzard] there is no CI Slot in your receiver")
 			else:
-				print "[CI_Wizzard] selected CI Slot : %d" % slot
+				print("[CI_Wizzard] selected CI Slot : %d" % slot)
 				if config.usage.setup_level.index > 1: # advanced
 					self.session.open(CIconfigMenu, slot)
 				else:
@@ -135,16 +135,16 @@
 				"cancel": self.cancel
 			}, -1)
 
-		print "[CI_Wizzard_Config] Configuring CI Slots : %d  " % self.ci_slot
+		print("[CI_Wizzard_Config] Configuring CI Slots : %d  " % self.ci_slot)
 
 		i=0
 		self.caidlist=[]
-		print eDVBCIInterfaces.getInstance().readCICaIds(self.ci_slot)
+		print(eDVBCIInterfaces.getInstance().readCICaIds(self.ci_slot))
 		for caid in eDVBCIInterfaces.getInstance().readCICaIds(self.ci_slot):
 			i+=1
 			self.caidlist.append((str(hex(int(caid))),str(caid),i))
 
-		print "[CI_Wizzard_Config_CI%d] read following CAIds from CI: %s" %(self.ci_slot, self.caidlist)
+		print("[CI_Wizzard_Config_CI%d] read following CAIds from CI: %s" %(self.ci_slot, self.caidlist))
 
 		self.selectedcaid = []
 		self.servicelist = []
@@ -254,7 +254,7 @@
 			fp.write("</ci>\n")
 			fp.close()
 		except:
-			print "[CI_Config_CI%d] xml not written" %self.ci_slot
+			print("[CI_Config_CI%d] xml not written" %self.ci_slot)
 			os.unlink(self.filename)
 
 	def loadXML(self):
@@ -274,13 +274,13 @@
 			self.ci_config=[]
 			for slot in tree.findall("slot"):
 				read_slot = getValue(slot.findall("id"), False).encode("UTF-8")
-				print "ci " + read_slot
+				print("ci " + read_slot)
 
 				i=0
 				for caid in slot.findall("caid"):
 					read_caid = caid.get("id").encode("UTF-8")
 					self.selectedcaid.append((str(read_caid),str(read_caid),i))
-					self.usingcaid.append(long(read_caid,16))
+					self.usingcaid.append(int(read_caid,16))
 					i+=1
 
 				for service in  slot.findall("service"):
@@ -295,7 +295,7 @@
 
 				self.ci_config.append((int(read_slot), (self.read_services, self.read_providers, self.usingcaid)))
 		except:
-			print "[CI_Config_CI%d] error parsing xml..." %self.ci_slot
+			print("[CI_Config_CI%d] error parsing xml..." %self.ci_slot)
 
 		for item in self.read_services:
 			if len(item):
@@ -305,7 +305,7 @@
 			if len(item):
 				self.finishedProviderSelection(item[0],item[1])
 
-		print self.ci_config
+		print(self.ci_config)
 		self.finishedCAidSelection(self.selectedcaid)
 		self["ServiceList"].l.setList(self.servicelist)
 		self.setServiceListInfo()
@@ -382,7 +382,7 @@
 
 	def greenPressed(self):
 		list = self.list.getSelectionsList()
-		print list
+		print(list)
 		self.close(list)
 
 	def cancel(self):
@@ -556,7 +556,7 @@
 
 def activate_all(session):
 	NUM_CI=eDVBCIInterfaces.getInstance().getNumOfSlots()
-	print "[CI_Activate] FOUND %d CI Slots " % NUM_CI
+	print("[CI_Activate] FOUND %d CI Slots " % NUM_CI)
 	if NUM_CI > 0:
 		ci_config=[]
 		def getValue(definitions, default):
@@ -570,7 +570,7 @@
 			filename = eEnv.resolve("${sysconfdir}/enigma2/ci") + str(ci) + ".xml"
 
 			if not os_path.exists(filename):
-				print "[CI_Activate_Config_CI%d] no config file found" %ci
+				print("[CI_Activate_Config_CI%d] no config file found" %ci)
 
 			try:
 				tree = ci_parse(filename).getroot()
@@ -582,7 +582,7 @@
 
 					for caid in slot.findall("caid"):
 						read_caid = caid.get("id").encode("UTF-8")
-						usingcaid.append(long(read_caid,16))
+						usingcaid.append(int(read_caid,16))
 
 					for service in slot.findall("service"):
 						read_service_ref = service.get("ref").encode("UTF-8")
@@ -591,20 +591,20 @@
 					for provider in slot.findall("provider"):
 						read_provider_name = provider.get("name").encode("UTF-8")
 						read_provider_dvbname = provider.get("dvbnamespace").encode("UTF-8")
-						read_providers.append((read_provider_name,long(read_provider_dvbname,16)))
+						read_providers.append((read_provider_name,int(read_provider_dvbname,16)))
 
 					ci_config.append((int(read_slot), (read_services, read_providers, usingcaid)))
 			except:
-				print "[CI_Activate_Config_CI%d] error parsing xml..." %ci
+				print("[CI_Activate_Config_CI%d] error parsing xml..." %ci)
 
 		for item in ci_config:
-			print "[CI_Activate] activate CI%d with following settings:" %item[0]
-			print item[0]
-			print item[1]
+			print("[CI_Activate] activate CI%d with following settings:" %item[0])
+			print(item[0])
+			print(item[1])
 			try:
 				eDVBCIInterfaces.getInstance().setDescrambleRules(item[0],item[1])
 			except:
-				print "[CI_Activate_Config_CI%d] error setting DescrambleRules..." %item[0]
+				print("[CI_Activate_Config_CI%d] error setting DescrambleRules..." %item[0])
 
 def find_in_list(list, search, listpos=0):
 	for item in list:
@@ -621,7 +621,7 @@
 def autostart(reason, **kwargs):
 	global global_session
 	if reason == 0:
-		print "[CI_Assignment] activating ci configs:"
+		print("[CI_Assignment] activating ci configs:")
 		activate_all(global_session)
 	elif reason == 1:
 		global_session = None
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/DefaultServicesScanner/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/DefaultServicesScanner/plugin.py
@@ -78,11 +78,11 @@
 				self.multiscanlist[satindex][1].value = True
 				
 	def runScan(self):
-		print "runScan"
+		print("runScan")
 		self.keyGo()
 
 	def startScan(self, tlist, flags, feid, networkid = 0):
-		print "startScan"
+		print("startScan")
 		if len(tlist):
 			# flags |= eComponentScan.scanSearchBAT
 			self.session.openWithCallback(self.scanFinished, DefaultServiceScan, [{"transponders": tlist, "feid": feid, "flags": flags, "networkid": networkid}])
@@ -90,13 +90,13 @@
 			self.session.openWithCallback(self.scanFinished, MessageBox, _("Nothing to scan!\nPlease setup your tuner settings before you start a service scan."), MessageBox.TYPE_ERROR)
 
 	def scanFinished(self, value = None):
-		print "finished"
-		print "self.scanIndex:", self.scanIndex
+		print("finished")
+		print("self.scanIndex:", self.scanIndex)
 		db = eDVBDB.getInstance()
-		print "self.multiscanlist:", self.multiscanlist
+		print("self.multiscanlist:", self.multiscanlist)
 		if len(self.multiscanlist) - 1 >= self.scanIndex and len(self.multiscanlist[self.scanIndex]) > 0:
 			satint = self.multiscanlist[self.scanIndex][0]
-			print "scanned sat:", satint
+			print("scanned sat:", satint)
 			db.saveServicelist("/tmp/lamedb." + str(satint))
 			file = open("/tmp/sat" + str(satint) + ".info", "w")
 			xml = """<default>
@@ -121,7 +121,7 @@
 		
 		self.scanIndex += 1
 		if self.scanIndex + 1 >= len(self.multiscanlist):
-			print "no more sats to scan"
+			print("no more sats to scan")
 			confdir = resolveFilename(SCOPE_CONFIG)
 			copyfile(confdir + "/lamedb.backup", confdir + "/lamedb")
 			db.reloadServicelist()
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/DiseqcTester/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/DiseqcTester/plugin.py
@@ -58,14 +58,14 @@
 				reasons[transponder[2]] = reasons.get(transponder[2], [])
 				reasons[transponder[2]].append(transponder)
 				if transponder[2] == "pids_failed":
-					print transponder[2], "-", transponder[3]
+					print(transponder[2], "-", transponder[3])
 				
 			text += "The %d unsuccessful tuning attempts failed for the following reasons:\n" % countfailed
 			
-			for reason in reasons.keys():
+			for reason in list(reasons.keys()):
 				text += "%s: %d transponders failed\n" % (reason, len(reasons[reason]))
 			
-			for reason in reasons.keys():
+			for reason in list(reasons.keys()):
 				text += "\n"
 				text += "%s previous planes:\n" % reason
 				for transponder in reasons[reason]:
@@ -111,17 +111,17 @@
 		if self.type == self.TYPE_BYINDEX:
 			text += self.getTextualResultForIndex(self.index)
 		elif self.type == self.TYPE_BYORBPOS:
-			for index in self.results.keys():
+			for index in list(self.results.keys()):
 				if index[2] == self.orbpos:
 					text += self.getTextualResultForIndex(index)
 					text += "\n-----------------------------------------------------\n"
 		elif self.type == self.TYPE_ALL:
 			orderedResults = {}
-			for index in self.results.keys():
+			for index in list(self.results.keys()):
 				orbpos = index[2]
 				orderedResults[orbpos] = orderedResults.get(orbpos, [])
 				orderedResults[orbpos].append(index)
-			ordered_orbpos = orderedResults.keys()
+			ordered_orbpos = list(orderedResults.keys())
 			ordered_orbpos.sort()
 			for orbpos in ordered_orbpos:
 				text += "\n*****************************************\n"
@@ -308,7 +308,7 @@
 	
 	# returns a string for the user representing a human readable output for index 
 	def getTextualIndexRepresentation(self, index):
-		print "getTextualIndexRepresentation:", index
+		print("getTextualIndexRepresentation:", index)
 		text = ""
 		
 		text += nimmanager.getSatDescription(index[2]) + ", "
@@ -326,14 +326,14 @@
 	
 	def fillTransponderList(self):
 		self.clearTransponder()
-		print "----------- fillTransponderList"
-		print "index:", self.currentlyTestedIndex
-		keys = self.indexlist.keys()
+		print("----------- fillTransponderList")
+		print("index:", self.currentlyTestedIndex)
+		keys = list(self.indexlist.keys())
 		if self.getContinueScanning():
-			print "index:", self.getTextualIndexRepresentation(self.currentlyTestedIndex)
+			print("index:", self.getTextualIndexRepresentation(self.currentlyTestedIndex))
 			for transponder in self.indexlist[self.currentlyTestedIndex]:
 				self.addTransponder(transponder)
-			print "transponderList:", self.transponderlist
+			print("transponderList:", self.transponderlist)
 			return True
 		else:
 			return False
@@ -349,21 +349,21 @@
 		# TODO use other function to scan more randomly
 		if self.test_type == self.TEST_TYPE_QUICK:
 			self.myindex = 0
-			keys = self.indexlist.keys()
+			keys = list(self.indexlist.keys())
 			keys.sort(key = lambda a: a[2]) # sort by orbpos
 			self["overall_progress"].setRange(len(keys))
 			self["overall_progress"].setValue(self.myindex)
 			return keys[0]
 		elif self.test_type == self.TEST_TYPE_RANDOM:
-			self.randomkeys = self.indexlist.keys()
+			self.randomkeys = list(self.indexlist.keys())
 			random.shuffle(self.randomkeys)
 			self.myindex = 0
 			self["overall_progress"].setRange(len(self.randomkeys))
 			self["overall_progress"].setValue(self.myindex)
 			return self.randomkeys[0]
 		elif self.test_type == self.TEST_TYPE_COMPLETE:
-			keys = self.indexlist.keys()
-			print "keys:", keys
+			keys = list(self.indexlist.keys())
+			print("keys:", keys)
 			successorindex = {}
 			for index in keys:
 				successorindex[index] = []
@@ -377,7 +377,7 @@
 			while not stop:
 				if currindex is None or len(successorindex[currindex]) == 0:
 					oldindex = currindex
-					for index in successorindex.keys():
+					for index in list(successorindex.keys()):
 						if len(successorindex[index]) > 0:
 							currindex = index
 							self.keylist.append(currindex)
@@ -387,7 +387,7 @@
 				else:
 					currindex = successorindex[currindex].pop()
 					self.keylist.append(currindex)
-			print "self.keylist:", self.keylist
+			print("self.keylist:", self.keylist)
 			self.myindex = 0
 			self["overall_progress"].setRange(len(self.keylist))
 			self["overall_progress"].setValue(self.myindex)
@@ -399,7 +399,7 @@
 		# TODO use other function to scan more randomly
 		if self.test_type == self.TEST_TYPE_QUICK:
 			self.myindex += 1
-			keys = self.indexlist.keys()
+			keys = list(self.indexlist.keys())
 			keys.sort(key = lambda a: a[2]) # sort by orbpos
 			
 			self["overall_progress"].setValue(self.myindex)
@@ -430,7 +430,7 @@
 	# the algorithm checks, if we should continue scanning
 	def getContinueScanning(self):
 		if self.test_type == self.TEST_TYPE_QUICK or self.test_type == self.TEST_TYPE_RANDOM:
-			return (self.myindex < len(self.indexlist.keys()))
+			return (self.myindex < len(list(self.indexlist.keys())))
 		elif self.test_type == self.TEST_TYPE_COMPLETE:
 			return (self.myindex < len(self.keylist))
 		
@@ -479,10 +479,10 @@
 		self.resultsstatus[status].append(index)
 	
 	def finishedChecking(self):
-		print "finishedChecking"
+		print("finishedChecking")
 		TuneTest.finishedChecking(self)
 
-		if not self.results.has_key(self.currentlyTestedIndex):
+		if self.currentlyTestedIndex not in self.results:
 			self.results[self.currentlyTestedIndex] = {"failed": [], "successful": [], "status": None, "internalstatus": None}
 		
 		if len(self.failedTune) > 0 and len(self.successfullyTune) > 0:
@@ -518,8 +518,8 @@
 		else:
 			self.running = False
 			self["progress_list"].setIndex(0)
-			print "results:", self.results
-			print "resultsstatus:", self.resultsstatus
+			print("results:", self.results)
+			print("resultsstatus:", self.resultsstatus)
 			if self.log:
 				file = open("/media/hdd/diseqctester.log", "w")
 				self.setResultType(ResultParser.TYPE_ALL)
@@ -544,7 +544,7 @@
 		self.close()
 		
 	def select(self):
-		print "selectedIndex:", self["progress_list"].getCurrent()[0]
+		print("selectedIndex:", self["progress_list"].getCurrent()[0])
 		if not self.running:
 			index = self["progress_list"].getCurrent()[0]
 			#self.setResultType(ResultParser.TYPE_BYORBPOS)
@@ -555,7 +555,7 @@
 			self.session.open(TextBox, self.getTextualResult())
 	
 	def selectionChanged(self):
-		print "selection changed"
+		print("selection changed")
 		if len(self.list) > 0 and not self.running:
 			self["CmdText"].setText(_("Press OK to get further details for %s") % str(self["progress_list"].getCurrent()[1]))
 
@@ -611,7 +611,7 @@
 		self["config"].l.setList(self.list)
 		
 	def keyOK(self):
-		print self.testtype.getValue()
+		print(self.testtype.getValue())
 		testtype = DiseqcTester.TEST_TYPE_QUICK
 		if self.testtype.getValue() == "quick":
 			testtype = DiseqcTester.TEST_TYPE_QUICK
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/FastScan/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/FastScan/plugin.py
@@ -160,7 +160,7 @@
 			"menu": self.closeRecursive,
 		}, -2)
 
-		providerList = list(x[0] for x in sorted(self.providers.iteritems(), key = operator.itemgetter(1)))
+		providerList = list(x[0] for x in sorted(iter(self.providers.items()), key = operator.itemgetter(1)))
 
 		lastConfiguration = eval(config.misc.fastscan.last_configuration.value)
 		if not lastConfiguration:
@@ -195,7 +195,7 @@
 		self["introduction"] = Label(_("Select your provider, and press OK to start the scan"))
 
 	def keyGo(self):
-		config.misc.fastscan.last_configuration.value = `(self.scan_nims.value, self.scan_provider.value, self.scan_hd.value, self.scan_keepnumbering.value, self.scan_keepsettings.value)`
+		config.misc.fastscan.last_configuration.value = repr((self.scan_nims.value, self.scan_provider.value, self.scan_hd.value, self.scan_keepnumbering.value, self.scan_keepsettings.value))
 		config.misc.fastscan.save()
 		self.startScan()
 
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
@@ -5,7 +5,7 @@
 hotplugNotifier = []
 
 def processHotplugData(self, v):
-	print "hotplug:", v
+	print("hotplug:", v)
 	action = v.get("ACTION")
 	device = v.get("DEVPATH")
 	physdevpath = v.get("PHYSDEVPATH")
@@ -34,16 +34,16 @@
 
 class Hotplug(Protocol):
 	def connectionMade(self):
-		print "HOTPLUG connection!"
+		print("HOTPLUG connection!")
 		self.received = ""
 
 	def dataReceived(self, data):
-		print "hotplug:", data
+		print("hotplug:", data)
 		self.received += data
-		print "complete", self.received
+		print("complete", self.received)
 
 	def connectionLost(self, reason):
-		print "HOTPLUG connection lost!"
+		print("HOTPLUG connection lost!")
 		data = self.received.split('\0')[:-1]
 		v = {}
 		for x in data:
@@ -54,7 +54,7 @@
 
 def autostart(reason, **kwargs):
 	if reason == 0:
-		print "starting hotplug handler"
+		print("starting hotplug handler")
 		from twisted.internet import reactor
 		import os
 		try:
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/NFIFlash/downloader.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/NFIFlash/downloader.py
@@ -52,7 +52,7 @@
 		self.weighting = 1
 
 	def processOutput(self, data):
-		print "[MountTask] output:", data
+		print("[MountTask] output:", data)
 
 class UmountTask(Task):
 	def __init__(self, job, mountpoint):
@@ -86,10 +86,10 @@
 		self.download = downloadWithProgress(self.url,self.path)
 		self.download.addProgress(self.download_progress)
 		self.download.start().addCallback(self.download_finished).addErrback(self.download_failed)
-		print "[ImageDownloadTask] downloading", self.url, "to", self.path
+		print("[ImageDownloadTask] downloading", self.url, "to", self.path)
 
 	def abort(self):
-		print "[ImageDownloadTask] aborting", self.url
+		print("[ImageDownloadTask] aborting", self.url)
 		if self.download:
 			self.download.stop()
 		self.aborted = True
@@ -142,7 +142,7 @@
 		}[task.error]
 		
 class PartitionTask(Task):
-	ERROR_UNKNOWN, ERROR_BLKRRPART = range(2)
+	ERROR_UNKNOWN, ERROR_BLKRRPART = list(range(2))
 	def __init__(self, job):
 		Task.__init__(self, job, ("partitioning"))
 		self.postconditions.append(PartitionTaskPostcondition())
@@ -157,7 +157,7 @@
 		Task.run(self, callback)
 	
 	def processOutput(self, data):
-		print "[PartitionTask] output:", data
+		print("[PartitionTask] output:", data)
 		if data.startswith("BLKRRPART:"):
 			self.error = self.ERROR_BLKRRPART
 		else:
@@ -183,7 +183,7 @@
 		self.progress += 1
 
 	def processOutput(self, data):
-		print "[UnpackTask] output: \'%s\'" % data
+		print("[UnpackTask] output: \'%s\'" % data)
 		self.job.imagefilename = data
 	
 	def afterRun(self):
@@ -208,7 +208,7 @@
 		self.progress += 1
 
 	def processOutput(self, data):
-		print "[CopyTask] output:", data
+		print("[CopyTask] output:", data)
 
 	def afterRun(self):
 		self.delayTimer.callback.remove(self.progress_increment)
@@ -243,24 +243,24 @@
 
 class feedDownloader:
 	def __init__(self, feed_base, box, OE_vers):
-		print "[feedDownloader::init] feed_base=%s, box=%s" % (feed_base, box)
+		print("[feedDownloader::init] feed_base=%s, box=%s" % (feed_base, box))
 		self.feed_base = feed_base
 		self.OE_vers = OE_vers
 		self.box = box
 	
 	def getList(self, callback, errback):
 		self.urlbase = "%s/%s/%s/images/" % (self.feed_base, self.OE_vers, self.box)
-		print "[getList]", self.urlbase
+		print("[getList]", self.urlbase)
 		self.callback = callback
 		self.errback = errback
 		client.getPage(self.urlbase).addCallback(self.feed_finished).addErrback(self.feed_failed)
 
 	def feed_failed(self, failure_instance):
-		print "[feed_failed]", str(failure_instance)
+		print("[feed_failed]", str(failure_instance))
 		self.errback(failure_instance.getErrorMessage())
 
 	def feed_finished(self, feedhtml):
-		print "[feed_finished]"
+		print("[feed_finished]")
 		fileresultmask = re.compile("<a class=[\'\"]nfi[\'\"] href=[\'\"](?P<url>.*?)[\'\"]>(?P<name>.*?.nfi)</a>", re.DOTALL)
 		searchresults = fileresultmask.finditer(feedhtml)
 		fileresultlist = []
@@ -310,7 +310,7 @@
 		self.onClose.append(self.removeHotplug)
 
 	def hotplugCB(self, dev, action):
-		print "[hotplugCB]", dev, action
+		print("[hotplugCB]", dev, action)
 		self.updateButton()
 	
 	def updateButton(self):
@@ -321,7 +321,7 @@
 			self["key_green"].text = ""
 	
 	def removeHotplug(self):
-		print "[removeHotplug]"
+		print("[removeHotplug]")
 		hotplugNotifier.remove(self.hotplugCB)
 
 	def ok(self):
@@ -332,7 +332,7 @@
 				self.filelist.descent()
 
 	def use(self):
-		print "[use]", self["filelist"].getCurrentDirectory(), self["filelist"].getFilename()
+		print("[use]", self["filelist"].getCurrentDirectory(), self["filelist"].getFilename())
 		if self["filelist"].getCurrentDirectory() is not None:
 			if self.filelist.canDescent() and self["filelist"].getFilename() and len(self["filelist"].getFilename()) > len(self["filelist"].getCurrentDirectory()):
 				self.filelist.descent()
@@ -343,7 +343,7 @@
 	def exit(self):
 		self.close(False)
 
-(ALLIMAGES, RELEASE, EXPERIMENTAL, STICK_WIZARD, START) = range(5)
+(ALLIMAGES, RELEASE, EXPERIMENTAL, STICK_WIZARD, START) = list(range(5))
 
 class NFIDownload(Screen):
 	skin = """
@@ -427,7 +427,7 @@
 		self.target_dir = None
 
 	def tool_avail(self, string):
-		print "[tool_avail]" + string
+		print("[tool_avail]" + string)
 		self.taskstring += string
 
 	def go(self):
@@ -440,7 +440,7 @@
 		client.getPage(url).addCallback(self.md5sums_finished).addErrback(self.feed_failed)
 
 	def md5sums_finished(self, data):
-		print "[md5sums_finished]", data
+		print("[md5sums_finished]", data)
 		self.stickimage_md5 = data
 		self.checkUSBStick()
 
@@ -457,7 +457,7 @@
 			self.session.open(NFOViewer, self.nfo)
 
 	def keyOk(self):
-		print "[keyOk]", self["menu"].getCurrent()
+		print("[keyOk]", self["menu"].getCurrent())
 		current = self["menu"].getCurrent()
 		if current:
 			if self.branch == START:
@@ -509,7 +509,7 @@
 				self.nfo_download(ALLIMAGES, self["menu"].getIndex())
 
 	def listImages(self):
-		print "[listImages]"
+		print("[listImages]")
 		imagelist = []
 		mask = re.compile("%s/(?P<OE_vers>1\.\d)/%s/images/(?P<branch>.*?)-%s_(?P<version>.*?).nfi" % (self.feed_base, self.box, self.box), re.DOTALL)
 		for name, url in self.feedlists[ALLIMAGES]:
@@ -525,10 +525,10 @@
 	
 	def getUSBPartitions(self):
 		allpartitions = [ (r.description, r.mountpoint) for r in harddiskmanager.getMountedPartitions(onlyhotplug = True)]
-		print "[getUSBPartitions]", allpartitions
+		print("[getUSBPartitions]", allpartitions)
 		usbpartition = []
 		for x in allpartitions:
-			print x, x[1] == '/', x[0].find("USB"), access(x[1], R_OK)
+			print(x, x[1] == '/', x[0].find("USB"), access(x[1], R_OK))
 			if x[1] != '/' and x[0].find("USB") > -1:  # and access(x[1], R_OK) is True:
 				usbpartition.append(x)
 		return usbpartition
@@ -545,7 +545,7 @@
 		self.session.openWithCallback(self.DeviceBrowserClosed, DeviceBrowser, None, showDirectories=True, showMountpoints=True, inhibitMounts=["/autofs/sr0/"])
 
 	def DeviceBrowserClosed(self, path):
-		print "[DeviceBrowserClosed]", str(path)
+		print("[DeviceBrowserClosed]", str(path))
 		self.target_dir = path
 		if path:
 			self.ackDestinationDevice()
@@ -562,14 +562,14 @@
 		self.session.openWithCallback(self.ackDestination_query, ChoiceBox, title=message, list=choices)
 
 	def ackDestination_query(self, choice):
-		print "[ackDestination_query]", choice
+		print("[ackDestination_query]", choice)
 		if isinstance(choice, tuple):
 			choice[1]()
 		else:
 			self.keyRed()
 
 	def ackedDestination(self):
-		print "[ackedDestination]", self.branch, self.target_dir
+		print("[ackedDestination]", self.branch, self.target_dir)
 		self.container.setCWD(resolveFilename(SCOPE_MEDIA)+"usb/")
 		if self.target_dir[:8] == "/autofs/":
 			self.target_dir = "/dev/" + self.target_dir[8:-1]
@@ -584,7 +584,7 @@
 		elif self.branch != STICK_WIZARD:
 			url = self.feedlists[self.branch][self.image_idx][1]
 			filename = self.feedlists[self.branch][self.image_idx][0]
-			print "[getImage] start downloading %s to %s" % (url, filename)
+			print("[getImage] start downloading %s to %s" % (url, filename))
 			if self.target_dir.startswith("/dev/"):
 				job = ImageDownloadJob(url, filename, self.target_dir, self.usbmountpoint)
 			else:
@@ -595,7 +595,7 @@
 			self.session.openWithCallback(self.ImageDownloadCB, JobView, job, afterEventChangeable = False)
 
 	def StickWizardCB(self, ret=None):
-		print "[StickWizardCB]", ret
+		print("[StickWizardCB]", ret)
 #		print job_manager.active_jobs, job_manager.failed_jobs, job_manager.job_classes, job_manager.in_background, job_manager.active_job
 		if len(job_manager.failed_jobs) == 0:
 			self.session.open(MessageBox, _("The USB stick was prepared to be bootable.\nNow you can download an NFI image file!"), type = MessageBox.TYPE_INFO)
@@ -608,7 +608,7 @@
 			self.umount()
 
 	def ImageDownloadCB(self, ret):
-		print "[ImageDownloadCB]", ret
+		print("[ImageDownloadCB]", ret)
 #		print job_manager.active_jobs, job_manager.failed_jobs, job_manager.job_classes, job_manager.in_background, job_manager.active_job
 		if len(job_manager.failed_jobs) == 0:
 			self.session.openWithCallback(self.askBackupCB, MessageBox, _("The wizard can backup your current settings. Do you want to do a backup now?"), MessageBox.TYPE_YESNO)
@@ -646,7 +646,7 @@
 		self["status"].text = _("Could not connect to receiver .NFI image feed server:") + "\n" + str(message) + "\n" + _("Please check your network settings!")
 
 	def gotFeed(self, feedlist, OE_vers):
-		print "[gotFeed]", OE_vers
+		print("[gotFeed]", OE_vers)
 		releaselist = []
 		experimentallist = []
 		
@@ -669,21 +669,21 @@
 	def checkUSBStick(self):
 		self.target_dir = None
 		allpartitions = [ (r.description, r.mountpoint) for r in harddiskmanager.getMountedPartitions(onlyhotplug = True)]
-		print "[checkUSBStick] found partitions:", allpartitions
+		print("[checkUSBStick] found partitions:", allpartitions)
 		usbpartition = []
 		for x in allpartitions:
-			print x, x[1] == '/', x[0].find("USB"), access(x[1], R_OK)
+			print(x, x[1] == '/', x[0].find("USB"), access(x[1], R_OK))
 			if x[1] != '/' and x[0].find("USB") > -1:  # and access(x[1], R_OK) is True:
 				usbpartition.append(x)
 
-		print usbpartition
+		print(usbpartition)
 		if len(usbpartition) == 1:
 			self.target_dir = usbpartition[0][1]
 			self.md5_passback = self.getFeed
 			self.md5_failback = self.askStartWizard
 			self.md5verify(self.stickimage_md5, self.target_dir)
 		elif usbpartition == []:
-			print "[NFIFlash] needs to create usb flasher stick first!"
+			print("[NFIFlash] needs to create usb flasher stick first!")
 			self.askStartWizard()
 		else:
 			self.askStartWizard()
@@ -697,7 +697,7 @@
 		self.session.openWithCallback(self.wizardDeviceBrowserClosed, DeviceBrowser, None, message, showDirectories=True, showMountpoints=True, inhibitMounts=["/","/autofs/sr0/","/autofs/sda1/","/media/hdd/","/media/net/",self.usbmountpoint,"/media/dvd/"])
 
 	def wizardDeviceBrowserClosed(self, path):
-		print "[wizardDeviceBrowserClosed]", path
+		print("[wizardDeviceBrowserClosed]", path)
 		self.target_dir = path
 		if path:
 			self.md5_passback = self.getFeed
@@ -707,7 +707,7 @@
 			self.close()
 	
 	def wizardQuery(self):
-		print "[wizardQuery]"
+		print("[wizardQuery]")
 		description = self.target_dir
 		for name, dev in self.getUSBPartitions():
 			if dev == self.target_dir:
@@ -742,23 +742,23 @@
 	def nfo_download(self, branch, idx):
 		nfourl = (self.feedlists[branch][idx][1])[:-4]+".nfo"
 		self.nfofilename = (self.feedlists[branch][idx][0])[:-4]+".nfo"
-		print "[check_for_NFO]", nfourl
+		print("[check_for_NFO]", nfourl)
 		client.getPage(nfourl).addCallback(self.nfo_finished).addErrback(self.nfo_failed)
 
 	def nfo_failed(self, failure_instance):
-		print "[nfo_failed] " + str(failure_instance)
+		print("[nfo_failed] " + str(failure_instance))
 		self["key_blue"].text = ""
 		self.nfofilename = ""
 		self.nfo = ""
 
 	def nfo_finished(self,nfodata=""):
-		print "[nfo_finished] " + str(nfodata)
+		print("[nfo_finished] " + str(nfodata))
 		self["key_blue"].text = _("Changelog")
 		self.nfo = nfodata
 
 	def md5verify(self, md5, path):
 		cmd = "md5sum -c -s"
-		print "[verify_md5]", md5, path, cmd
+		print("[verify_md5]", md5, path, cmd)
 		self.container.setCWD(path)
 		self.container.appClosed.append(self.md5finished)
 		self.container.execute(cmd)
@@ -769,25 +769,25 @@
 		self.container.sendEOF()
 
 	def md5finished(self, retval):
-		print "[md5finished]", str(retval)
+		print("[md5finished]", str(retval))
 		self.container.appClosed.remove(self.md5finished)
 		self.container.dataSent.remove(self.md5ready)
 		if retval==0:
-			print "check passed! calling", repr(self.md5_passback)
+			print("check passed! calling", repr(self.md5_passback))
 			self.md5_passback()
 		else:
-			print "check failed! calling", repr(self.md5_failback)
+			print("check failed! calling", repr(self.md5_failback))
 			self.md5_failback()
 
 	def umount(self):
 		cmd = "umount " + self.usbmountpoint
-		print "[umount]", cmd
+		print("[umount]", cmd)
 		self.container.setCWD('/')
 		self.container.appClosed.append(self.umountFinished)
 		self.container.execute(cmd)
 
 	def umountFinished(self, retval):
-		print "[umountFinished]", str(retval)
+		print("[umountFinished]", str(retval))
 		self.container.appClosed.remove(self.umountFinished)
 		self.umountCallback()
 
@@ -796,7 +796,7 @@
 
 def filescan_open(list, session, **kwargs):
 	dev = "/dev/" + (list[0].path).rsplit('/',1)[0][7:]
-	print "mounting device " + dev + " to /media/usb..."
+	print("mounting device " + dev + " to /media/usb...")
 	usbmountpoint = resolveFilename(SCOPE_MEDIA)+"usb/"
 	system("mount %s %s -o rw,sync" % (dev, usbmountpoint))
 	session.open(NFIDownload,usbmountpoint)
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/NFIFlash/flasher.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/NFIFlash/flasher.py
@@ -19,7 +19,7 @@
 
 class md5Postcondition(Condition):
 	def check(self, task):
-		print "md5Postcondition::check", task.returncode
+		print("md5Postcondition::check", task.returncode)
 		return task.returncode == 0
 
 	def getErrorMessage(self, task):
@@ -39,14 +39,14 @@
 	
 	def writeInput(self, input):
 		self.container.dataSent.append(self.md5ready)
-		print "[writeInput]", input
+		print("[writeInput]", input)
 		Task.writeInput(self, input)
 
 	def md5ready(self, retval):
 		self.container.sendEOF()
 
 	def processOutput(self, data):
-		print "[md5sum]",
+		print("[md5sum]", end=' ')
 
 class writeNAND(Task):
 	def __init__(self, job, param, box):
@@ -60,11 +60,11 @@
 		self.weighting = 95
 
 	def processOutput(self, data):
-		print "[writeNand] " + data
+		print("[writeNand] " + data)
 		if data == "." or data.endswith(" ."):
 			self.progress += 1
 		elif data.find("*** done!") > 0:
-			print "data.found done"
+			print("data.found done")
 			self.setProgress(self.end)
 		else:
 			self.output_line = data
@@ -121,9 +121,9 @@
 	def autostart(self):
 		self.onShown.remove(self.autostart)
 		self.check_for_NFO()
-		print "[[layoutFinished]]", len(self["filelist"].getFileList())
+		print("[[layoutFinished]]", len(self["filelist"].getFileList()))
 		if len(self["filelist"].getFileList()) == 1:
-			print "==1"
+			print("==1")
 			self.keyOk()
 
 	def keyUp(self):
@@ -151,7 +151,7 @@
 				self.session.openWithCallback(self.queryCB, MessageBox, _("Shall the USB stick wizard proceed and program the image file %s into flash memory?" % self.nfifile.rsplit('/',1)[-1]), MessageBox.TYPE_YESNO)
 
 	def check_for_NFO(self, nfifile=None):
-		print "check_for_NFO", self["filelist"].getFilename(), self["filelist"].getCurrentDirectory()
+		print("check_for_NFO", self["filelist"].getFilename(), self["filelist"].getCurrentDirectory())
 		self["infolabel"].text = ""
 		self["key_green"].text = ""
 
@@ -166,10 +166,10 @@
 		if self.nfifile.upper().endswith(".NFI"):
 			self["key_green"].text = _("Flash")
 			nfofilename = self.nfifile[0:-3]+"nfo"
-			print nfofilename, fileExists(nfofilename)
+			print(nfofilename, fileExists(nfofilename))
 			if fileExists(nfofilename):
 				nfocontent = open(nfofilename, "r").read()
-				print "nfocontent:", nfocontent
+				print("nfocontent:", nfocontent)
 				self["infolabel"].text = nfocontent
 				pos = nfocontent.find("MD5:")
 				if pos > 0:
@@ -197,7 +197,7 @@
 		self.session.openWithCallback(self.flashed, JobView, self.job, cancelable = False, backgroundable = False, afterEventChangeable = False)
 
 	def flashed(self, bg):
-		print "[flashed]"
+		print("[flashed]")
 		if self.job.status == self.job.FINISHED:
 			self["status"].text = _("NFI image flashing completed. Press Yellow to Reboot!")
 			filename = self.usbmountpoint+'enigma2settingsbackup.tar.gz'
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/NFIFlash/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/NFIFlash/plugin.py
@@ -1,8 +1,8 @@
 from Plugins.Plugin import PluginDescriptor
 from Tools.HardwareInfo import HardwareInfo
 from Tools.Directories import fileExists
-from downloader import NFIDownload, filescan
-from flasher import NFIFlash
+from .downloader import NFIDownload, filescan
+from .flasher import NFIFlash
 
 def NFIFlasherMain(session, tmp = None, **kwargs):
 	session.open(NFIDownload, "/home/root" )
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/NetworkWizard/NetworkWizard.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/NetworkWizard/NetworkWizard.py
@@ -124,7 +124,7 @@
 	def checkOldInterfaceState(self):
 		# disable up interface if it was originally down and config is unchanged.
 		if self.originalInterfaceStateChanged is False:
-			for interface in self.originalInterfaceState.keys():
+			for interface in list(self.originalInterfaceState.keys()):
 				if interface == self.selectedInterface:
 					if self.originalInterfaceState[interface]["up"] is False:
 						if iNetwork.checkforInterface(interface) is True:
@@ -196,7 +196,7 @@
 				self.isInterfaceUp = False
 			self.resetRef.close(True)
 		else:
-			print "we should never come here!"
+			print("we should never come here!")
 
 	def AdapterSetupEnd(self, iface):
 		self.originalInterfaceStateChanged = True
@@ -290,7 +290,7 @@
 			self.newAPlist.append(newentry)
 
 		if len(self.newAPlist):
-			if (self.wizard[self.currStep].has_key("dynamiclist")):
+			if ("dynamiclist" in self.wizard[self.currStep]):
 				currentListEntry = self["list"].getCurrent()
 				if currentListEntry is not None:
 					idx = 0
@@ -314,7 +314,7 @@
 			self.w = iWlan.getInterface()
 			aps = iWlan.getNetworkList()
 			if aps is not None:
-				print "[NetworkWizard.py] got Accespoints!"
+				print("[NetworkWizard.py] got Accespoints!")
 				tmplist = []
 				complist = []
 				for ap in aps:
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/NetworkWizard/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/NetworkWizard/plugin.py
@@ -14,7 +14,7 @@
 	return [(_("Network wizard"), NetworkWizardMain, "nw_wizard", 40)]
 
 def NetworkWizard(*args, **kwargs):
-	from NetworkWizard import NetworkWizard
+	from .NetworkWizard import NetworkWizard
 	return NetworkWizard(*args, **kwargs)
 
 def Plugins(**kwargs):
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/PositionerSetup/log.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/PositionerSetup/log.py
@@ -6,7 +6,7 @@
 # because the log unit looks enough like a file!
 
 import sys
-from cStringIO import StringIO
+from io import StringIO
 import threading
 
 logfile = None
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/PositionerSetup/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/PositionerSetup/plugin.py
@@ -26,8 +26,8 @@
 from threading import Thread as Thread
 from threading import Event as Event
 
-import log
-import rotor_calc
+from . import log
+from . import rotor_calc
 
 class PositionerSetup(Screen):
 	skin = """
@@ -255,11 +255,11 @@
 				if self.frontend:
 					return True
 				else:
-					print "getFrontend failed"
-			else:
-				print "getRawChannel failed"
-		else:
-			print "getResourceManager instance failed"
+					print("getFrontend failed")
+			else:
+				print("getRawChannel failed")
+		else:
+			print("getResourceManager instance failed")
 		return False
 
 	def setLNB(self, lnb):
@@ -410,8 +410,8 @@
 			self.blue.setText("")
 
 	def printMsg(self, msg):
-		print msg
-		print>>log, msg
+		print(msg)
+		print(msg, file=log)
 
 	def stopMoving(self):
 		self.printMsg(_("Stop"))
@@ -449,8 +449,8 @@
 		if entry == "tune":
 			# Auto focus
 			self.printMsg(_("Auto focus"))
-			print>>log, (_("Site latitude") + "      : %5.1f %s") % PositionerSetup.latitude2orbital(self.sitelat)
-			print>>log, (_("Site longitude") + "     : %5.1f %s") % PositionerSetup.longitude2orbital(self.sitelon)
+			print((_("Site latitude") + "      : %5.1f %s") % PositionerSetup.latitude2orbital(self.sitelat), file=log)
+			print((_("Site longitude") + "     : %5.1f %s") % PositionerSetup.longitude2orbital(self.sitelon), file=log)
 			Thread(target = self.autofocus).start()
 		elif entry == "move":
 			if self.isMoving:
@@ -509,15 +509,15 @@
 			self.printMsg(_("Move to position X"))
 			satlon = self.orbitalposition.float
 			position = ("%5.1f %s") % (satlon, self.orientation.value)
-			print>>log, (_("Satellite longitude:") + " %s") % position
+			print((_("Satellite longitude:") + " %s") % position, file=log)
 			satlon = PositionerSetup.orbital2metric(satlon, self.orientation.value)
 			self.statusMsg((_("Moving to position") + " %s") % position, timeout = self.STATUS_MSG_TIMEOUT)
 			self.gotoX(satlon)
 		elif entry == "tune":
 			# Start USALS calibration
 			self.printMsg(_("USALS calibration"))
-			print>>log, (_("Site latitude") + "      : %5.1f %s") % PositionerSetup.latitude2orbital(self.sitelat)
-			print>>log, (_("Site longitude") + "     : %5.1f %s") % PositionerSetup.longitude2orbital(self.sitelon)
+			print((_("Site latitude") + "      : %5.1f %s") % PositionerSetup.latitude2orbital(self.sitelat), file=log)
+			print((_("Site longitude") + "     : %5.1f %s") % PositionerSetup.longitude2orbital(self.sitelon), file=log)
 			Thread(target = self.gotoXcalibration).start()
 
 	def blueKey(self):
@@ -558,8 +558,8 @@
 	def recalcConfirmed(self, yesno):
 		if yesno:
 			self.printMsg(_("Calculate all positions"))
-			print>>log, (_("Site latitude") + "      : %5.1f %s") % PositionerSetup.latitude2orbital(self.sitelat)
-			print>>log, (_("Site longitude") + "     : %5.1f %s") % PositionerSetup.longitude2orbital(self.sitelon)
+			print((_("Site latitude") + "      : %5.1f %s") % PositionerSetup.latitude2orbital(self.sitelat), file=log)
+			print((_("Site longitude") + "     : %5.1f %s") % PositionerSetup.longitude2orbital(self.sitelon), file=log)
 			lon = self.sitelon
 			if lon >= 180:
 				lon -= 360
@@ -575,7 +575,7 @@
 		self.session.open(PositionerSetupLog)
 
 	def diseqccommand(self, cmd, param = 0):
-		print>>log, "Diseqc(%s, %X)" % (cmd, param)
+		print("Diseqc(%s, %X)" % (cmd, param), file=log)
 		self.diseqc.command(cmd, param)
 		self.tuner.retune()
 
@@ -696,7 +696,7 @@
 		rotorCmd = PositionerSetup.gotoXcalc(satlon, self.sitelat, self.sitelon)
 		self.diseqccommand("gotoX", rotorCmd)
 		x = PositionerSetup.rotorCmd2Step(rotorCmd, self.tuningstepsize)
-		print>>log, (_("Rotor step position:") + " %4d") % x
+		print((_("Rotor step position:") + " %4d") % x, file=log)
 		return x
 
 	def getTurningspeed(self):
@@ -751,12 +751,12 @@
 			return z
 
 		def reportlevels(pos, level, lock):
-			print>>log, (_("Signal quality") + " %5.1f" + chr(176) + "   : %6.2f") % (pos, level)
-			print>>log, (_("Lock ratio") + "     %5.1f" + chr(176) + "   : %6.2f") % (pos, lock)
+			print((_("Signal quality") + " %5.1f" + chr(176) + "   : %6.2f") % (pos, level), file=log)
+			print((_("Lock ratio") + "     %5.1f" + chr(176) + "   : %6.2f") % (pos, lock), file=log)
 
 		def optimise(readings):
-			xi = readings.keys()
-			yi = map(lambda (x, y) : x, readings.values())
+			xi = list(readings.keys())
+			yi = [x_y[0] for x_y in list(readings.values())]
 			x0 = sum(map(mul, xi, yi)) / sum(yi)
 			xm = xi[yi.index(max(yi))]
 			return (x0, xm)
@@ -775,7 +775,7 @@
 
 		self.logMsg(_("GotoX calibration"))
 		satlon = self.orbitalposition.float
-		print>>log, (_("Satellite longitude:") + " %5.1f" + chr(176) + " %s") % (satlon, self.orientation.value)
+		print((_("Satellite longitude:") + " %5.1f" + chr(176) + " %s") % (satlon, self.orientation.value), file=log)
 		satlon = PositionerSetup.orbital2metric(satlon, self.orientation.value)
 		prev_pos = 0.0						# previous relative position w.r.t. satlon
 		turningspeed = self.getTurningspeed()
@@ -812,8 +812,8 @@
 		prev_pos = x
 		measurements = {}
 		self.measure()
-		print>>log, (_("Initial signal quality") + " %5.1f" + chr(176) + ": %6.2f") % (x, self.snr_percentage)
-		print>>log, (_("Initial lock ratio") + "     %5.1f" + chr(176) + ": %6.2f") % (x, self.lock_count)
+		print((_("Initial signal quality") + " %5.1f" + chr(176) + ": %6.2f") % (x, self.snr_percentage), file=log)
+		print((_("Initial lock ratio") + "     %5.1f" + chr(176) + ": %6.2f") % (x, self.lock_count), file=log)
 		measurements[x] = (self.snr_percentage, self.lock_count)
 
 		start_pos = x
@@ -870,8 +870,8 @@
 			satlon -= 360
 		x0 += satlon
 		xm += satlon
-		print>>log, (_("Weighted position") + "     : %5.1f" + chr(176) + " %s") % (abs(x0), toGeopos(x0))
-		print>>log, (_("Strongest position") + "    : %5.1f" + chr(176) + " %s") % (abs(xm), toGeopos(xm))
+		print((_("Weighted position") + "     : %5.1f" + chr(176) + " %s") % (abs(x0), toGeopos(x0)), file=log)
+		print((_("Strongest position") + "    : %5.1f" + chr(176) + " %s") % (abs(xm), toGeopos(xm)), file=log)
 		self.logMsg((_("Final position at") + " %5.1f" + chr(176) + " %s / %d; " + _("offset is") + " %4.1f" + chr(176)) % (abs(x0), toGeopos(x0), x, x0 - satlon), timeout = 10)
 
 	def autofocus(self):
@@ -886,12 +886,12 @@
 				sleep(time * self.MAX_LOW_RATE_ADAPTER_COUNT)
 
 		def reportlevels(pos, level, lock):
-			print>>log, (_("Signal quality") + " [%2d]   : %6.2f") % (pos, level)
-			print>>log, (_("Lock ratio") + " [%2d]       : %6.2f") % (pos, lock)
+			print((_("Signal quality") + " [%2d]   : %6.2f") % (pos, level), file=log)
+			print((_("Lock ratio") + " [%2d]       : %6.2f") % (pos, lock), file=log)
 
 		def optimise(readings):
-			xi = readings.keys()
-			yi = map(lambda (x, y) : x, readings.values())
+			xi = list(readings.keys())
+			yi = [x_y1[0] for x_y1 in list(readings.values())]
 			x0 = int(round(sum(map(mul, xi, yi)) / sum(yi)))
 			xm = xi[yi.index(max(yi))]
 			return (x0, xm)
@@ -907,15 +907,15 @@
 		measurements = {}
 		maxsteps = max(min(round(self.MAX_FOCUS_ANGLE / self.tuningstepsize), 0x1F), 3)
 		self.measure()
-		print>>log, (_("Initial signal quality:") + " %6.2f") % self.snr_percentage
-		print>>log, (_("Initial lock ratio") + "    : %6.2f") % self.lock_count
+		print((_("Initial signal quality:") + " %6.2f") % self.snr_percentage, file=log)
+		print((_("Initial lock ratio") + "    : %6.2f") % self.lock_count, file=log)
 		if self.lock_count < 1 - self.LOCK_LIMIT:
 			msg = _("There is no signal to lock on !")
 			self.printMsg(msg)
 			self.statusMsg("")
 			self.session.open(MessageBox, msg, MessageBox.TYPE_ERROR, timeout = 5)
 			return
-		print>>log, _("Signal OK, proceeding")
+		print(_("Signal OK, proceeding"), file=log)
 		x = 0
 		dir = 1
 		if self.randomBool():
@@ -966,8 +966,8 @@
 			self.session.open(MessageBox, msg, MessageBox.TYPE_ERROR, timeout = 5)
 			return
 		(x0, xm) = optimise(measurements)
-		print>>log, (_("Weighted position") + "     : %2d") % x0
-		print>>log, (_("Strongest position") + "    : %2d") % xm
+		print((_("Weighted position") + "     : %2d") % x0, file=log)
+		print((_("Strongest position") + "    : %2d") % xm, file=log)
 		self.logMsg((_("Final position at index") + " %2d (%5.1f" + chr(176) + ")") % (x0, x0 * self.tuningstepsize), timeout = 6)
 		move(x0 - x)
 
@@ -1001,8 +1001,8 @@
 			else:
 				string = 'E03160' #positioner stop
 
-			print "diseqc command:",
-			print string
+			print("diseqc command:", end=' ')
+			print(string)
 			cmd.setCommandString(string)
 			self.frontend.setTone(iDVBFrontend.toneOff)
 			sleep(0.015) # wait 15msec after disable tone
@@ -1060,7 +1060,7 @@
 			f = open('/tmp/positionersetup.log', 'w')
 			f.write(log.getvalue())
 			f.close()
-		except Exception, e:
+		except Exception as e:
 			self["list"].setText(_("Failed to write /tmp/positionersetup.log: ") + str(e))
 		self.close(True)
 
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Satfinder/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Satfinder/plugin.py
@@ -24,11 +24,11 @@
 				if self.frontend:
 					return True
 				else:
-					print "getFrontend failed"
-			else:
-				print "getRawChannel failed"
-		else:
-			print "getResourceManager instance failed"
+					print("getFrontend failed")
+			else:
+				print("getRawChannel failed")
+		else:
+			print("getResourceManager instance failed")
 		return False
 
 	def __init__(self, session, feid):
@@ -145,7 +145,7 @@
 		self.tuning_transponder = None
 		self.tuning_type = ConfigSelection(choices = [("manual_transponder", _("Manual transponder")), ("predefined_transponder", _("Predefined transponder"))])
 		orbital_position = 192
-		if self.frontendData and self.frontendData.has_key('orbital_position'):
+		if self.frontendData and 'orbital_position' in self.frontendData:
 			orbital_position = self.frontendData['orbital_position']
 		self.tuning_sat = getConfigSatlist(orbital_position, nimmanager.getSatListForNim(self.feid))
 		ScanSetup.createConfig(self, self.frontendData)
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py
@@ -84,7 +84,7 @@
 	def find(self, arg, dirname, names):
 		for x in names:
 			if x == "skin.xml":
-				if dirname <> self.root:
+				if dirname != self.root:
 					subdir = dirname[len(resolveFilename(SCOPE_SKIN)):]
 					self.skinlist.append(subdir)
 				else:
@@ -97,7 +97,7 @@
 		else:
 			skinfile = self["SkinList"].getCurrent()+"/skin.xml"
 
-		print "Skinselector: Selected Skin: "+self.root+skinfile
+		print("Skinselector: Selected Skin: "+self.root+skinfile)
 		config.skin.primary_skin.value = skinfile
 		config.skin.primary_skin.save()
 		restartbox = self.session.openWithCallback(self.restartGUI,MessageBox,_("GUI needs a restart to apply a new skin\nDo you want to restart the GUI now?"), MessageBox.TYPE_YESNO)
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py
@@ -273,7 +273,7 @@
 	def startDelete(self, ret = False):
 		if (ret == True):
 			self.exe = True
-			print "removing:",self.val
+			print("removing:",self.val)
 			if (path.exists(self.val) == True):
 				remove(self.val)
 			self.exe = False
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/SoftwareManager/SoftwareTools.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/SoftwareManager/SoftwareTools.py
@@ -199,7 +199,7 @@
 					self.packagesIndexlist.remove(package)
 			for package in self.packagesIndexlist[:]:
 				attributes = package[0]["attributes"]
-				if attributes.has_key("packagetype"):
+				if "packagetype" in attributes:
 					if attributes["packagetype"] == "internal":
 						self.packagesIndexlist.remove(package)
 			if callback is None:
@@ -223,7 +223,7 @@
 			packagename = attributes["packagename"]
 			for x in self.available_packetlist:
 				if x[0] == packagename:
-					if self.installed_packetlist.has_key(packagename):
+					if packagename in self.installed_packetlist:
 						if self.installed_packetlist[packagename] != x[1]:
 							self.available_updates +=1
 							self.available_updatelist.append([packagename])
@@ -260,15 +260,15 @@
 		self.ipkg.stop()
 		if self.Console is not None:
 			if len(self.Console.appContainers):
-				for name in self.Console.appContainers.keys():
+				for name in list(self.Console.appContainers.keys()):
 					self.Console.kill(name)
 		if self.UpdateConsole is not None:
 			if len(self.UpdateConsole.appContainers):
-				for name in self.UpdateConsole.appContainers.keys():
+				for name in list(self.UpdateConsole.appContainers.keys()):
 					self.UpdateConsole.kill(name)
 
 	def verifyPrerequisites(self, prerequisites):
-		if prerequisites.has_key("hardware"):
+		if "hardware" in prerequisites:
 			hardware_found = False
 			for hardware in prerequisites["hardware"]:
 				if hardware == self.hardware_info.device_name:
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/SoftwareManager/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/SoftwareManager/plugin.py
@@ -31,7 +31,7 @@
 from Tools.LoadPixmap import LoadPixmap
 from Tools.NumericalTextInput import NumericalTextInput
 from enigma import eTimer, RT_HALIGN_LEFT, RT_VALIGN_CENTER, eListboxPythonMultiContent, eListbox, gFont, getDesktop, ePicLoad, eRCInput, getPrevAsciiCode, eEnv, iRecordableService
-from cPickle import dump, load
+from pickle import dump, load
 from os import path as os_path, system as os_system, unlink, stat, mkdir, popen, makedirs, listdir, access, rename, remove, W_OK, R_OK, F_OK
 from time import time, gmtime, strftime, localtime
 from stat import ST_MTIME
@@ -39,9 +39,9 @@
 from twisted.web import client
 from twisted.internet import reactor
 
-from ImageWizard import ImageWizard
-from BackupRestore import BackupSelection, RestoreMenu, BackupScreen, RestoreScreen, getBackupPath, getBackupFilename
-from SoftwareTools import iSoftwareTools
+from .ImageWizard import ImageWizard
+from .BackupRestore import BackupSelection, RestoreMenu, BackupScreen, RestoreScreen, getBackupPath, getBackupFilename
+from .SoftwareTools import iSoftwareTools
 
 config.plugins.configurationbackup = ConfigSubsection()
 config.plugins.configurationbackup.backuplocation = ConfigText(default = '/media/hdd/', visible_width = 50, fixed_size = False)
@@ -63,7 +63,7 @@
 		try:
 			mkdir( os_path.dirname(cache_file) )
 		except OSError:
-			    print os_path.dirname(cache_file), 'is a file'
+			    print(os_path.dirname(cache_file), 'is a file')
 	fd = open(cache_file, 'w')
 	dump(cache_data, fd, -1)
 	fd.close()
@@ -128,7 +128,7 @@
 		self.text = ""
 		self.backupdirs = ' '.join( config.plugins.configurationbackup.backupdirs.value )
 		if self.menu == 0:
-			print "building menu entries"
+			print("building menu entries")
 			self.list.append(("install-extensions", _("Manage extensions"), _("\nManage extensions or plugins for your receiver" ) + self.oktext, None))
 			self.list.append(("software-update", _("Software update"), _("\nOnline update of your receiver software." ) + self.oktext, None))
 			self.list.append(("software-restore", _("Software restore"), _("\nRestore your receiver with a new firmware." ) + self.oktext, None))
@@ -136,14 +136,14 @@
 			self.list.append(("system-restore",_("Restore system settings"), _("\nRestore your receiver settings." ) + self.oktext, None))
 			self.list.append(("ipkg-install", _("Install local extension"),  _("\nScan for local extensions and install them." ) + self.oktext, None))
 			for p in plugins.getPlugins(PluginDescriptor.WHERE_SOFTWAREMANAGER):
-				if p.__call__.has_key("SoftwareSupported"):
+				if "SoftwareSupported" in p.__call__:
 					callFnc = p.__call__["SoftwareSupported"](None)
 					if callFnc is not None:
-						if p.__call__.has_key("menuEntryName"):
+						if "menuEntryName" in p.__call__:
 							menuEntryName = p.__call__["menuEntryName"](None)
 						else:
 							menuEntryName = _('Extended Software')
-						if p.__call__.has_key("menuEntryDescription"):
+						if "menuEntryDescription" in p.__call__:
 							menuEntryDescription = p.__call__["menuEntryDescription"](None)
 						else:
 							menuEntryDescription = _('Extended Software Plugin')
@@ -158,14 +158,14 @@
 				self.list.append(("ipkg-manager", _("Packet management"),  _("\nView, install and remove available or installed packages." ) + self.oktext, None))
 			self.list.append(("ipkg-source",_("Select upgrade source"), _("\nEdit the upgrade source address." ) + self.oktext, None))
 			for p in plugins.getPlugins(PluginDescriptor.WHERE_SOFTWAREMANAGER):
-				if p.__call__.has_key("AdvancedSoftwareSupported"):
+				if "AdvancedSoftwareSupported" in p.__call__:
 					callFnc = p.__call__["AdvancedSoftwareSupported"](None)
 					if callFnc is not None:
-						if p.__call__.has_key("menuEntryName"):
+						if "menuEntryName" in p.__call__:
 							menuEntryName = p.__call__["menuEntryName"](None)
 						else:
 							menuEntryName = _('Advanced software')
-						if p.__call__.has_key("menuEntryDescription"):
+						if "menuEntryDescription" in p.__call__:
 							menuEntryDescription = p.__call__["menuEntryDescription"](None)
 						else:
 							menuEntryDescription = _('Advanced software plugin')
@@ -319,7 +319,7 @@
 			self.createBackupfolders()
 
 	def createBackupfolders(self):
-		print "Creating backup folder if not already there..."
+		print("Creating backup folder if not already there...")
 		self.backuppath = getBackupPath()
 		try:
 			if (os_path.exists(self.backuppath) == False):
@@ -419,7 +419,7 @@
 
 	def confirm(self, confirmed):
 		if not confirmed:
-			print "not confirmed"
+			print("not confirmed")
 			return
 		else:
 			self.keySave()
@@ -823,11 +823,11 @@
 			self.packetlist = []
 			for package in iSoftwareTools.packagesIndexlist[:]:
 				prerequisites = package[0]["prerequisites"]
-				if prerequisites.has_key("tag"):
+				if "tag" in prerequisites:
 					for foundtag in prerequisites["tag"]:
 						if categorytag == foundtag:
 							attributes = package[0]["attributes"]
-							if attributes.has_key("packagetype"):
+							if "packagetype" in attributes:
 								if attributes["packagetype"] == "internal":
 									continue
 								self.packetlist.append([attributes["name"], attributes["details"], attributes["shortdescription"], attributes["packagename"]])
@@ -843,7 +843,7 @@
 					description = "No description available."
 				packagename = x[3].strip()
 				selectState = self.getSelectionState(details)
-				if iSoftwareTools.installed_packetlist.has_key(packagename):
+				if packagename in iSoftwareTools.installed_packetlist:
 					if selectState == True:
 						status = "remove"
 					else:
@@ -868,7 +868,7 @@
 		self.categoryList = []
 		for package in iSoftwareTools.packagesIndexlist[:]:
 			prerequisites = package[0]["prerequisites"]
-			if prerequisites.has_key("tag"):
+			if "tag" in prerequisites:
 				for foundtag in prerequisites["tag"]:
 					attributes = package[0]["attributes"]
 					if foundtag not in self.categories:
@@ -920,11 +920,11 @@
 				if (os_path.exists(detailsfile) == True):
 					iSoftwareTools.fillPackageDetails(plugin[0])
 					self.package = iSoftwareTools.packageDetails[0]
-					if self.package[0].has_key("attributes"):
+					if "attributes" in self.package[0]:
 						self.attributes = self.package[0]["attributes"]
-						if self.attributes.has_key("needsRestart"):
+						if "needsRestart" in self.attributes:
 							self.restartRequired = True
-					if self.attributes.has_key("package"):
+					if "package" in self.attributes:
 						self.packagefiles = self.attributes["package"]
 					if plugin[1] == 'installed':
 						if self.packagefiles:
@@ -1205,7 +1205,7 @@
 		self["divpic"].hide()
 
 		self.package = self.packageDetails[0]
-		if self.package[0].has_key("attributes"):
+		if "attributes" in self.package[0]:
 			self.attributes = self.package[0]["attributes"]
 		self.restartRequired = False
 		self.cmdList = []
@@ -1231,20 +1231,20 @@
 		pass
 
 	def setInfos(self):
-		if self.attributes.has_key("screenshot"):
+		if "screenshot" in self.attributes:
 			self.loadThumbnail(self.attributes)
 
-		if self.attributes.has_key("name"):
+		if "name" in self.attributes:
 			self.pluginname = self.attributes["name"]
 		else:
 			self.pluginname = _("unknown")
 
-		if self.attributes.has_key("author"):
+		if "author" in self.attributes:
 			self.author = self.attributes["author"]
 		else:
 			self.author = _("unknown")
 
-		if self.attributes.has_key("description"):
+		if "description" in self.attributes:
 			self.description = _(self.attributes["description"].replace("\\n", "\n"))
 		else:
 			self.description = _("No description available.")
@@ -1261,7 +1261,7 @@
 
 	def loadThumbnail(self, entry):
 		thumbnailUrl = None
-		if entry.has_key("screenshot"):
+		if "screenshot" in entry:
 			thumbnailUrl = entry["screenshot"]
 			if self.language == "de":
 				if thumbnailUrl[-7:] == "_en.jpg":
@@ -1269,7 +1269,7 @@
 
 		if thumbnailUrl is not None:
 			self.thumbnail = "/tmp/" + thumbnailUrl.split('/')[-1]
-			print "[PluginDetails] downloading screenshot " + thumbnailUrl + " to " + self.thumbnail
+			print("[PluginDetails] downloading screenshot " + thumbnailUrl + " to " + self.thumbnail)
 			if iSoftwareTools.NetworkConnectionAvailable:
 				client.downloadPage(thumbnailUrl,self.thumbnail).addCallback(self.setThumbnail).addErrback(self.fetchFailed)
 			else:
@@ -1303,9 +1303,9 @@
 			self.setThumbnail(noScreenshot = True)
 
 	def go(self):
-		if self.attributes.has_key("package"):
+		if "package" in self.attributes:
 			self.packagefiles = self.attributes["package"]
-		if self.attributes.has_key("needsRestart"):
+		if "needsRestart" in self.attributes:
 			self.restartRequired = True
 		self.cmdList = []
 		if self.pluginstate in ('installed', 'remove'):
@@ -1349,7 +1349,7 @@
 
 	def fetchFailed(self,string):
 		self.setThumbnail(noScreenshot = True)
-		print "[PluginDetails] fetch failed " + string.getErrorMessage()
+		print("[PluginDetails] fetch failed " + string.getErrorMessage())
 
 class IPKGMenu(Screen):
 	skin = """
@@ -1551,7 +1551,7 @@
 		self.session = session
 		self.skin_path = plugin_path
 
-		self.setUseableChars(u'1234567890abcdefghijklmnopqrstuvwxyz')
+		self.setUseableChars('1234567890abcdefghijklmnopqrstuvwxyz')
 
 		self["shortcuts"] = NumberActionMap(["ShortcutActions", "WizardActions", "NumberActions", "InputActions", "InputAsciiActions", "KeyboardInputActions" ],
 		{
@@ -1606,7 +1606,7 @@
 				self.setNextIdx(keyvalue[0])
 
 	def keyGotAscii(self):
-		keyvalue = unichr(getPrevAsciiCode()).encode("utf-8")
+		keyvalue = chr(getPrevAsciiCode()).encode("utf-8")
 		if len(keyvalue) == 1:
 			self.setNextIdx(keyvalue[0])
 
@@ -1627,7 +1627,7 @@
 		self.ipkg.stop()
 		if self.Console is not None:
 			if len(self.Console.appContainers):
-				for name in self.Console.appContainers.keys():
+				for name in list(self.Console.appContainers.keys()):
 					self.Console.kill(name)
 		rcinput = eRCInput.getInstance()
 		rcinput.setKeyboardMode(rcinput.kmNone)
@@ -1810,7 +1810,7 @@
 		self.list = []
 		self.cachelist = []
 		if self.cache_ttl > 0 and self.vc != 0:
-			print 'Loading packagelist cache from ',self.cache_file
+			print('Loading packagelist cache from ',self.cache_file)
 			try:
 				self.cachelist = load_cache(self.cache_file)
 				if len(self.cachelist) > 0:
@@ -1821,11 +1821,11 @@
 				self.inv_cache = 1
 
 		if self.cache_ttl == 0 or self.inv_cache == 1 or self.vc == 0:
-			print 'rebuilding fresh package list'
+			print('rebuilding fresh package list')
 			for x in self.packetlist:
 				status = ""
-				if self.installed_packetlist.has_key(x[0]):
-					if self.upgradeable_packages.has_key(x[0]):
+				if x[0] in self.installed_packetlist:
+					if x[0] in self.upgradeable_packages:
 						status = "upgradeable"
 					else:
 						status = "installed"
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
@@ -78,7 +78,7 @@
 							servicename = "PLAY"
 					else:
 						servicename = ServiceReference(service).getServiceName()
-			print "[VFD Display] text ", servicename[0:20]
+			print("[VFD Display] text ", servicename[0:20])
 			evfd.getInstance().vfd_write_string(servicename[0:20])
 
 	def timerEvent(self):
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VideoEnhancement/VideoEnhancement.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VideoEnhancement/VideoEnhancement.py
@@ -18,10 +18,10 @@
 			def setContrast(config):
 				myval = int(config.value*256)
 				try:
-					print "--> setting contrast to: %0.8X" % myval
+					print("--> setting contrast to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_contrast", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_contrast."
+					print("couldn't write pep_contrast.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -35,10 +35,10 @@
 			def setSaturation(config):
 				myval = int(config.value*256)
 				try:
-					print "--> setting saturation to: %0.8X" % myval
+					print("--> setting saturation to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_saturation", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_saturaion."
+					print("couldn't write pep_saturaion.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -52,10 +52,10 @@
 			def setHue(config):
 				myval = int(config.value*256)
 				try:
-					print "--> setting hue to: %0.8X" % myval
+					print("--> setting hue to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_hue", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_hue."
+					print("couldn't write pep_hue.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -69,10 +69,10 @@
 			def setBrightness(config):
 				myval = int(config.value*256)
 				try:
-					print "--> setting brightness to: %0.8X" % myval
+					print("--> setting brightness to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_brightness", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_brightness."
+					print("couldn't write pep_brightness.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -86,10 +86,10 @@
 			def setBlock_noise_reduction(config):
 				myval = int(config.value)
 				try:
-					print "--> setting block_noise_reduction to: %0.8X" % myval
+					print("--> setting block_noise_reduction to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_block_noise_reduction", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_block_noise_reduction."
+					print("couldn't write pep_block_noise_reduction.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -103,10 +103,10 @@
 			def setMosquito_noise_reduction(config):
 				myval = int(config.value)
 				try:
-					print "--> setting mosquito_noise_reduction to: %0.8X" % myval
+					print("--> setting mosquito_noise_reduction to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_mosquito_noise_reduction", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_mosquito_noise_reduction."
+					print("couldn't write pep_mosquito_noise_reduction.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -120,10 +120,10 @@
 			def setDigital_contour_removal(config):
 				myval = int(config.value)
 				try:
-					print "--> setting digital_contour_removal to: %0.8X" % myval
+					print("--> setting digital_contour_removal to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_digital_contour_removal", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_digital_contour_removal."
+					print("couldn't write pep_digital_contour_removal.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -136,10 +136,10 @@
 		if os_path.exists("/proc/stb/vmpeg/0/pep_split"):
 			def setSplitMode(config):
 				try:
-					print "--> setting splitmode to:",str(config.value)
+					print("--> setting splitmode to:",str(config.value))
 					open("/proc/stb/vmpeg/0/pep_split", "w").write(str(config.value))
 				except IOError:
-					print "couldn't write pep_split."
+					print("couldn't write pep_split.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -157,10 +157,10 @@
 			def setSharpness(config):
 				myval = int(config.value*256)
 				try:
-					print "--> setting sharpness to: %0.8X" % myval
+					print("--> setting sharpness to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_sharpness", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_sharpness."
+					print("couldn't write pep_sharpness.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -174,10 +174,10 @@
 			def setAutoflesh(config):
 				myval = int(config.value)
 				try:
-					print "--> setting auto_flesh to: %0.8X" % myval
+					print("--> setting auto_flesh to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_auto_flesh", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_auto_flesh."
+					print("couldn't write pep_auto_flesh.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -191,10 +191,10 @@
 			def setGreenboost(config):
 				myval = int(config.value)
 				try:
-					print "--> setting green_boost to: %0.8X" % myval
+					print("--> setting green_boost to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_green_boost", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_green_boost."
+					print("couldn't write pep_green_boost.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -208,10 +208,10 @@
 			def setBlueboost(config):
 				myval = int(config.value)
 				try:
-					print "--> setting blue_boost to: %0.8X" % myval
+					print("--> setting blue_boost to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_blue_boost", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_blue_boost."
+					print("couldn't write pep_blue_boost.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -225,10 +225,10 @@
 			def setDynamic_contrast(config):
 				myval = int(config.value)
 				try:
-					print "--> setting dynamic_contrast to: %0.8X" % myval
+					print("--> setting dynamic_contrast to: %0.8X" % myval)
 					open("/proc/stb/vmpeg/0/pep_dynamic_contrast", "w").write("%0.8X" % myval)
 				except IOError:
-					print "couldn't write pep_dynamic_contrast."
+					print("couldn't write pep_dynamic_contrast.")
 
 				if not VideoEnhancement.firstRun:
 					self.setConfiguredValues()
@@ -245,10 +245,10 @@
 				def setScaler_sharpness(config):
 					myval = int(config.value)
 					try:
-						print "--> setting scaler_sharpness to: %0.8X" % myval
+						print("--> setting scaler_sharpness to: %0.8X" % myval)
 						open("/proc/stb/vmpeg/0/pep_scaler_sharpness", "w").write("%0.8X" % myval)
 					except IOError:
-						print "couldn't write pep_scaler_sharpness."
+						print("couldn't write pep_scaler_sharpness.")
 
 					if not VideoEnhancement.firstRun:
 						self.setConfiguredValues()
@@ -265,9 +265,9 @@
 
 	def setConfiguredValues(self):
 		try:
-			print "--> applying pep values"
+			print("--> applying pep values")
 			open("/proc/stb/vmpeg/0/pep_apply", "w").write("1")
 		except IOError:
-			print "couldn't apply pep values."
+			print("couldn't apply pep values.")
 
 VideoEnhancement()
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VideoEnhancement/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VideoEnhancement/plugin.py
@@ -5,7 +5,7 @@
 from Components.Sources.StaticText import StaticText
 from Screens.Screen import Screen
 from Screens.MessageBox import MessageBox
-import VideoEnhancement
+from . import VideoEnhancement
 from os import path as os_path
 
 class VideoEnhancementSetup(Screen, ConfigListScreen):
@@ -155,7 +155,7 @@
 
 	def confirm(self, confirmed):
 		if not confirmed:
-			print "not confirmed"
+			print("not confirmed")
 		else:
 			if self.splitEntry is not None:
 				config.pep.split.setValue('off')
@@ -178,7 +178,7 @@
 
 	def keyYellowConfirm(self, confirmed):
 		if not confirmed:
-			print "not confirmed"
+			print("not confirmed")
 		else:
 			if self.contrastEntry is not None:
 				config.pep.contrast.setValue(self.oldContrast)
@@ -215,7 +215,7 @@
 
 	def keyBlueConfirm(self, confirmed):
 		if not confirmed:
-			print "not confirmed"
+			print("not confirmed")
 		else:
 			if self.contrastEntry is not None:
 				config.pep.contrast.setValue(128)
@@ -336,7 +336,7 @@
 			else:
 				self.isStepSlider = False
 		except AttributeError:
-			print "no max value"
+			print("no max value")
 
 	def keyLeft(self):
 		if self.isStepSlider is True:
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py
@@ -33,8 +33,8 @@
 		self.testpic_brightness()
 
 	def callNext(self):
-		if self.next:
-			self.next()
+		if self.__next__:
+			next(self)
 
 	def bbox(self, x, y, width, height, col, xx, yy):
 		c = self["Canvas"]
@@ -227,13 +227,13 @@
 
 		c.fill(offset - border, yb - border, border * 2 + width, border * 2 + (height * 3 + o * 2), RGB(g1, g1, g1))
 
-		for x in xrange(0, width, 2):
+		for x in range(0, width, 2):
 			c.fill(offset + x, yb, 1, height, RGB(g2,g2,g2))
 
-		for x in xrange(0, width, 4):
+		for x in range(0, width, 4):
 			c.fill(offset + x, yb + (o + height), 2, height, RGB(g2,g2,g2))
 
-		for x in xrange(0, width, 8):
+		for x in range(0, width, 8):
 			c.fill(offset + x, yb + (o + height) * 2, 4, height, RGB(g2,g2,g2))
 
 		c.flush()
@@ -253,13 +253,13 @@
 		height = yres - yres/5
 		offset_y = yres/10
 
-		for y in xrange(0, height, 4):
+		for y in range(0, height, 4):
 			c.fill(offset_x, offset_y + y, width/2, 2, RGB(255,255,255))
 
 		l = 0
 		fnt = gFont("Regular", height / 14)
 		import math
-		for i in xrange(1, 15):
+		for i in range(1, 15):
 			y = i * height / 14
 			h = y - l
 			gamma = 0.6 + i * 0.2
@@ -283,10 +283,10 @@
 
 		c.fill(0, 0, xres, yres, RGB(128, 128, 128))
 
-		for x in xrange(6, xres, 44):
+		for x in range(6, xres, 44):
 			c.fill(x, 0, 3, yres, RGB(255,255,255))
 
-		for y in xrange(34, yres, 44):
+		for y in range(34, yres, 44):
 			c.fill(0, y, xres, 3, RGB(255,255,255))
 
 		for i in range(8):
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VideoTune/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VideoTune/plugin.py
@@ -1,7 +1,7 @@
 from Plugins.Plugin import PluginDescriptor
 
 def videoFinetuneMain(session, **kwargs):
-	from VideoFinetune import VideoFinetune
+	from .VideoFinetune import VideoFinetune
 	session.open(VideoFinetune)
 
 def startSetup(menuid):
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
@@ -48,7 +48,7 @@
 		ret = (16,9)
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
-			print "current port not available in getOutputAspect!!! force 16:9"
+			print("current port not available in getOutputAspect!!! force 16:9")
 		else:
 			mode = config.av.videomode[port].value
 			force_widescreen = self.isWidescreenMode(port, mode)
@@ -80,8 +80,8 @@
 
 		self.readAvailableModes()
 
-		if self.modes.has_key("DVI-PC") and not self.getModeList("DVI-PC"):
-			print "remove DVI-PC because of not existing modes"
+		if "DVI-PC" in self.modes and not self.getModeList("DVI-PC"):
+			print("remove DVI-PC because of not existing modes")
 			del self.modes["DVI-PC"]
 
 		self.createConfig()
@@ -125,7 +125,7 @@
 		try:
 			modes = open("/proc/stb/video/videomode_choices").read()[:-1]
 		except IOError:
-			print "couldn't read available videomodes."
+			print("couldn't read available videomodes.")
 			self.modes_available = [ ]
 			return
 		self.modes_available = modes.split(' ')
@@ -135,18 +135,18 @@
 			modes = open("/proc/stb/video/videomode_preferred").read()[:-1]
 			self.modes_preferred = modes.split(' ')
 		except IOError:
-			print "reading preferred modes failed, using all modes"
+			print("reading preferred modes failed, using all modes")
 			self.modes_preferred = self.modes_available
 
 		if self.modes_preferred != self.last_modes_preferred:
 			self.last_modes_preferred = self.modes_preferred
-			print "hotplug on dvi"
+			print("hotplug on dvi")
 			self.on_hotplug("DVI") # must be DVI
 
 	# check if a high-level mode with a given rate is available.
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
-		for mode in rate.values():
+		for mode in list(rate.values()):
 			if port == "HDMI-PC":
 				return True
 			if mode not in self.modes_available:
@@ -157,7 +157,7 @@
 		return mode in self.widescreen_modes
 
 	def setMode(self, port, mode, rate, force = None):
-		print "setMode - port:", port, "mode:", mode, "rate:", rate
+		print("setMode - port:", port, "mode:", mode, "rate:", rate)
 		# we can ignore "port"
 		self.current_mode = mode
 		self.current_port = port
@@ -178,12 +178,12 @@
 				# fallback if no possibility to setup 50/60 hz mode
 				open("/proc/stb/video/videomode", "w").write(mode_50)
 			except IOError:
-				print "setting videomode failed."
+				print("setting videomode failed.")
 
 		try:
 			open("/etc/videomode", "w").write(mode_50) # use 50Hz mode (if available) for booting
 		except IOError:
-			print "writing initial videomode to /etc/videomode failed."
+			print("writing initial videomode to /etc/videomode failed.")
 
 		#call setResolution() with -1,-1 to read the new scrren dimesions without changing the framebuffer resolution
 		from enigma import gMainDC
@@ -193,7 +193,7 @@
 		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
-		print "saveMode", port, mode, rate
+		print("saveMode", port, mode, rate)
 		config.av.videoport.value = port
 		config.av.videoport.save()
 		if port in config.av.videomode:
@@ -220,7 +220,7 @@
 
 	# get a list with all modes, with all rates, for a given port.
 	def getModeList(self, port):
-		print "getModeList for port", port
+		print("getModeList for port", port)
 		res = [ ]
 		for mode in self.modes[port]:
 			# list all rates which are completely valid
@@ -260,13 +260,13 @@
 	def setConfiguredMode(self):
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
-			print "current port not available, not setting videomode"
+			print("current port not available, not setting videomode")
 			return
 
 		mode = config.av.videomode[port].value
 
 		if mode not in config.av.videorate:
-			print "current mode not available, not setting videomode"
+			print("current mode not available, not setting videomode")
 			return
 
 		rate = config.av.videorate[mode].value
@@ -295,7 +295,7 @@
 
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
-			print "current port not available, not setting videomode"
+			print("current port not available, not setting videomode")
 			return
 		mode = config.av.videomode[port].value
 
@@ -334,7 +334,7 @@
 		else:
 			wss = "auto"
 
-		print "-> setting aspect, policy, policy2, wss", aspect, policy, policy2, wss
+		print("-> setting aspect, policy, policy2, wss", aspect, policy, policy2, wss)
 		open("/proc/stb/video/aspect", "w").write(aspect)
 		open("/proc/stb/video/policy", "w").write(policy)
 		open("/proc/stb/denc/0/wss", "w").write(wss)
@@ -358,7 +358,7 @@
 		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
 
 	def updateColor(self, port):
-		print "updateColor: ", port
+		print("updateColor: ", port)
 		if port == "HDMI":
 			self.setHDMIColor(config.av.colorformat_hdmi)
 		elif port == "Component":
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py
@@ -1,7 +1,7 @@
 from Screens.Wizard import WizardSummary
 from Screens.WizardLanguage import WizardLanguage
 from Screens.Rc import Rc
-from VideoHardware import video_hw
+from .VideoHardware import video_hw
 
 from Components.Pixmap import Pixmap, MovingPixmap, MultiPixmap
 from Components.config import config, ConfigBoolean, configfile
@@ -61,7 +61,7 @@
 		
 		
 	def createSummary(self):
-		print "++++++++++++***++**** VideoWizard-createSummary"
+		print("++++++++++++***++**** VideoWizard-createSummary")
 		from Screens.Wizard import WizardSummary
 		return VideoWizardSummary
 		
@@ -84,18 +84,18 @@
 				if port != "DVI-PC":
 					list.append((descr,port))
 		list.sort(key = lambda x: x[0])
-		print "listInputChannels:", list
+		print("listInputChannels:", list)
 		return list
 
 	def inputSelectionMade(self, index):
-		print "inputSelectionMade:", index
+		print("inputSelectionMade:", index)
 		self.port = index
 		self.inputSelect(index)
 		
 	def inputSelectionMoved(self):
 		hw_type = HardwareInfo().get_device_name()
 		has_hdmi = HardwareInfo().has_hdmi()
-		print "input selection moved:", self.selection
+		print("input selection moved:", self.selection)
 		self.inputSelect(self.selection)
 		if self["portpic"].instance is not None:
 			picname = self.selection
@@ -104,9 +104,9 @@
 			self["portpic"].instance.setPixmapFromFile(resolveFilename(SCOPE_PLUGINS, "SystemPlugins/Videomode/" + picname + ".png"))
 		
 	def inputSelect(self, port):
-		print "inputSelect:", port
+		print("inputSelect:", port)
 		modeList = self.hw.getModeList(self.selection)
-		print "modeList:", modeList
+		print("modeList:", modeList)
 		self.port = port
 		if (len(modeList) > 0):
 			ratesList = self.listRates(modeList[0][0])
@@ -114,25 +114,25 @@
 		
 	def listModes(self):
 		list = []
-		print "modes for port", self.port
+		print("modes for port", self.port)
 		for mode in self.hw.getModeList(self.port):
 			#if mode[0] != "PC":
 				list.append((mode[0], mode[0]))
-		print "modeslist:", list
+		print("modeslist:", list)
 		return list
 	
 	def modeSelectionMade(self, index):
-		print "modeSelectionMade:", index
+		print("modeSelectionMade:", index)
 		self.mode = index
 		self.modeSelect(index)
 		
 	def modeSelectionMoved(self):
-		print "mode selection moved:", self.selection
+		print("mode selection moved:", self.selection)
 		self.modeSelect(self.selection)
 		
 	def modeSelect(self, mode):
 		ratesList = self.listRates(mode)
-		print "ratesList:", ratesList
+		print("ratesList:", ratesList)
 		if self.port == "DVI" and mode in ("720p", "1080i", "1080p"):
 			self.rate = "multi"
 			self.hw.setMode(port = self.port, mode = mode, rate = "multi")
@@ -143,13 +143,13 @@
 		if querymode is None:
 			querymode = self.mode
 		list = []
-		print "modes for port", self.port, "and mode", querymode
+		print("modes for port", self.port, "and mode", querymode)
 		for mode in self.hw.getModeList(self.port):
-			print mode
+			print(mode)
 			if mode[0] == querymode:
 				for rate in mode[1]:
 					if self.port == "DVI-PC":
-						print "rate:", rate
+						print("rate:", rate)
 						if rate == "640x480":
 							list.insert(0, (rate, rate))
 							continue
@@ -157,12 +157,12 @@
 		return list
 	
 	def rateSelectionMade(self, index):
-		print "rateSelectionMade:", index
+		print("rateSelectionMade:", index)
 		self.rate = index
 		self.rateSelect(index)
 		
 	def rateSelectionMoved(self):
-		print "rate selection moved:", self.selection
+		print("rate selection moved:", self.selection)
 		self.rateSelect(self.selection)
 
 	def rateSelect(self, rate):
@@ -171,7 +171,7 @@
 	def showTestCard(self, selection = None):
 		if selection is None:
 			selection = self.selection
-		print "set config.misc.showtestcard to", {'yes': True, 'no': False}[selection]
+		print("set config.misc.showtestcard to", {'yes': True, 'no': False}[selection])
 		if selection == "yes":
 			config.misc.showtestcard.value = True
 		else:
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
@@ -6,7 +6,7 @@
 from Components.Label import Label
 from Components.Sources.StaticText import StaticText
 
-from VideoHardware import video_hw
+from .VideoHardware import video_hw
 
 config.misc.videowizardenabled = ConfigBoolean(default = True)
 
@@ -186,20 +186,20 @@
 		self.hw.on_hotplug.remove(self.hotplug)
 
 	def hotplug(self, what):
-		print "hotplug detected on port '%s'" % (what)
+		print("hotplug detected on port '%s'" % (what))
 		port = config.av.videoport.value
 		mode = config.av.videomode[port].value
 		rate = config.av.videorate[mode].value
 
 		if not self.hw.isModeAvailable(port, mode, rate):
-			print "mode %s/%s/%s went away!" % (port, mode, rate)
+			print("mode %s/%s/%s went away!" % (port, mode, rate))
 			modelist = self.hw.getModeList(port)
 			if not len(modelist):
-				print "sorry, no other mode is available (unplug?). Doing nothing."
+				print("sorry, no other mode is available (unplug?). Doing nothing.")
 				return
 			mode = modelist[0][0]
 			rate = modelist[0][1]
-			print "setting %s/%s/%s" % (port, mode, rate)
+			print("setting %s/%s/%s" % (port, mode, rate))
 			self.hw.setMode(port, mode, rate)
 
 hotplug = None
@@ -235,7 +235,7 @@
 	return [(_("A/V settings"), videoSetupMain, "av_setup", 40)]
 
 def VideoWizard(*args, **kwargs):
-	from VideoWizard import VideoWizard
+	from .VideoWizard import VideoWizard
 	return VideoWizard(*args, **kwargs)
 
 def Plugins(**kwargs):
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py
@@ -73,7 +73,7 @@
 			scanresults = ifobj.scan()
 		except:
 			scanresults = None
-			print "[Wlan.py] No wireless networks could be found"
+			print("[Wlan.py] No wireless networks could be found")
 		aps = {}
 		if scanresults is not None:
 			(num_channels, frequencies) = ifobj.getChannelInfo()
@@ -184,7 +184,7 @@
 			configfile = '/etc/wpa_supplicant.conf'
 		try:
 			#parse the wpasupplicant configfile
-			print "[Wlan.py] parsing configfile: ",configfile
+			print("[Wlan.py] parsing configfile: ",configfile)
 			fp = file(configfile, 'r')
 			supplicant = fp.readlines()
 			fp.close()
@@ -236,7 +236,7 @@
 					'key': config.plugins.wlan.psk.value,
 				}
 		
-			for (key, item) in wsconfig.items():
+			for (key, item) in list(wsconfig.items()):
 				if item is "None" or item is "":
 					if key == 'hiddenessid':
 						wsconfig['hiddenessid'] = False
@@ -249,7 +249,7 @@
 					if key == 'key':
 						wsconfig['key'] = ""
 		except:
-			print "[Wlan.py] Error parsing ",configfile
+			print("[Wlan.py] Error parsing ",configfile)
 			wsconfig = {
 					'hiddenessid': False,
 					'ssid': "",
@@ -270,7 +270,7 @@
 
 	def stopWlanConsole(self):
 		if self.WlanConsole is not None:
-			print "[iStatus] killing self.WlanConsole"
+			print("[iStatus] killing self.WlanConsole")
 			self.WlanConsole.killAll()
 			self.WlanConsole = None
 			
@@ -355,15 +355,15 @@
 		
 		if self.WlanConsole is not None:
 			if len(self.WlanConsole.appContainers) == 0:
-				print "[Wlan.py] self.wlaniface after loading:", self.wlaniface
+				print("[Wlan.py] self.wlaniface after loading:", self.wlaniface)
 				if self.statusCallback is not None:
 						self.statusCallback(True,self.wlaniface)
 						self.statusCallback = None
 
 	def getAdapterAttribute(self, iface, attribute):
 		self.iface = iface
-		if self.wlaniface.has_key(self.iface):
-			if self.wlaniface[self.iface].has_key(attribute):
+		if self.iface in self.wlaniface:
+			if attribute in self.wlaniface[self.iface]:
 				return self.wlaniface[self.iface][attribute]
 		return None
 	
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/WirelessLan/plugin.py
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/WirelessLan/plugin.py
@@ -15,7 +15,7 @@
 from Tools.Directories import resolveFilename, SCOPE_PLUGINS, SCOPE_SKIN_IMAGE
 from Tools.LoadPixmap import LoadPixmap
 from Tools.HardwareInfo import HardwareInfo
-from Wlan import iWlan, wpaSupplicant, iStatus, getWlanConfigName
+from .Wlan import iWlan, wpaSupplicant, iStatus, getWlanConfigName
 from time import time
 from os import system
 from re import escape as re_escape
@@ -132,24 +132,24 @@
 						essid = _("No Connection")
 					else:
 						accesspoint = status[self.iface]["accesspoint"]
-					if self.has_key("BSSID"):
+					if "BSSID" in self:
 						self["BSSID"].setText(accesspoint)
-					if self.has_key("ESSID"):
+					if "ESSID" in self:
 						self["ESSID"].setText(essid)
 
 					quality = status[self.iface]["quality"]
-					if self.has_key("quality"):
+					if "quality" in self:
 						self["quality"].setText(quality)
 						
 					if status[self.iface]["bitrate"] == '0':
 						bitrate = _("Unsupported")
 					else:
 						bitrate = str(status[self.iface]["bitrate"]) + " Mb/s"
-					if self.has_key("bitrate"):
+					if "bitrate" in self:
 						self["bitrate"].setText(bitrate)					
 					
 					signal = status[self.iface]["signal"]
-					if self.has_key("signal"):
+					if "signal" in self:
 						self["signal"].setText(signal)
 
 					if status[self.iface]["encryption"] == "off":
@@ -159,7 +159,7 @@
 							encryption = _("Unsupported")
 					else:
 						encryption = _("Enabled")
-					if self.has_key("enc"):
+					if "enc" in self:
 						self["enc"].setText(encryption)
 					self.updateStatusLink(status)
 
@@ -299,7 +299,7 @@
 		currentListEntry = None
 		currentListIndex = None
 
-		for ap in self.oldlist.keys():
+		for ap in list(self.oldlist.keys()):
 			data = self.oldlist[ap]['data']
 			if data is not None:
 				tmpList.append(data)
@@ -328,7 +328,7 @@
 		self.cleanList = []
 		aps = iWlan.getNetworkList()
 		if aps is not None:
-			print "[WirelessLan.py] got Accespoints!"
+			print("[WirelessLan.py] got Accespoints!")
 			tmpList = []
 			compList = []
 			for ap in aps:
@@ -344,7 +344,7 @@
 							compList.remove(compentry)
 			for entry in compList:
 				self.cleanList.append( ( entry[0], entry[1], entry[2], entry[3], entry[4], entry[5] ) )
-				if not self.oldlist.has_key(entry[0]):
+				if entry[0] not in self.oldlist:
 					self.oldlist[entry[0]] = { 'data': entry }
 				else:
 					self.oldlist[entry[0]]['data'] = entry
--- enigma2-nightly.org/lib/python/Screens/About.py
+++ enigma2-nightly.patched/lib/python/Screens/About.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import ActionMap
 from Components.Sources.StaticText import StaticText
 from Components.Harddisk import harddiskmanager
@@ -96,7 +96,7 @@
 				continue
 			(type, value) = l
 			infomap[type] = value
-		print infomap
+		print(infomap)
 
 		self["TranslationInfo"] = StaticText(info)
 
--- enigma2-nightly.org/lib/python/Screens/AudioSelection.py
+++ enigma2-nightly.patched/lib/python/Screens/AudioSelection.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Screens.Setup import getConfigMenuItem, Setup
 from Components.ServiceEventTracker import ServiceEventTracker
 from Components.ActionMap import NumberActionMap
@@ -16,7 +16,7 @@
 
 from Tools.ISO639 import LanguageCodes
 from Tools.BoundFunction import boundFunction
-FOCUS_CONFIG, FOCUS_STREAMS = range(2)
+FOCUS_CONFIG, FOCUS_STREAMS = list(range(2))
 [PAGE_AUDIO, PAGE_SUBTITLES] = ["audio", "subtitles"]
 
 class AudioSelection(Screen, ConfigListScreen):
@@ -123,7 +123,7 @@
 					for lang in languages:
 						if cnt:
 							language += ' / '
-						if LanguageCodes.has_key(lang):
+						if lang in LanguageCodes:
 							language += LanguageCodes[lang][0]
 						elif lang == "und":
 							""
@@ -163,7 +163,7 @@
 					conflist.append(getConfigListEntry(Plugins[0][0], ConfigNothing()))
 					self.plugincallfunc = Plugins[0][1]
 				if len(Plugins) > 1:
-					print "plugin(s) installed but not displayed in the dialog box:", Plugins[1:]
+					print("plugin(s) installed but not displayed in the dialog box:", Plugins[1:])
 
 		elif self.settings.menupage.getValue() == PAGE_SUBTITLES:
 	
@@ -187,7 +187,7 @@
 					
 				try:
 					if x[4] != "und":
-						if LanguageCodes.has_key(x[4]):
+						if x[4] in LanguageCodes:
 							language = LanguageCodes[x[4]][0]
 						else:
 							language = x[4]
@@ -216,7 +216,7 @@
 
 			conflist.append(getConfigListEntry(_("To audio selection"), self.settings.menupage))
 
-			if self.infobar.selected_subtitle and self.infobar.selected_subtitle != (0,0,0,0)  and not ".DVDPlayer'>" in `self.infobar`:
+			if self.infobar.selected_subtitle and self.infobar.selected_subtitle != (0,0,0,0)  and not ".DVDPlayer'>" in repr(self.infobar):
 				self["key_blue"].setBoolean(True)
 				conflist.append(getConfigListEntry(_("Subtitle Quickmenu"), ConfigNothing()))
 
--- enigma2-nightly.org/lib/python/Screens/ChannelSelection.py
+++ enigma2-nightly.patched/lib/python/Screens/ChannelSelection.py
@@ -1,6 +1,6 @@
 from Tools.Profile import profile
 
-from Screen import Screen
+from .Screen import Screen
 from Components.Button import Button
 from Components.ServiceList import ServiceList
 #+++>
@@ -13,7 +13,7 @@
 from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
 from Components.SystemInfo import SystemInfo
 profile("ChannelSelection.py 1")
-from EpgSelection import EPGSelection
+from .EpgSelection import EPGSelection
 from enigma import eServiceReference, eEPGCache, eServiceCenter, eRCInput, eTimer, eDVBDB, iPlayableService, iServiceInformation, getPrevAsciiCode, eEnv
 from Components.config import config, configfile, ConfigSubsection, ConfigText
 from Tools.NumericalTextInput import NumericalTextInput
@@ -535,7 +535,7 @@
 		mutableBouquet = cur_root.list().startEdit()
 		if mutableBouquet:
 			name = cur_service.getServiceName()
-			print "NAME", name
+			print("NAME", name)
 			if self.mode == MODE_TV:
 				str = '1:134:1:0:0:0:0:0:0:0:FROM BOUQUET \"alternatives.%s.tv\" ORDER BY bouquet'%(self.buildBouquetID(name))
 			else:
@@ -549,17 +549,17 @@
 				if mutableAlternatives:
 					mutableAlternatives.setListName(name)
 					if mutableAlternatives.addService(cur_service.ref):
-						print "add", cur_service.ref.toString(), "to new alternatives failed"
+						print("add", cur_service.ref.toString(), "to new alternatives failed")
 					mutableAlternatives.flushChanges()
 					self.servicelist.addService(new_ref.ref, True)
 					self.servicelist.removeCurrent()
 					self.servicelist.moveUp()
 				else:
-					print "get mutable list for new created alternatives failed"
+					print("get mutable list for new created alternatives failed")
 			else:
-				print "add", str, "to", cur_root.getServiceName(), "failed"
-		else:
-			print "bouquetlist is not editable"
+				print("add", str, "to", cur_root.getServiceName(), "failed")
+		else:
+			print("bouquetlist is not editable")
 
 	def addBouquet(self, bName, services):
 		serviceHandler = eServiceCenter.getInstance()
@@ -581,10 +581,10 @@
 					if services is not None:
 						for service in services:
 							if mutableBouquet.addService(service):
-								print "add", service.toString(), "to new bouquet failed"
+								print("add", service.toString(), "to new bouquet failed")
 					mutableBouquet.flushChanges()
 				else:
-					print "get mutable list for new created bouquet failed"
+					print("get mutable list for new created bouquet failed")
 				# do some voodoo to check if current_root is equal to bouquet_root
 				cur_root = self.getRoot();
 				str1 = cur_root and cur_root.toString()
@@ -593,9 +593,9 @@
 				if pos1 != -1 and pos2 != -1 and str1[pos1:] == self.bouquet_rootstr[pos2:]:
 					self.servicelist.addService(new_bouquet_ref)
 			else:
-				print "add", str, "to bouquets failed"
-		else:
-			print "bouquetlist is not editable"
+				print("add", str, "to bouquets failed")
+		else:
+			print("bouquetlist is not editable")
 
 	def copyCurrentToBouquetList(self):
 		provider = ServiceReference(self.getCurrentSelection())
@@ -616,17 +616,17 @@
 				if not edit_root.addService(first_in_alternative, cur_service.ref):
 					self.servicelist.addService(first_in_alternative, True)
 				else:
-					print "couldn't add first alternative service to current root"
+					print("couldn't add first alternative service to current root")
 			else:
-				print "couldn't edit current root!!"
-		else:
-			print "remove empty alternative list !!"
+				print("couldn't edit current root!!")
+		else:
+			print("remove empty alternative list !!")
 		self.removeBouquet()
 		self.servicelist.moveUp()
 
 	def removeBouquet(self):
 		refstr = self.getCurrentSelection().toString()
-		print "removeBouquet", refstr
+		print("removeBouquet", refstr)
 		pos = refstr.find('FROM BOUQUET "')
 		filename = None
 		if pos != -1:
@@ -639,7 +639,7 @@
 			if filename is not None:
 				remove(filename)
 		except OSError:
-			print "error during remove of", filename
+			print("error during remove of", filename)
 
 #  multiple marked entry stuff ( edit mode, later multiepg selection )
 	def startMarkedEdit(self, type):
@@ -821,7 +821,7 @@
 #+++<
 
 		self.numericalTextInput = NumericalTextInput()
-		self.numericalTextInput.setUseableChars(u'1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
+		self.numericalTextInput.setUseableChars('1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
 
 		self.servicePathTV = [ ]
 		self.servicePathRadio = [ ]
@@ -1194,7 +1194,7 @@
 			self.servicelist.moveToChar(charstr[0])
 
 	def keyAsciiCode(self):
-		unichar = unichr(getPrevAsciiCode())
+		unichar = chr(getPrevAsciiCode())
 		charstr = unichar.encode("utf-8")
 		if len(charstr) == 1:
 			self.servicelist.moveToChar(charstr[0])
--- enigma2-nightly.org/lib/python/Screens/ChoiceBox.py
+++ enigma2-nightly.patched/lib/python/Screens/ChoiceBox.py
@@ -127,7 +127,7 @@
 
 	# lookups a key in the keymap, then runs it
 	def goKey(self, key):
-		if self.keymap.has_key(key):
+		if key in self.keymap:
 			entry = self.keymap[key]
 			self.goEntry(entry)
 
--- enigma2-nightly.org/lib/python/Screens/Ci.py
+++ enigma2-nightly.patched/lib/python/Screens/Ci.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import ActionMap
 from Components.ActionMap import NumberActionMap
 from Components.Label import Label
@@ -32,7 +32,7 @@
 	def __init__(self, session, slotid, action, handler = eDVBCI_UI.getInstance(), wait_text = _("wait for ci...") ):
 		Screen.__init__(self, session)
 
-		print "MMIDialog with action" + str(action)
+		print("MMIDialog with action" + str(action))
 
 		self.mmiclosed = False
 		self.tag = None
@@ -101,9 +101,9 @@
 		if not self.tag:
 			return
 		if self.tag == "WAIT":
-			print "do nothing - wait"
+			print("do nothing - wait")
 		elif self.tag == "MENU":
-			print "answer MENU"
+			print("answer MENU")
 			cur = self["entries"].getCurrent()
 			if cur:
 				self.handler.answerMenu(self.slotid, cur[2])
@@ -111,7 +111,7 @@
 				self.handler.answerMenu(self.slotid, 0)
 			self.showWait()
 		elif self.tag == "LIST":
-			print "answer LIST"
+			print("answer LIST")
 			self.handler.answerMenu(self.slotid, 0)
 			self.showWait()
 		elif self.tag == "ENQ":
@@ -136,15 +136,15 @@
 			self.handler.stopMMI(self.slotid)
 			self.closeMmi()
 		elif self.tag in ( "MENU", "LIST" ):
-			print "cancel list"
+			print("cancel list")
 			self.handler.answerMenu(self.slotid, 0)
 			self.showWait()
 		elif self.tag == "ENQ":
-			print "cancel enq"
+			print("cancel enq")
 			self.handler.cancelEnq(self.slotid)
 			self.showWait()
 		else:
-			print "give cancel action to ci"
+			print("give cancel action to ci")
 
 	def keyConfigEntry(self, key):
 		self.timer.stop()
--- enigma2-nightly.org/lib/python/Screens/ClockDisplay.py
+++ enigma2-nightly.patched/lib/python/Screens/ClockDisplay.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 
 # a clock display dialog
 class ClockDisplay(Screen):
--- enigma2-nightly.org/lib/python/Screens/ConfigMenu.py
+++ enigma2-nightly.patched/lib/python/Screens/ConfigMenu.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ConfigList import ConfigList
 from Components.config import config
 from Components.ActionMap import ActionMap
--- enigma2-nightly.org/lib/python/Screens/Console.py
+++ enigma2-nightly.patched/lib/python/Screens/Console.py
@@ -42,7 +42,7 @@
 
 	def startRun(self):
 		self["text"].setText(_("Execution progress:") + "\n\n")
-		print "Console: executing in run", self.run, " the command:", self.cmdlist[self.run]
+		print("Console: executing in run", self.run, " the command:", self.cmdlist[self.run])
 		if self.container.execute(self.cmdlist[self.run]): #start of container application failed...
 			self.runFinished(-1) # so we must call runFinished manual
 
--- enigma2-nightly.org/lib/python/Screens/CopyFiles.py
+++ enigma2-nightly.patched/lib/python/Screens/CopyFiles.py
@@ -20,20 +20,20 @@
 			try:
 				self.end += os.stat(src).st_size
 			except:
-				print "Failed to stat", src
+				print("Failed to stat", src)
 		if not self.end:
 			self.end = 1
-		print "[CopyFileTask] size:", self.end
+		print("[CopyFileTask] size:", self.end)
 	def work(self):
-		print "[CopyFileTask] handles ", len(self.handles)
+		print("[CopyFileTask] handles ", len(self.handles))
 		try:
 			bs = 65536
 			d = bytearray(bs)
 			for src, dst in self.handles:
 				while 1:
 					if self.aborted:
-						print "[CopyFileTask] aborting"
-						raise Exception, "Aborted"
+						print("[CopyFileTask] aborting")
+						raise Exception("Aborted")
 					l = src.readinto(d)
 					if l < bs:
 						if not l:
@@ -61,12 +61,12 @@
 class MoveFileTask(CopyFileTask):
 	def work(self):
 		CopyFileTask.work(self)
-		print "[MoveFileTask]: delete source files"
+		print("[MoveFileTask]: delete source files")
 		errors = []
 		for s,d in self.fileList:
 			try:
 				os.unlink(s)
-			except Exception, e:
+			except Exception as e:
 				errors.append(e)
 		if errors:
 			 raise errors[0]
--- enigma2-nightly.org/lib/python/Screens/DVD.py
+++ enigma2-nightly.patched/lib/python/Screens/DVD.py
@@ -14,6 +14,7 @@
 from Components.config import config
 from Tools.Directories import pathExists, fileExists
 from Components.Harddisk import harddiskmanager
+import collections
 
 lastpath = ""
 
@@ -286,7 +287,7 @@
 		self.in_menu = False
 
 	def keyNumberGlobal(self, number):
-		print "You pressed number " + str(number)
+		print("You pressed number " + str(number))
 		self.session.openWithCallback(self.numberEntered, ChapterZap, number)
 
 	def numberEntered(self, retval):
@@ -298,7 +299,7 @@
 		service = self.service
 		if service:
 			attr = getattr(service, iface, None)
-			if callable(attr):
+			if isinstance(attr, collections.Callable):
 				return attr()
 		return None
 
@@ -344,32 +345,32 @@
 	def toggleInfo(self):
 		if not self.in_menu:
 			self.toggleShow()
-			print "toggleInfo"
+			print("toggleInfo")
 
 	def __timeUpdated(self):
-		print "timeUpdated"
+		print("timeUpdated")
 
 	def __statePlay(self):
-		print "statePlay"
+		print("statePlay")
 
 	def __statePause(self):
-		print "statePause"
+		print("statePause")
 
 	def __osdFFwdInfoAvail(self):
 		self.setChapterLabel()
-		print "FFwdInfoAvail"
+		print("FFwdInfoAvail")
 
 	def __osdFBwdInfoAvail(self):
 		self.setChapterLabel()
-		print "FBwdInfoAvail"
+		print("FBwdInfoAvail")
 
 	def __osdStringAvail(self):
-		print "StringAvail"
+		print("StringAvail")
 
 	def __osdAudioInfoAvail(self):
 		info = self.getServiceInterface("info")
 		audioTuple = info and info.getInfoObject(iServiceInformation.sUser+6)
-		print "AudioInfoAvail ", repr(audioTuple)
+		print("AudioInfoAvail ", repr(audioTuple))
 		if audioTuple:
 			audioString = "%d: %s (%s)" % (audioTuple[0],audioTuple[1],audioTuple[2])
 			self["audioLabel"].setText(audioString)
@@ -380,7 +381,7 @@
 	def __osdSubtitleInfoAvail(self):
 		info = self.getServiceInterface("info")
 		subtitleTuple = info and info.getInfoObject(iServiceInformation.sUser+7)
-		print "SubtitleInfoAvail ", repr(subtitleTuple)
+		print("SubtitleInfoAvail ", repr(subtitleTuple))
 		if subtitleTuple:
 			subtitleString = ""
 			if subtitleTuple[0] is not 0:
@@ -393,7 +394,7 @@
 	def __osdAngleInfoAvail(self):
 		info = self.getServiceInterface("info")
 		angleTuple = info and info.getInfoObject(iServiceInformation.sUser+8)
-		print "AngleInfoAvail ", repr(angleTuple)
+		print("AngleInfoAvail ", repr(angleTuple))
 		if angleTuple:
 			angleString = ""
 			if angleTuple[1] > 1:
@@ -412,7 +413,7 @@
 			self.currentChapter = info.getInfo(iServiceInformation.sCurrentChapter)
 			self.totalChapters = info.getInfo(iServiceInformation.sTotalChapters)
 			self.setChapterLabel()
-			print "__chapterUpdated: %d/%d" % (self.currentChapter, self.totalChapters)
+			print("__chapterUpdated: %d/%d" % (self.currentChapter, self.totalChapters))
 
 	def __titleUpdated(self):
 		info = self.getServiceInterface("info")
@@ -420,7 +421,7 @@
 			self.currentTitle = info.getInfo(iServiceInformation.sCurrentTitle)
 			self.totalTitles = info.getInfo(iServiceInformation.sTotalTitles)
 			self.setChapterLabel()
-			print "__titleUpdated: %d/%d" % (self.currentTitle, self.totalTitles)
+			print("__titleUpdated: %d/%d" % (self.currentTitle, self.totalTitles))
 			if not self.in_menu:
 				self.doShow()
 		
@@ -481,7 +482,7 @@
 		if self.service:
 			seekable = self.getSeek()
 			if seekable:
-				print "seek to chapter %d" % number
+				print("seek to chapter %d" % number)
 				seekable.seekChapter(number)
 
 #	MENU ACTIONS
@@ -521,7 +522,7 @@
 
 	def FileBrowserClosed(self, val):
 		curref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
-		print "FileBrowserClosed", val
+		print("FileBrowserClosed", val)
 		if val is None:
 			self.askLeavePlayer()
 		else:
@@ -529,7 +530,7 @@
 			if os.path.exists(val + isopathname):
 				val += isopathname
 			newref = eServiceReference(4369, 0, val)
-			print "play", newref.toString()
+			print("play", newref.toString())
 			if curref is None or curref != newref:
 				if newref.toString().endswith("/VIDEO_TS") or newref.toString().endswith("/"):
 					names = newref.toString().rsplit("/",3)
@@ -537,7 +538,7 @@
 						name = str(names[1]) + " - " + str(names[2])
 					else:
 						name = names[2]
-					print "setting name to: ", self.service
+					print("setting name to: ", self.service)
 					newref.setName(str(name))
 
 #				Construct a path for the IFO header assuming it exists
@@ -550,18 +551,18 @@
 					if status:
 						 break
 				height = getDesktop(0).size().height()
-				print "[DVD] height:", height
+				print("[DVD] height:", height)
 				if isNTSC:
 					height = height * 576 / 480
-					print "[DVD] NTSC height:", height
+					print("[DVD] NTSC height:", height)
 				if isLowResolution:
 					height *= 2
-					print "[DVD] LowResolution:", height
+					print("[DVD] LowResolution:", height)
 				self.dvdScreen = self.session.instantiateDialog(DVDOverlay, height=height)
 				self.session.nav.playService(newref)
 				self.service = self.session.nav.getCurrentService()
-				print "self.service", self.service
-				print "cur_dlg", self.session.current_dialog
+				print("self.service", self.service)
+				print("cur_dlg", self.session.current_dialog)
 				subs = self.getServiceInterface("subtitle")
 				if subs:
 					subs.enableSubtitles(self.dvdScreen.instance, None)
@@ -570,7 +571,7 @@
 		(name, offset) = checked_file
 		isofilename += name
 
-		print "[DVD] file", name
+		print("[DVD] file", name)
 
 		status = False
 		isNTSC = False
@@ -585,13 +586,13 @@
 			if video_attr_high != 0:
 				status = True
 			video_attr_low = ord(ifofile.read(1))
-			print "[DVD] %s: video_attr_high = %x" % ( name, video_attr_high ), "video_attr_low = %x" % ( video_attr_low )
+			print("[DVD] %s: video_attr_high = %x" % ( name, video_attr_high ), "video_attr_low = %x" % ( video_attr_low ))
 			isNTSC = (video_attr_high & 0x10 == 0)
 			isLowResolution = (video_attr_low & 0x18 == 0x18)
 		except:
 #			If the service is an .iso or .img file we assume it is PAL
 #			Sorry we cannot open image files here.
-			print "[DVD] Cannot read file or is ISO/IMG"
+			print("[DVD] Cannot read file or is ISO/IMG")
 		finally:
 			if ifofile is not None:
 				ifofile.close()
@@ -620,7 +621,7 @@
 			pass
 
 	def playLastCB(self, answer): # overwrite infobar cuesheet function
-		print "playLastCB", answer, self.resume_point
+		print("playLastCB", answer, self.resume_point)
 		if self.service:
 			if answer == True:
 				seekable = self.getSeek()
@@ -645,7 +646,7 @@
 		return 0
 
 	def hotplugCB(self, dev, media_state):
-		print "[hotplugCB]", dev, media_state
+		print("[hotplugCB]", dev, media_state)
 		if dev == harddiskmanager.getCD():
 			if media_state == "1":
 				self.scanHotplug()
@@ -661,9 +662,9 @@
 			if list:
 				(desc, scanner, files, session) = list[0]
 				for file in files:
-					print file
+					print(file)
 					if file.mimetype == "video/x-dvd":
-						print "physical dvd found:", devicepath
+						print("physical dvd found:", devicepath)
 						self.physicalDVD = True
 						return
 		self.physicalDVD = False
--- enigma2-nightly.org/lib/python/Screens/Dish.py
+++ enigma2-nightly.patched/lib/python/Screens/Dish.py
@@ -1,5 +1,5 @@
 # -*- coding: utf-8 -*-
-from Screen import Screen
+from .Screen import Screen
 from Components.BlinkingPixmap import BlinkingPixmapConditional
 from Components.Pixmap import Pixmap
 from Components.config import config, ConfigInteger
--- enigma2-nightly.org/lib/python/Screens/EpgSelection.py
+++ enigma2-nightly.patched/lib/python/Screens/EpgSelection.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.config import config, ConfigClock
 from Components.Button import Button
 from Components.Pixmap import Pixmap
@@ -12,10 +12,10 @@
 from Screens.TimerEdit import TimerSanityConflict
 from Screens.EventView import EventViewSimple
 from Screens.MessageBox import MessageBox
-from TimeDateInput import TimeDateInput
+from .TimeDateInput import TimeDateInput
 from enigma import eServiceReference
 from RecordTimer import RecordTimerEntry, parseEvent, AFTEREVENT
-from TimerEntry import TimerEntry
+from .TimerEntry import TimerEntry
 from ServiceReference import ServiceReference
 from time import localtime, time
 
@@ -254,7 +254,7 @@
 			self.session.openWithCallback(self.finishedAdd, TimerEntry, newEntry)
 
 	def finishedAdd(self, answer):
-		print "finished add"
+		print("finished add")
 		if answer[0]:
 			entry = answer[1]
 			simulTimerList = self.session.nav.RecordTimer.record(entry)
@@ -270,7 +270,7 @@
 		else:
 			self["key_green"].setText(_("Add timer"))
 			self.key_green_choice = self.ADD_TIMER
-			print "Timeredit aborted"
+			print("Timeredit aborted")
 	
 	def finishSanityCorrection(self, answer):
 		self.finishedAdd(answer)
--- enigma2-nightly.org/lib/python/Screens/EventView.py
+++ enigma2-nightly.patched/lib/python/Screens/EventView.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Screens.TimerEdit import TimerSanityConflict
 from Screens.MessageBox import MessageBox
 from Components.ActionMap import ActionMap
@@ -11,7 +11,7 @@
 from Components.UsageConfig import preferredTimerPath
 from enigma import eEPGCache, eTimer, eServiceReference
 from RecordTimer import RecordTimerEntry, parseEvent, AFTEREVENT
-from TimerEntry import TimerEntry
+from .TimerEntry import TimerEntry
 from Plugins.Plugin import PluginDescriptor
 from Tools.BoundFunction import boundFunction
 from time import localtime
@@ -34,7 +34,7 @@
 
 		for p in plugins.getPlugins(PluginDescriptor.WHERE_EVENTINFO):
 			#only list service or event specific eventinfo plugins here, no servelist plugins
-			if 'servicelist' not in p.__call__.func_code.co_varnames:
+			if 'servicelist' not in p.__call__.__code__.co_varnames:
 				menu.append((p.name, boundFunction(self.runPlugin, p)))
 
 		self["menu"] = MenuList(menu)
@@ -126,7 +126,7 @@
 			self.session.openWithCallback(self.finishedAdd, TimerEntry, newEntry)
 
 	def finishedAdd(self, answer):
-		print "finished add"
+		print("finished add")
 		if answer[0]:
 			entry = answer[1]
 			simulTimerList = self.session.nav.RecordTimer.record(entry)
@@ -142,7 +142,7 @@
 		else:
 			self["key_green"].setText(_("Add timer"))
 			self.key_green_choice = self.ADD_TIMER
-			print "Timeredit aborted"		
+			print("Timeredit aborted")		
 
 	def finishSanityCorrection(self, answer):
 		self.finishedAdd(answer)
--- enigma2-nightly.org/lib/python/Screens/FixedMenu.py
+++ enigma2-nightly.patched/lib/python/Screens/FixedMenu.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.Sources.List import List
 from Components.ActionMap import ActionMap
 from Components.Sources.StaticText import StaticText
--- enigma2-nightly.org/lib/python/Screens/HarddiskSetup.py
+++ enigma2-nightly.patched/lib/python/Screens/HarddiskSetup.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import ActionMap
 from Components.Harddisk import harddiskmanager
 from Components.MenuList import MenuList
@@ -36,7 +36,7 @@
 		from Components.Task import job_manager
 		try:
 			job_manager.AddJob(self.action(), onSuccess=job_manager.popupTaskView)
-		except Exception, ex:
+		except Exception as ex:
 			self.session.open(MessageBox, str(ex), type=MessageBox.TYPE_ERROR, timeout=10)
 		self.close()
 
--- enigma2-nightly.org/lib/python/Screens/HelpMenu.py
+++ enigma2-nightly.patched/lib/python/Screens/HelpMenu.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.Pixmap import Pixmap, MovingPixmap
 from Components.Label import Label
 from Components.ActionMap import ActionMap
@@ -28,7 +28,7 @@
 		if selection:
 			selection = selection[3]
 		#arrow = self["arrowup"]
-		print "selection:", selection
+		print("selection:", selection)
 
 		longText = ""
 		if selection and len(selection) > 1:
@@ -40,7 +40,7 @@
 
 		self.selectKey(selection[0])
 		#if selection is None:
-		print "select arrow"
+		print("select arrow")
 		#	arrow.moveTo(selection[1], selection[2], 1)
 		#	arrow.startMoving()
 		#	arrow.show()
--- enigma2-nightly.org/lib/python/Screens/InfoBar.py
+++ enigma2-nightly.patched/lib/python/Screens/InfoBar.py
@@ -3,7 +3,7 @@
 # workaround for required config entry dependencies.
 import Screens.MovieSelection
 
-from Screen import Screen
+from .Screen import Screen
 from Screens.MessageBox import MessageBox
 
 profile("LOAD:enigma")
@@ -80,12 +80,12 @@
 		InfoBar.instance = self
 
 	def _volUp(self):
-		print "_volUp"
+		print("_volUp")
 		from Components.VolumeControl import VolumeControl
 		VolumeControl.instance.volUp()
 
 	def _volDown(self):
-		print "_volDown"
+		print("_volDown")
 		from Components.VolumeControl import VolumeControl
 		VolumeControl.instance.volDown()
 
@@ -113,14 +113,14 @@
 		AudioPID = info.getInfo(iServiceInformation.sAudioPID)
 		VideoPID = info.getInfo(iServiceInformation.sVideoPID)
 
-		print "sAudioPID", AudioPID
-		print "sVideoPID", VideoPID
+		print("sAudioPID", AudioPID)
+		print("sVideoPID", VideoPID)
 
 		if VideoPID == -1:
-			print "radio->tv"
+			print("radio->tv")
 			self.showTv2()
 		else:
-			print "tv->radio"
+			print("tv->radio")
 			self.showRadio2()
 
 	def serviceStarted(self):  #override from InfoBarShowHide
@@ -281,8 +281,8 @@
 						# Moved to trash, okay
 						self.close()
 						return
-					except Exception, e:
-						print "[InfoBar] Failed to move to .Trash folder:", e
+					except Exception as e:
+						print("[InfoBar] Failed to move to .Trash folder:", e)
 						msg = _("Cannot move to trash can") + "\n" + str(e) + "\n"
 				info = serviceHandler.info(ref)
 				name = info and info.getName(ref) or _("this recording")
@@ -441,7 +441,7 @@
 				self.session.nav.playService(ref)
 
 	def nextPlaylistService(self, service):
-		from MovieSelection import playlist
+		from .MovieSelection import playlist
 		for i, item in enumerate(playlist):
 			if item == service:
 				i += 1
--- enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py
+++ enigma2-nightly.patched/lib/python/Screens/InfoBarGenerics.py
@@ -1,4 +1,4 @@
-from ChannelSelection import ChannelSelection, BouquetSelector, SilentBouquetSelector
+from .ChannelSelection import ChannelSelection, BouquetSelector, SilentBouquetSelector
 
 from Components.ActionMap import ActionMap, HelpableActionMap
 from Components.ActionMap import NumberActionMap
@@ -11,10 +11,10 @@
 from Components.config import config, ConfigBoolean, ConfigClock, ConfigSubsection, ConfigYesNo, ConfigText
 from Components.SystemInfo import SystemInfo
 from Components.UsageConfig import preferredInstantRecordPath, defaultMoviePath, ConfigSelection
-from EpgSelection import EPGSelection
+from .EpgSelection import EPGSelection
 from Plugins.Plugin import PluginDescriptor
 
-from Screen import Screen
+from .Screen import Screen
 from Screens.ChoiceBox import ChoiceBox
 from Screens.Dish import Dish
 from Screens.EventView import EventViewEPGSelect, EventViewSimple
@@ -43,10 +43,10 @@
 from RecordTimer import RecordTimerEntry, RecordTimer, findSafeRecordPath
 
 # hack alert!
-from Menu import MainMenu, mdom
+from .Menu import MainMenu, mdom
 
 def isStandardInfoBar(self):
-	return ".InfoBar'>" in `self`
+	return ".InfoBar'>" in repr(self)
 
 def setResumePoint(session):
 	global resumePointCache, resumePointCacheLast
@@ -68,7 +68,7 @@
 				resumePointCache[key] = [lru, pos[1], l]
 				if len(resumePointCache) > 50:
 					candidate = key
-					for k,v in resumePointCache.items():
+					for k,v in list(resumePointCache.items()):
 						if v[0] < lru:
 							candidate = k
 					del resumePointCache[candidate]
@@ -97,20 +97,20 @@
 
 def saveResumePoints():
 	global resumePointCache, resumePointCacheLast
-	import cPickle
+	import pickle
 	try:
 		f = open('/etc/enigma2/resumepoints.pkl', 'wb')
-		cPickle.dump(resumePointCache, f, cPickle.HIGHEST_PROTOCOL)
-	except Exception, ex:
-		print "[InfoBar] Failed to write resumepoints:", ex
+		pickle.dump(resumePointCache, f, pickle.HIGHEST_PROTOCOL)
+	except Exception as ex:
+		print("[InfoBar] Failed to write resumepoints:", ex)
 	resumePointCacheLast = int(time())
 
 def loadResumePoints():
-	import cPickle
+	import pickle
 	try:
-		return cPickle.load(open('/etc/enigma2/resumepoints.pkl', 'rb'))
-	except Exception, ex:
-		print "[InfoBar] Failed to load resumepoints:", ex
+		return pickle.load(open('/etc/enigma2/resumepoints.pkl', 'rb'))
+	except Exception as ex:
+		print("[InfoBar] Failed to load resumepoints:", ex)
 		return {}
 
 resumePointCache = loadResumePoints()
@@ -388,7 +388,7 @@
 			else:
 				self.servicelist.recallPrevService()
 		else:
-			if self.has_key("TimeshiftActions") and not self.timeshift_enabled:
+			if "TimeshiftActions" in self and not self.timeshift_enabled:
 				self.session.openWithCallback(self.numberEntered, NumberZap, number, self.searchNumber)
 
 	def numberEntered(self, service = None, bouquet = None):
@@ -563,7 +563,7 @@
 		self.session.infobar = None
 
 	def mainMenu(self):
-		print "loading mainmenu XML..."
+		print("loading mainmenu XML...")
 		menu = mdom.getroot()
 		assert menu.tag == "menu", "root element in menu must be 'menu'!"
 
@@ -895,7 +895,7 @@
 			self.eventView = self.session.openWithCallback(self.closed, EventViewEPGSelect, epglist[0], ServiceReference(ref), self.eventViewCallback, self.openSingleServiceEPG, self.openMultiServiceEPG, self.openSimilarList)
 			self.dlg_stack.append(self.eventView)
 		else:
-			print "no epg for the service avail.. so we show multiepg instead of eventinfo"
+			print("no epg for the service avail.. so we show multiepg instead of eventinfo")
 			self.openMultiServiceEPG(False)
 
 	def eventViewCallback(self, setEvent, setService, val): #used for now/next displaying
@@ -979,7 +979,7 @@
 				self.screen = screen
 
 			def action(self, contexts, action):
-				print "action:", action
+				print("action:", action)
 				if action[:5] == "seek:":
 					time = int(action[5:])
 					self.screen.doSeekRelative(time * 90000)
@@ -1105,23 +1105,23 @@
 		pauseable = service.pause()
 
 		if pauseable is None:
-			print "not pauseable."
+			print("not pauseable.")
 			state = self.SEEK_STATE_PLAY
 
 		self.seekstate = state
 
 		if pauseable is not None:
 			if self.seekstate[0]:
-				print "resolved to PAUSE"
+				print("resolved to PAUSE")
 				pauseable.pause()
 			elif self.seekstate[1]:
-				print "resolved to FAST FORWARD"
+				print("resolved to FAST FORWARD")
 				pauseable.setFastForward(self.seekstate[1])
 			elif self.seekstate[2]:
-				print "resolved to SLOW MOTION"
+				print("resolved to SLOW MOTION")
 				pauseable.setSlowMotion(self.seekstate[2])
 			else:
-				print "resolved to PLAY"
+				print("resolved to PLAY")
 				pauseable.unpause()
 
 		for c in self.onPlayStateChanged:
@@ -1152,7 +1152,7 @@
 			self.setSeekState(self.SEEK_STATE_PAUSE)
 
 	def unPauseService(self):
-		print "unpause"
+		print("unpause")
 		if self.seekstate == self.SEEK_STATE_PLAY:
 			return 0
 		self.setSeekState(self.SEEK_STATE_PLAY)
@@ -1256,14 +1256,14 @@
 		self.session.openWithCallback(self.fwdSeekTo, MinuteInput)
 
 	def fwdSeekTo(self, minutes):
-		print "Seek", minutes, "minutes forward"
+		print("Seek", minutes, "minutes forward")
 		self.doSeekRelative(minutes * 60 * 90000)
 
 	def seekBackManual(self):
 		self.session.openWithCallback(self.rwdSeekTo, MinuteInput)
 
 	def rwdSeekTo(self, minutes):
-		print "rwdSeekTo"
+		print("rwdSeekTo")
 		self.doSeekRelative(-minutes * 60 * 90000)
 
 	def checkSkipShowHideLock(self):
@@ -1432,15 +1432,15 @@
 		return service and service.timeshift()
 
 	def startTimeshift(self):
-		print "enable timeshift"
+		print("enable timeshift")
 		ts = self.getTimeshift()
 		if ts is None:
 			self.session.open(MessageBox, _("Timeshift not possible!"), MessageBox.TYPE_ERROR, simple = True)
-			print "no ts interface"
+			print("no ts interface")
 			return 0
 
 		if self.timeshift_enabled:
-			print "hu, timeshift already enabled?"
+			print("hu, timeshift already enabled?")
 		else:
 			if not ts.startTimeshift():
 				self.timeshift_enabled = True
@@ -1456,12 +1456,12 @@
 				# the startTimeshift actions
 				self.__seekableStatusChanged()
 			else:
-				print "timeshift failed"
+				print("timeshift failed")
 
 	def stopTimeshift(self):
 		if not self.timeshift_enabled:
 			return 0
-		print "disable timeshift"
+		print("disable timeshift")
 		ts = self.getTimeshift()
 		if ts is None:
 			return 0
@@ -1485,16 +1485,16 @@
 	# activates timeshift, and seeks to (almost) the end
 	def activateTimeshiftEnd(self, back = True):
 		ts = self.getTimeshift()
-		print "activateTimeshiftEnd"
+		print("activateTimeshiftEnd")
 
 		if ts is None:
 			return
 
 		if ts.isTimeshiftActive():
-			print "!! activate timeshift called - but shouldn't this be a normal pause?"
+			print("!! activate timeshift called - but shouldn't this be a normal pause?")
 			self.pauseService()
 		else:
-			print "play, ..."
+			print("play, ...")
 			ts.activateTimeshift() # activate timeshift will automatically pause
 			self.setSeekState(self.SEEK_STATE_PAUSE)
 			seekable = self.getSeek()
@@ -1508,7 +1508,7 @@
 
 	# same as activateTimeshiftEnd, but pauses afterwards.
 	def activateTimeshiftEndAndPause(self):
-		print "activateTimeshiftEndAndPause"
+		print("activateTimeshiftEndAndPause")
 		#state = self.seekstate
 		self.activateTimeshiftEnd(False)
 
@@ -1546,12 +1546,12 @@
 	def updateExtension(self, extension, key = None):
 		self.extensionsList.append(extension)
 		if key is not None:
-			if self.extensionKeys.has_key(key):
+			if key in self.extensionKeys:
 				key = None
 
 		if key is None:
 			for x in self.availableKeys:
-				if not self.extensionKeys.has_key(x):
+				if x not in self.extensionKeys:
 					key = x
 					break
 
@@ -1576,7 +1576,7 @@
 		keys = []
 		list = []
 		for x in self.availableKeys:
-			if self.extensionKeys.has_key(x):
+			if x in self.extensionKeys:
 				entry = self.extensionKeys[x]
 				extension = self.extensionsList[entry]
 				if extension[2]():
@@ -1807,7 +1807,7 @@
 			if len(simulTimerList) > 1: # with other recording
 				name = simulTimerList[1].name
 				name_date = ' '.join((name, strftime('%F %T', localtime(simulTimerList[1].begin))))
-				print "[TIMER] conflicts with", name_date
+				print("[TIMER] conflicts with", name_date)
 				recording.autoincrease = True	# start with max available length, then increment
 				if recording.setAutoincreaseEnd():
 					self.session.nav.RecordTimer.record(recording)
@@ -1820,7 +1820,7 @@
 			recording.autoincrease = False
 
 	def isInstantRecordRunning(self):
-		print "self.recording:", self.recording
+		print("self.recording:", self.recording)
 		if self.recording:
 			for x in self.recording:
 				if x.isRunning():
@@ -1828,7 +1828,7 @@
 		return False
 
 	def recordQuestionCallback(self, answer):
-		print "pre:\n", self.recording
+		print("pre:\n", self.recording)
 
 		if answer is None or answer[1] == "no":
 			return
@@ -1858,7 +1858,7 @@
 				self.changeDuration(len(self.recording)-1)
 			elif answer[1] == "manualendtime":
 				self.setEndtime(len(self.recording)-1)
-		print "after:\n", self.recording
+		print("after:\n", self.recording)
 
 	def setEndtime(self, entry):
 		if entry is not None and entry >= 0:
@@ -1870,7 +1870,7 @@
 	def TimeDateInputClosed(self, ret):
 		if len(ret) > 1:
 			if ret[0]:
-				print "stopping recording at", strftime("%F %T", localtime(ret[1]))
+				print("stopping recording at", strftime("%F %T", localtime(ret[1])))
 				if self.recording[self.selectedEntry].end != ret[1]:
 					self.recording[self.selectedEntry].autoincrease = False
 				self.recording[self.selectedEntry].end = ret[1]
@@ -1883,7 +1883,7 @@
 
 	def inputCallback(self, value):
 		if value is not None:
-			print "stopping recording after", int(value), "minutes."
+			print("stopping recording after", int(value), "minutes.")
 			entry = self.recording[self.selectedEntry]
 			if int(value) != 0:
 				entry.autoincrease = False
@@ -1928,7 +1928,7 @@
 		self.session.openWithCallback(self.audioSelected, AudioSelection, infobar=self)
 
 	def audioSelected(self, ret=None):
-		print "[infobar::audioSelected]", ret
+		print("[infobar::audioSelected]", ret)
 
 class InfoBarSubserviceSelection:
 	def __init__(self):
@@ -2111,7 +2111,7 @@
 			del notifications[0]
 			cb = n[0]
 
-			if n[3].has_key("onSessionOpenCallback"):
+			if "onSessionOpenCallback" in n[3]:
 				n[3]["onSessionOpenCallback"]()
 				del n[3]["onSessionOpenCallback"]
 
@@ -2136,7 +2136,7 @@
 			})
 
 	def serviceHasEnded(self):
-		print "service end!"
+		print("service end!")
 
 		try:
 			self.setSeekState(self.SEEK_STATE_PLAY)
@@ -2169,7 +2169,7 @@
 	def __serviceStarted(self):
 		if self.is_closing:
 			return
-		print "new service started! trying to download cuts!"
+		print("new service started! trying to download cuts!")
 		self.downloadCuesheet()
 
 		if self.ENABLE_RESUME_SUPPORT:
@@ -2186,7 +2186,7 @@
 			if seekable is None:
 				return # Should not happen?
 			length = seekable.getLength() or (None,0)
-			print "seekable.getLength() returns:", length
+			print("seekable.getLength() returns:", length)
 			# Hmm, this implies we don't resume if the length is unknown...
 			if (last > 900000) and (not length[1]  or (last < length[1] - 900000)):
 				self.resume_point = last
@@ -2225,7 +2225,7 @@
 		r = seek.getPlayPosition()
 		if r[0]:
 			return None
-		return long(r[1])
+		return int(r[1])
 
 	def cueGetEndCutPosition(self):
 		ret = False
@@ -2296,7 +2296,7 @@
 	def toggleMark(self, onlyremove=False, onlyadd=False, tolerance=5*90000, onlyreturn=False):
 		current_pos = self.cueGetCurrentPosition()
 		if current_pos is None:
-			print "not seekable"
+			print("not seekable")
 			return
 
 		nearest_cutpoint = self.getNearestCutPoint(current_pos)
@@ -2336,7 +2336,7 @@
 		cue = self.__getCuesheet()
 
 		if cue is None:
-			print "upload failed, no cuesheet interface"
+			print("upload failed, no cuesheet interface")
 			return
 		cue.setCutList(self.cut_list)
 
@@ -2344,7 +2344,7 @@
 		cue = self.__getCuesheet()
 
 		if cue is None:
-			print "download failed, no cuesheet interface"
+			print("download failed, no cuesheet interface")
 			self.cut_list = [ ]
 		else:
 			self.cut_list = cue.getCutList()
@@ -2417,7 +2417,7 @@
 					"startTeletext": (self.startTeletext, _("View teletext..."))
 				})
 		else:
-			print "no teletext plugin found!"
+			print("no teletext plugin found!")
 
 	def startTeletext(self):
 		self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
@@ -2562,7 +2562,7 @@
 		tlist.append(("Bestfit", "bestfit"))
 
 		mode = open("/proc/stb/video/policy").read()[:-1]
-		print mode
+		print(mode)
 		for x in range(len(tlist)):
 			if tlist[x][1] == mode:
 				selection = x
@@ -2639,7 +2639,7 @@
 		keys = ["green", "yellow", "blue", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
 
 		mode = open("/proc/stb/video/videomode").read()[:-1]
-		print mode
+		print(mode)
 		for x in range(len(tlist)):
 			if tlist[x][1] == mode:
 				selection = x
--- enigma2-nightly.org/lib/python/Screens/InputBox.py
+++ enigma2-nightly.patched/lib/python/Screens/InputBox.py
@@ -147,7 +147,7 @@
 				pass
 	
 	def closePinWrong(self, *args):
-		print "args:", args
+		print("args:", args)
 		self.close(False)
 		
 	def closePinCorrect(self, *args):
--- enigma2-nightly.org/lib/python/Screens/InputDeviceSetup.py
+++ enigma2-nightly.patched/lib/python/Screens/InputDeviceSetup.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Screens.HelpMenu import HelpableScreen
 from Screens.MessageBox import MessageBox
 from Components.InputDevice import iInputDevices, iRcTypeControl
@@ -51,7 +51,7 @@
 		self["introduction"] = StaticText(self.edittext)
 
 		self.devices = [(iInputDevices.getDeviceName(x),x) for x in iInputDevices.getDeviceList()]
-		print "[InputDeviceSelection] found devices :->", len(self.devices),self.devices
+		print("[InputDeviceSelection] found devices :->", len(self.devices),self.devices)
 
 		self["OkCancelActions"] = HelpableActionMap(self, "OkCancelActions",
 			{
@@ -251,7 +251,7 @@
 
 	def confirm(self, confirmed):
 		if not confirmed:
-			print "not confirmed"
+			print("not confirmed")
 			return
 		else:
 			self.nameEntry[1].setValue(iInputDevices.getDeviceAttribute(self.inputDevice, 'name'))
--- enigma2-nightly.org/lib/python/Screens/Ipkg.py
+++ enigma2-nightly.patched/lib/python/Screens/Ipkg.py
@@ -49,7 +49,7 @@
 			self.runningCmd = 0
 		else:
 			self.runningCmd += 1
-		print len(self.cmdList), self.runningCmd
+		print(len(self.cmdList), self.runningCmd)
 		if len(self.cmdList) - 1 < self.runningCmd:
 			self.activityslider.setValue(0)
 			self.slider.setValue(len(self.cmdList))
@@ -82,7 +82,7 @@
 		if event == IpkgComponent.EVENT_DOWNLOAD:
 			self.status.setText(_("Downloading"))
 		elif event == IpkgComponent.EVENT_UPGRADE:
-			if self.sliderPackages.has_key(param):
+			if param in self.sliderPackages:
 				self.slider.setValue(self.sliderPackages[param])
 			self.package.setText(param)
 			self.status.setText(_("Upgrading"))
--- enigma2-nightly.org/lib/python/Screens/LanguageSelection.py
+++ enigma2-nightly.patched/lib/python/Screens/LanguageSelection.py
@@ -1,5 +1,5 @@
 import gettext
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import ActionMap
 from Components.Language import language
 from Components.config import config
@@ -59,7 +59,7 @@
 		self.close()
 
 	def run(self):
-		print "updating language..."
+		print("updating language...")
 		lang = self["languages"].getCurrent()[0]
 		if lang != config.osd.language.value:
 			config.osd.language.value = lang
@@ -69,7 +69,7 @@
 		return lang
 
 	def commit(self, lang):
-		print "commit language"
+		print("commit language")
 		language.activateLanguage(lang)
 		config.misc.languageselected.value = 0
 		config.misc.languageselected.save()
--- enigma2-nightly.org/lib/python/Screens/LocationBox.py
+++ enigma2-nightly.patched/lib/python/Screens/LocationBox.py
@@ -57,7 +57,7 @@
 		HelpableScreen.__init__(self)
 
 		# Set useable chars
-		self.setUseableChars(u'1234567890abcdefghijklmnopqrstuvwxyz')
+		self.setUseableChars('1234567890abcdefghijklmnopqrstuvwxyz')
 
 		# Quickselect Timer
 		self.qs_timer = eTimer()
@@ -453,7 +453,7 @@
 
 		# Get char and append to text
 		char = self.getKey(number)
-		self.quickselect = self.quickselect[:self.curr_pos] + unicode(char)
+		self.quickselect = self.quickselect[:self.curr_pos] + str(char)
 
 		# Start Timeout
 		self.qs_timer_type = 0
--- enigma2-nightly.org/lib/python/Screens/Menu.py
+++ enigma2-nightly.patched/lib/python/Screens/Menu.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.Sources.List import List
 from Components.ActionMap import NumberActionMap
 from Components.Sources.StaticText import StaticText
@@ -36,7 +36,7 @@
 		self.updatedMenuItems[id].remove([text, pos, module, screen, weight])
 	
 	def updatedMenuAvailable(self, id):
-		return self.updatedMenuItems.has_key(id)
+		return id in self.updatedMenuItems
 	
 	def getUpdatedMenu(self, id):
 		return self.updatedMenuItems[id]
@@ -50,13 +50,13 @@
 	ALLOW_SUSPEND = True
 
 	def okbuttonClick(self):
-		print "okbuttonClick"
+		print("okbuttonClick")
 		selection = self["menu"].getCurrent()
 		if selection is not None:
 			selection[1]()
 
 	def execText(self, text):
-		exec text
+		exec(text)
 
 	def runScreen(self, arg):
 		# arg[0] is the module (as string)
@@ -66,7 +66,7 @@
 		#        stuff which is just imported)
 		# FIXME. somehow
 		if arg[0] != "":
-			exec "from " + arg[0] + " import *"
+			exec("from " + arg[0] + " import *")
 
 		self.openDialog(*eval(arg[1]))
 
@@ -125,7 +125,7 @@
 				if screen is None:
 					screen = module
 
-				print module, screen
+				print(module, screen)
 				if module:
 					module = "Screens." + module
 				else:
@@ -227,7 +227,7 @@
 		self.menu_title = a
 
 	def keyNumberGlobal(self, number):
-		print "menu keyNumber:", number
+		print("menu keyNumber:", number)
 		# Calculate index
 		number -= 1
 
--- enigma2-nightly.org/lib/python/Screens/MessageBox.py
+++ enigma2-nightly.patched/lib/python/Screens/MessageBox.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import ActionMap
 from Components.Label import Label
 from Components.Pixmap import Pixmap
@@ -112,7 +112,7 @@
 				self.timeoutCallback()
 
 	def timeoutCallback(self):
-		print "Timeout!"
+		print("Timeout!")
 		self.ok()
 
 	def cancel(self):
--- enigma2-nightly.org/lib/python/Screens/MinuteInput.py
+++ enigma2-nightly.patched/lib/python/Screens/MinuteInput.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import NumberActionMap
 from Components.Input import Input
 
--- enigma2-nightly.org/lib/python/Screens/MovieSelection.py
+++ enigma2-nightly.patched/lib/python/Screens/MovieSelection.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.Button import Button
 from Components.ActionMap import HelpableActionMap, ActionMap, NumberActionMap
 from Components.MenuList import MenuList
@@ -32,7 +32,7 @@
 from enigma import eServiceReference, eServiceCenter, eTimer, eSize, iPlayableService, iServiceInformation, getPrevAsciiCode, eRCInput
 import os
 import time
-import cPickle as pickle
+import pickle as pickle
 
 config.movielist = ConfigSubsection()
 config.movielist.moviesort = ConfigInteger(default=MovieList.SORT_RECORDED)
@@ -80,9 +80,9 @@
 	global preferredTagEditor
 	if preferredTagEditor is None:
 		preferredTagEditor = te
-		print "Preferred tag editor changed to", preferredTagEditor
+		print("Preferred tag editor changed to", preferredTagEditor)
 	else:
-		print "Preferred tag editor already set to", preferredTagEditor, "ignoring", te
+		print("Preferred tag editor already set to", preferredTagEditor, "ignoring", te)
 
 def getPreferredTagEditor():
 	global preferredTagEditor
@@ -141,7 +141,7 @@
 	srcPath, srcName = os.path.split(src)
 	if os.path.normpath(srcPath) == dest:
 		# move file to itself is allowed, so we have to check it
-		raise Exception, "Refusing to move to the same directory"
+		raise Exception("Refusing to move to the same directory")
 	# Make a list of items to move
 	moveList = [(src, os.path.join(dest, srcName))]
 	if not serviceref.flags & eServiceReference.mustDescent:
@@ -167,25 +167,25 @@
 			for item in moveList:
 				os.rename(item[0], item[1])
 				movedList.append(item)
-		except OSError, e:
+		except OSError as e:
 			if e.errno == 18 and allowCopy:
-				print "[MovieSelection] cannot rename across devices, trying slow move"
-				import CopyFiles
+				print("[MovieSelection] cannot rename across devices, trying slow move")
+				from . import CopyFiles
 				# start with the smaller files, do the big one later.
 				moveList.reverse()
 				if name is None:
 					name = os.path.split(moveList[-1][0])[1]
 				CopyFiles.moveFiles(moveList, name)
-				print "[MovieSelection] Moving in background..."
+				print("[MovieSelection] Moving in background...")
 			else:
 				raise
-	except Exception, e:
-		print "[MovieSelection] Failed move:", e
+	except Exception as e:
+		print("[MovieSelection] Failed move:", e)
 		for item in movedList:
 			try:
 				os.rename(item[1], item[0])
 			except:
-				print "[MovieSelection] Failed to undo move:", item
+				print("[MovieSelection] Failed to undo move:", item)
 		# rethrow exception
 		raise
 
@@ -200,21 +200,21 @@
 			movedList.append(item)
 		# this worked, we're done
 		return
-	except Exception, e:
-		print "[MovieSelection] Failed copy using link:", e
+	except Exception as e:
+		print("[MovieSelection] Failed copy using link:", e)
 		for item in movedList:
 			try:
 				os.unlink(item[1])
 			except:
-				print "[MovieSelection] Failed to undo copy:", item
+				print("[MovieSelection] Failed to undo copy:", item)
 	#Link failed, really copy.
-	import CopyFiles
+	from . import CopyFiles
 	# start with the smaller files, do the big one later.
 	moveList.reverse()
 	if name is None:
 		name = os.path.split(moveList[-1][0])[1]
 	CopyFiles.copyFiles(moveList, name)
-	print "[MovieSelection] Copying in background..."
+	print("[MovieSelection] Copying in background...")
 
 class MovieBrowserConfiguration(ConfigListScreen,Screen):
 	skin = """
@@ -695,7 +695,7 @@
 			self.list.moveToChar(charstr[0], self["chosenletter"])
 
 	def keyAsciiCode(self):
-		unichar = unichr(getPrevAsciiCode())
+		unichar = chr(getPrevAsciiCode())
 		charstr = unichar.encode("utf-8")
 		if len(charstr) == 1:
 			self.list.moveToString(charstr[0], self["chosenletter"])
@@ -749,8 +749,8 @@
 	def __onClose(self):
 		try:
 			NavigationInstance.instance.RecordTimer.on_state_change.remove(self.list.updateRecordings)
-		except Exception, e:
-			print "[ML] failed to unsubscribe:", e
+		except Exception as e:
+			print("[ML] failed to unsubscribe:", e)
 			pass
 
 	def createSummary(self):
@@ -838,8 +838,8 @@
 				path = os.path.split(path.rstrip('/'))[0]
 			self.session.open(DVD.DVDPlayer, dvd_filelist=[path])
 			return True
-		except Exception, e:
-			print "[ML] DVD Player not installed:", e
+		except Exception as e:
+			print("[ML] DVD Player not installed:", e)
 
 	def __serviceStarted(self):
 		if not self.list.playInBackground:
@@ -889,7 +889,7 @@
 	def __evEOF(self):
 		playInBackground = self.list.playInBackground
 		if not playInBackground:
-			print "Not playing anything in background"
+			print("Not playing anything in background")
 			return
 		current = self.getCurrent()
 		self.session.nav.stopService()
@@ -899,11 +899,11 @@
 				self["list"].moveDown()
 				next = self.getCurrent()
 				if not next or (next == current):
-					print "End of list"
+					print("End of list")
 					return # don't loop the last item
 				path = next.getPath()
 				ext = os.path.splitext(path)[1].lower()
-				print "Next up:", path
+				print("Next up:", path)
 				if ext in AUDIO_EXTENSIONS:
 					self.callLater(self.preview)
 
@@ -973,8 +973,8 @@
 							if os.path.splitext(p)[1].lower() in IMAGE_EXTENSIONS:
 							        filelist.append(((p,False), None))
 						self.session.open(ui.Pic_Full_View, filelist, index, path)
-					except Exception, ex:
-					        print "[ML] Cannot display", str(ex)
+					except Exception as ex:
+					        print("[ML] Cannot display", str(ex))
 					return
 				self.movieSelected()
 
@@ -998,8 +998,8 @@
 		try:
 			path = os.path.join(config.movielist.last_videodir.value, ".e2settings.pkl")
 			pickle.dump(self.settings, open(path, "wb"))
-		except Exception, e:
-			print "Failed to save settings to %s: %s" % (path, e)
+		except Exception as e:
+			print("Failed to save settings to %s: %s" % (path, e))
 		# Also set config items, in case the user has a read-only disk
 		config.movielist.moviesort.value = self.settings["moviesort"]
 		config.movielist.listtype.value = self.settings["listtype"]
@@ -1013,7 +1013,7 @@
 				path = os.path.join(config.movielist.last_videodir.value, ".e2settings.pkl")
 				updates = pickle.load(open(path, "rb"))
 				self.applyConfigSettings(updates)
-			except IOError, e:
+			except IOError as e:
 				updates = {
 					"listtype": config.movielist.listtype.default,
 					"moviesort": config.movielist.moviesort.default,
@@ -1022,8 +1022,8 @@
 				}
 				self.applyConfigSettings(updates)
 				pass # ignore fail to open errors
-			except Exception, e:
-				print "Failed to load settings from %s: %s" % (path, e)
+			except Exception as e:
+				print("Failed to load settings from %s: %s" % (path, e))
 		else:
 			updates = {
 				"listtype": config.movielist.listtype.value,
@@ -1335,14 +1335,14 @@
 			if not path.endswith('/'):
 				path += '/'
 			self.reloadList(sel = eServiceReference("2:0:1:0:0:0:0:0:0:0:" + path))
-		except OSError, e:
-			print "Error %s:" % e.errno, e
+		except OSError as e:
+			print("Error %s:" % e.errno, e)
 			if e.errno == 17:
 				msg = _("The path %s already exists.") % name
 			else:
 				msg = _("Error") + '\n' + str(e)
-		except Exception, e:
-			print "[ML] Unexpected error:", e
+		except Exception as e:
+			print("[ML] Unexpected error:", e)
 			msg = _("Error") + '\n' + str(e)
 		if msg:
 			self.session.open(MessageBox, msg, type = MessageBox.TYPE_ERROR, timeout = 5)
@@ -1408,18 +1408,18 @@
 				pathname,filename = os.path.split(path)
 				newpath = os.path.join(pathname, name)
 				msg = None
-				print "[ML] rename", path, "to", newpath
+				print("[ML] rename", path, "to", newpath)
 				os.rename(path, newpath)
 				self.reloadList(sel = eServiceReference("2:0:1:0:0:0:0:0:0:0:" + newpath))
-			except OSError, e:
-				print "Error %s:" % e.errno, e
+			except OSError as e:
+				print("Error %s:" % e.errno, e)
 				if e.errno == 17:
 					msg = _("The path %s already exists.") % name
 				else:
 					msg = _("Error") + '\n' + str(e)
-			except Exception, e:
+			except Exception as e:
 				import traceback
-				print "[ML] Unexpected error:", e
+				print("[ML] Unexpected error:", e)
 				traceback.print_exc()
 				msg = _("Error") + '\n' + str(e)
 			if msg:
@@ -1455,8 +1455,8 @@
 						if os.path.isdir(d) and (d not in inlist):
 							bookmarks.append((fn,d))
 							inlist.append(d)
-			except Exception, e :
-				print "[MovieSelection]", e
+			except Exception as e :
+				print("[MovieSelection]", e)
 			# Last favourites
 			for d in last_selected_dest:
 				if d not in inlist:
@@ -1488,7 +1488,7 @@
 				name = item[1].getName(current)
 			moveServiceFiles(current, dest, name)
 			self["list"].removeService(current)
-		except Exception, e:
+		except Exception as e:
 			self.session.open(MessageBox, str(e), MessageBox.TYPE_ERROR)
 
 	def can_copy(self, item):
@@ -1516,7 +1516,7 @@
 			else:
 				name = item[1].getName(current)
 			copyServiceFiles(current, dest, name)
-		except Exception, e:
+		except Exception as e:
 			self.session.open(MessageBox, str(e), MessageBox.TYPE_ERROR)
 
 	def stopTimer(self, timer):
@@ -1577,30 +1577,30 @@
 						for root, dirnames, filenames in os.walk(cur_path):
 							trashroot = os.path.join(trash, root[len(cur_path)+1:])
 							for fn in filenames:
-								print "Move %s -> %s" % (os.path.join(root, fn), os.path.join(trashroot, fn))
+								print("Move %s -> %s" % (os.path.join(root, fn), os.path.join(trashroot, fn)))
 								os.rename(os.path.join(root, fn), os.path.join(trashroot, fn))
 							for dn in dirnames:
-								print "MkDir", os.path.join(trashroot, dn)
+								print("MkDir", os.path.join(trashroot, dn))
 								os.mkdir(os.path.join(trashroot, dn))
 						# second pass to remove the empty directories
 						for root, dirnames, filenames in os.walk(cur_path, topdown=False):
 							for dn in dirnames:
-								print "rmdir", os.path.join(trashroot, dn)
+								print("rmdir", os.path.join(trashroot, dn))
 								os.rmdir(os.path.join(root, dn))
 						os.rmdir(cur_path)
 						self["list"].removeService(current)
 						self.showActionFeedback(_("Deleted") + " " + name)
 						# Files were moved to .Trash, ok.
 						return
-					except OSError, e:
-						print "[MovieSelection] Cannot move to trash", e
+					except OSError as e:
+						print("[MovieSelection] Cannot move to trash", e)
 						if e.errno == 18:
 							# This occurs when moving across devices
 							msg = _("Cannot move files on a different disk or system to the trash can") + ". "
 						else:
 							msg = _("Cannot move to trash can") + ".\n" + str(e) + "\n"
-					except Exception, e:
-						print "[MovieSelection] Weird error moving to trash", e
+					except Exception as e:
+						print("[MovieSelection] Weird error moving to trash", e)
 						# Failed to create trash or move files.
 						msg = _("Cannot move to trash can") + "\n" + str(e) + "\n"
 				msg += _("Sorry, deleting directories can (for now) only be done through the trash can.")
@@ -1626,8 +1626,8 @@
 			else:
 				try:
 					os.rmdir(cur_path)
-				except Exception, e:
-					print "[MovieSelection] Failed delete", e
+				except Exception as e:
+					print("[MovieSelection] Failed delete", e)
 					self.session.open(MessageBox, _("Delete failed!") + "\n" + str(e), MessageBox.TYPE_ERROR)
 				else:
 					self["list"].removeService(current)
@@ -1662,15 +1662,15 @@
 						delResumePoint(current)
 						self.showActionFeedback(_("Deleted") + " " + name)
 						return
-				except OSError, e:
-					print "[MovieSelection] Cannot move to trash", e
+				except OSError as e:
+					print("[MovieSelection] Cannot move to trash", e)
 					if e.errno == 18:
 						# This occurs when moving across devices
 						msg = _("Cannot move files on a different disk or system to the trash can") + ". "
 					else:
 						msg = _("Cannot move to trash can") + ".\n" + str(e) + "\n"
-				except Exception, e:
-					print "[MovieSelection] Weird error moving to trash", e
+				except Exception as e:
+					print("[MovieSelection] Weird error moving to trash", e)
 					# Failed to create trash or move files.
 					msg = _("Cannot move to trash can") + "\n" + str(e) + "\n"
 			else:
@@ -1694,12 +1694,12 @@
 			        eBackgroundFileEraser.getInstance().erase(os.path.realpath(current.getPath()))
 			else:
 				if offline.deleteFromDisk(0):
-					raise Exception, "Offline delete failed"
+					raise Exception("Offline delete failed")
 			self["list"].removeService(current)
 			from Screens.InfoBarGenerics import delResumePoint
 			delResumePoint(current)
 			self.showActionFeedback(_("Deleted") + " " + name)
-		except Exception, ex:
+		except Exception as ex:
 			self.session.open(MessageBox, _("Delete failed!") + "\n" + name + "\n" + str(ex), MessageBox.TYPE_ERROR)
 
 
@@ -1722,7 +1722,7 @@
 		Tools.Trashcan.cleanAll(cur_path)
 
 	def showNetworkSetup(self):
-		import NetworkSetup
+		from . import NetworkSetup
 		self.session.open(NetworkSetup.NetworkAdapterSelection)
 
 	def showActionFeedback(self, text):
@@ -1735,7 +1735,7 @@
 		self.diskinfo.setText(text)
 
 	def hideActionFeedback(self):
-		print "[ML] hide feedback"
+		print("[ML] hide feedback")
 		self.diskinfo.update()
 
 	def can_gohome(self, item):
--- enigma2-nightly.org/lib/python/Screens/Mute.py
+++ enigma2-nightly.patched/lib/python/Screens/Mute.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 
 class Mute(Screen):
 	pass
--- enigma2-nightly.org/lib/python/Screens/NetworkSetup.py
+++ enigma2-nightly.patched/lib/python/Screens/NetworkSetup.py
@@ -218,7 +218,7 @@
 		Screen.__init__(self, session)
 		HelpableScreen.__init__(self)
 		self.backupNameserverList = iNetwork.getNameserverList()[:]
-		print "backup-list:", self.backupNameserverList
+		print("backup-list:", self.backupNameserverList)
 		
 		self["key_red"] = StaticText(_("Cancel"))
 		self["key_green"] = StaticText(_("Add"))
@@ -276,7 +276,7 @@
 
 	def cancel(self):
 		iNetwork.clearNameservers()
-		print "backup-list:", self.backupNameserverList
+		print("backup-list:", self.backupNameserverList)
 		for nameserver in self.backupNameserverList:
 			iNetwork.addNameserver(nameserver)
 		self.close()
@@ -287,7 +287,7 @@
 		self.createSetup()
 
 	def remove(self):
-		print "currentIndex:", self["config"].getCurrentIndex()
+		print("currentIndex:", self["config"].getCurrentIndex())
 		index = self["config"].getCurrentIndex()
 		if index < len(self.nameservers):
 			iNetwork.removeNameserver(self.nameservers[index])
@@ -463,9 +463,9 @@
 			for p in plugins.getPlugins(PluginDescriptor.WHERE_NETWORKSETUP):
 				callFnc = p.__call__["ifaceSupported"](self.iface)
 				if callFnc is not None:
-					if p.__call__.has_key("WlanPluginEntry"): # internally used only for WLAN Plugin
+					if "WlanPluginEntry" in p.__call__: # internally used only for WLAN Plugin
 						self.extended = callFnc
-						if p.__call__.has_key("configStrings"):
+						if "configStrings" in p.__call__:
 							self.configStrings = p.__call__["configStrings"]
 
 						self.hiddenSSID = getConfigListEntry(_("Hidden network"), config.plugins.wlan.hiddenessid)
@@ -716,11 +716,12 @@
 			try:
 				ifobj = Wireless(iface) # a Wireless NIC Object
 				wlanresponse = ifobj.getAPaddr()
-			except IOError, (error_no, error_str):
+			except IOError as xxx_todo_changeme:
+				(error_no, error_str) = xxx_todo_changeme.args
 				if error_no in (errno.EOPNOTSUPP, errno.ENODEV, errno.EPERM):
 					return False
 				else:
-					print "error: ",error_no,error_str
+					print("error: ",error_no,error_str)
 					return True
 			else:
 				return True
@@ -846,16 +847,16 @@
 			callFnc = p.__call__["ifaceSupported"](self.iface)
 			if callFnc is not None:
 				self.extended = callFnc
-				if p.__call__.has_key("WlanPluginEntry"): # internally used only for WLAN Plugin
+				if "WlanPluginEntry" in p.__call__: # internally used only for WLAN Plugin
 					menu.append((_("Scan wireless networks"), "scanwlan"))
 					if iNetwork.getAdapterAttribute(self.iface, "up"):
 						menu.append((_("Show WLAN status"), "wlanstatus"))
 				else:
-					if p.__call__.has_key("menuEntryName"):
+					if "menuEntryName" in p.__call__:
 						menuEntryName = p.__call__["menuEntryName"](self.iface)
 					else:
 						menuEntryName = _('Extended setup...')
-					if p.__call__.has_key("menuEntryDescription"):
+					if "menuEntryDescription" in p.__call__:
 						menuEntryDescription = p.__call__["menuEntryDescription"](self.iface)
 					else:
 						menuEntryDescription = _('Extended network setup plugin...')
--- enigma2-nightly.org/lib/python/Screens/NumericalTextInputHelpDialog.py
+++ enigma2-nightly.patched/lib/python/Screens/NumericalTextInputHelpDialog.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.Label import Label
 
 class NumericalTextInputHelpDialog(Screen):
--- enigma2-nightly.org/lib/python/Screens/PVRState.py
+++ enigma2-nightly.patched/lib/python/Screens/PVRState.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 
 from Components.Label import Label
 
--- enigma2-nightly.org/lib/python/Screens/ParentalControlSetup.py
+++ enigma2-nightly.patched/lib/python/Screens/ParentalControlSetup.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ConfigList import ConfigListScreen
 from Components.ActionMap import NumberActionMap
 from Components.config import config, getConfigListEntry, ConfigNothing, NoSave, ConfigPIN
@@ -72,7 +72,7 @@
 		
 		self.list = []
 		self.list.append(getConfigListEntry(_("Enable parental control"), config.ParentalControl.configured))
-		print "config.ParentalControl.configured.value", config.ParentalControl.configured.value
+		print("config.ParentalControl.configured.value", config.ParentalControl.configured.value)
 		self.editBouquetListEntry = -1
 		self.reloadLists = -1
 		if config.ParentalControl.configured.value:
@@ -105,7 +105,7 @@
 		self["config"].setList(self.list)
 
 	def keyOK(self):
-		print "self[\"config\"].l.getCurrentSelection()", self["config"].l.getCurrentSelection()
+		print("self[\"config\"].l.getCurrentSelection()", self["config"].l.getCurrentSelection())
 		if self["config"].l.getCurrentSelection() == self.editListEntry:
 			self.session.open(ParentalControlEditor)
 		elif self["config"].l.getCurrentSelection() == self.editBouquetListEntry:
@@ -122,17 +122,17 @@
 			parentalControl.open()
 		else:
 			ConfigListScreen.keyRight(self)
-			print "current selection:", self["config"].l.getCurrentSelection()
+			print("current selection:", self["config"].l.getCurrentSelection())
 			self.createSetup()
 
 	def keyLeft(self):
 		ConfigListScreen.keyLeft(self)
-		print "current selection:", self["config"].l.getCurrentSelection()
+		print("current selection:", self["config"].l.getCurrentSelection())
 		self.createSetup()
 
 	def keyRight(self):
 		ConfigListScreen.keyRight(self)
-		print "current selection:", self["config"].l.getCurrentSelection()
+		print("current selection:", self["config"].l.getCurrentSelection())
 		self.createSetup()
 
 	def SetupPinMessageCallback(self, value):
@@ -237,14 +237,14 @@
 				if key < 'a' or key > 'z':
 					key = chr(SPECIAL_CHAR)
 				#key = str(key)
-				if not self.servicesList.has_key(key):
+				if key not in self.servicesList:
 					self.servicesList[key] = []
 				self.servicesList[key].append(s)
 			
 	def chooseLetter(self):
-		print "choose letter"
+		print("choose letter")
 		mylist = []
-		for x in self.servicesList.keys():
+		for x in list(self.servicesList.keys()):
 			if x == chr(SPECIAL_CHAR):
 				x = (_("special characters"), x)
 			else:
@@ -257,7 +257,7 @@
 	def letterChosen(self, result):
 		from Components.ParentalControl import parentalControl
 		if result is not None:
-			print "result:", result
+			print("result:", result)
 			self.currentLetter = result[1]
 			#Replace getProtectionLevel by new getProtectionType
 			self.list = [ParentalControlEntryComponent(x[0], x[1], parentalControl.getProtectionType(x[0])) for x in self.servicesList[result[1]]]
--- enigma2-nightly.org/lib/python/Screens/PluginBrowser.py
+++ enigma2-nightly.patched/lib/python/Screens/PluginBrowser.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.Language import language
 from enigma import eConsoleAppContainer, eDVBDB
 
@@ -304,8 +304,8 @@
 		if hasattr(self, 'postInstallCall'):
 			try:
 				self.postInstallCall()
-			except Exception, ex:
-				print "[PluginBrowser] postInstallCall failed:", ex
+			except Exception as ex:
+				print("[PluginBrowser] postInstallCall failed:", ex)
 			self.resetPostInstall()
 		try:
 			os.unlink('/tmp/opkg.conf')
@@ -397,12 +397,12 @@
 			split = x[3].split('-', 1)
 			if len(split) < 2:
 				continue
-			if not self.plugins.has_key(split[0]):
+			if split[0] not in self.plugins:
 				self.plugins[split[0]] = []
 
 			self.plugins[split[0]].append((PluginDescriptor(name = x[3], description = x[2], icon = verticallineIcon), split[1], x[1]))
 
-		for x in self.plugins.keys():
+		for x in list(self.plugins.keys()):
 			if x in self.expanded:
 				list.append(PluginCategoryComponent(x, expandedIcon, self.listWidth))
 				list.extend([PluginDownloadComponent(plugin[0], plugin[1], plugin[2], self.listWidth) for plugin in self.plugins[x]])
--- enigma2-nightly.org/lib/python/Screens/Rc.py
+++ enigma2-nightly.patched/lib/python/Screens/Rc.py
@@ -67,7 +67,7 @@
 			rc = self.rcs[config.misc.rcused.value]
 		else:
 			rc = self.rcs[2]
-		if rc.has_key(key):
+		if key in rc:
 			rcpos = self["rc"].getPosition()
 			pos = rc[key]
 			selectPics = self.getSelectPic(pos)
@@ -77,7 +77,7 @@
 					selectPic = x
 					break
 			if selectPic is not None:
-				print "selectPic:", selectPic
+				print("selectPic:", selectPic)
 				self[selectPic].moveTo(rcpos[0] + pos[0] + selectPics[1][0], rcpos[1] + pos[1] + selectPics[1][1], 1)
 				self[selectPic].startMoving()
 				self[selectPic].show()
--- enigma2-nightly.org/lib/python/Screens/RdsDisplay.py
+++ enigma2-nightly.patched/lib/python/Screens/RdsDisplay.py
@@ -160,7 +160,7 @@
 		service = self.session.nav.getCurrentService()
 		decoder = service and service.rdsDecoder()
 		if not decoder: # this should never happen
-			print "NO RDS DECODER in showRassPage"
+			print("NO RDS DECODER in showRassPage")
 		else:
 			mask = decoder.getRassInteractiveMask()
 			page = 1
@@ -174,7 +174,7 @@
 							subpage.instance.setPixmap(png)
 							subpage.show()
 						else:
-							print "rass png missing"
+							print("rass png missing")
 				else:
 					subpage.hide()
 				page += 1
@@ -186,7 +186,7 @@
 		service = self.session.nav.getCurrentService()
 		decoder = service and service.rdsDecoder()
 		if not decoder: # this should never happen
-			print "NO RDS DECODER in showRassPage"
+			print("NO RDS DECODER in showRassPage")
 		else:
 			decoder.showRassInteractivePic(page, subpage)
 			page_diff = page - self.current_page
@@ -202,7 +202,7 @@
 			service = self.session.nav.getCurrentService()
 			decoder = service and service.rdsDecoder()
 			if not decoder: # this should never happen
-				print "NO RDS DECODER in getMaskForPage"
+				print("NO RDS DECODER in getMaskForPage")
 			masks = decoder.getRassInteractiveMask()
 		if masks:
 			mask = masks[(page*4)/8]
--- enigma2-nightly.org/lib/python/Screens/RecordPaths.py
+++ enigma2-nightly.patched/lib/python/Screens/RecordPaths.py
@@ -37,7 +37,7 @@
 		}, -2)
 
 	def checkReadWriteDir(self, configele):
-		print "checkReadWrite: ", configele.value
+		print("checkReadWrite: ", configele.value)
 		if configele.value in [x[0] for x in self.styles] or fileExists(configele.value, "w"):
 			configele.last_value = configele.value
 			return True
@@ -59,28 +59,28 @@
 		if default not in tmp:
 			tmp = tmp[:]
 			tmp.append(default)
-		print "DefaultPath: ", default, tmp
+		print("DefaultPath: ", default, tmp)
 		self.default_dirname = ConfigSelection(default = default, choices = tmp)
 		tmp = config.movielist.videodirs.value
 		default = config.usage.timer_path.value
 		if default not in tmp and default not in styles_keys:
 			tmp = tmp[:]
 			tmp.append(default)
-		print "TimerPath: ", default, tmp
+		print("TimerPath: ", default, tmp)
 		self.timer_dirname = ConfigSelection(default = default, choices = self.styles+tmp)
 		tmp = config.movielist.videodirs.value
 		default = config.usage.instantrec_path.value
 		if default not in tmp and default not in styles_keys:
 			tmp = tmp[:]
 			tmp.append(default)
-		print "InstantrecPath: ", default, tmp
+		print("InstantrecPath: ", default, tmp)
 		self.instantrec_dirname = ConfigSelection(default = default, choices = self.styles+tmp)
 		default = config.usage.timeshift_path.value
 		tmp = config.usage.allowed_timeshift_paths.value
 		if default not in tmp:
 			tmp = tmp[:]
 			tmp.append(default)
-		print "TimeshiftPath: ", default, tmp
+		print("TimeshiftPath: ", default, tmp)
 		self.timeshift_dirname = ConfigSelection(default = default, choices = tmp)
 		self.default_dirname.addNotifier(self.checkReadWriteDir, initial_call=False, immediate_feedback=False)
 		self.timer_dirname.addNotifier(self.checkReadWriteDir, initial_call=False, immediate_feedback=False)
--- enigma2-nightly.org/lib/python/Screens/Satconfig.py
+++ enigma2-nightly.patched/lib/python/Screens/Satconfig.py
@@ -1,5 +1,5 @@
 from enigma import eDVBDB
-from Screen import Screen
+from .Screen import Screen
 from Components.SystemInfo import SystemInfo
 from Components.ActionMap import ActionMap
 from Components.ConfigList import ConfigListScreen
@@ -75,7 +75,7 @@
 			self.nimConfig.configMode.setChoices(choices, default = "simple")
 
 	def createSetup(self):
-		print "Creating setup"
+		print("Creating setup")
 		self.list = [ ]
 
 		self.multiType = None
@@ -131,7 +131,7 @@
 				self.list.append(getConfigListEntry(_("Tuner"), self.nimConfig.connectedTo))
 			elif self.nimConfig.configMode.value == "loopthrough":
 				choices = []
-				print "connectable to:", nimmanager.canConnectTo(self.slotid)
+				print("connectable to:", nimmanager.canConnectTo(self.slotid))
 				connectable = nimmanager.canConnectTo(self.slotid)
 				for id in connectable:
 					choices.append((str(id), nimmanager.getNimDescription(id)))
@@ -144,7 +144,7 @@
 				self.advancedSatsEntry = getConfigListEntry(_("Satellite"), self.nimConfig.advanced.sats)
 				self.list.append(self.advancedSatsEntry)
 				cur_orb_pos = self.nimConfig.advanced.sats.orbital_position
-				satlist = self.nimConfig.advanced.sat.keys()
+				satlist = list(self.nimConfig.advanced.sat.keys())
 				if cur_orb_pos is not None:
 					if cur_orb_pos not in satlist:
 						cur_orb_pos = satlist[0]
@@ -387,7 +387,7 @@
 		self.list.append(self.configMode)
 		self.advancedSatsEntry = getConfigListEntry(_("Satellite"), self.nimConfig.advanced.sats)
 		self.list.append(self.advancedSatsEntry)
-		for x in self.nimConfig.advanced.sat.keys():
+		for x in list(self.nimConfig.advanced.sat.keys()):
 			Sat = self.nimConfig.advanced.sat[x]
 			self.fillListWithAdvancedSatEntrys(Sat)
 		self["config"].list = self.list
@@ -577,7 +577,7 @@
 					elif nimConfig.configMode.value == "enabled":
 						text = _("enabled")
 				if x.isMultiType():
-					text = _("Switchable tuner types:") + "(" + ','.join(x.getMultiTypeList().values()) + ")" + "\n" + text
+					text = _("Switchable tuner types:") + "(" + ','.join(list(x.getMultiTypeList().values())) + ")" + "\n" + text
 				if not x.isSupported():
 					text = _("tuner is not supported")
 
--- enigma2-nightly.org/lib/python/Screens/ScanSetup.py
+++ enigma2-nightly.patched/lib/python/Screens/ScanSetup.py
@@ -1,5 +1,5 @@
-from Screen import Screen
-from ServiceScan import ServiceScan
+from .Screen import Screen
+from .ServiceScan import ServiceScan
 from Components.config import config, ConfigSubsection, ConfigSelection, \
 	ConfigYesNo, ConfigInteger, getConfigListEntry, ConfigSlider, ConfigEnableDisable
 from Components.ActionMap import NumberActionMap, ActionMap
@@ -110,7 +110,7 @@
 		return False
 
 	def cableTransponderSearchSessionClosed(self, *val):
-		print "cableTransponderSearchSessionClosed, val", val
+		print("cableTransponderSearchSessionClosed, val", val)
 		self.cable_search_container.appClosed.remove(self.cableTransponderSearchClosed)
 		self.cable_search_container.dataAvail.remove(self.getCableTransponderData)
 		if val and len(val):
@@ -125,7 +125,7 @@
 		self.cableTransponderSearchFinished()
 
 	def cableTransponderSearchClosed(self, retval):
-		print "cableTransponderSearch finished", retval
+		print("cableTransponderSearch finished", retval)
 		self.cable_search_session.close(True)
 
 	def getCableTransponderData(self, str):
@@ -145,7 +145,7 @@
 			data = line.split()
 			if len(data):
 				if data[0] == 'OK':
-					print str
+					print(str)
 					parm = eDVBFrontendParametersCable()
 					qam = { "QAM16" : parm.Modulation_QAM16,
 						"QAM32" : parm.Modulation_QAM32,
@@ -196,7 +196,7 @@
 		try:
 			bus = nimmanager.getI2CDevice(nim_idx)
 			if bus is None:
-				print "ERROR: could not get I2C device for nim", nim_idx, "for cable transponder search"
+				print("ERROR: could not get I2C device for nim", nim_idx, "for cable transponder search")
 				bus = 2
 		except:
 			# older API
@@ -271,7 +271,7 @@
 			cmd += " --sr "
 			cmd += str(cableConfig.scan_sr_ext2.value)
 			cmd += "000"
-		print "TDA1002x CMD is", cmd
+		print("TDA1002x CMD is", cmd)
 
 		self.cable_search_container.execute(cmd)
 		tmpstr = _("Try to find used transponders in cable network.. please wait...")
@@ -335,7 +335,7 @@
 		self.list = []
 		self.multiscanlist = []
 		index_to_scan = int(self.scan_nims.value)
-		print "ID: ", index_to_scan
+		print("ID: ", index_to_scan)
 
 		self.tunerEntry = getConfigListEntry(_("Tuner"), self.scan_nims)
 		self.list.append(self.tunerEntry)
@@ -382,7 +382,7 @@
 					self.list.append(getConfigListEntry(_('Pilot'), self.scan_sat.pilot))
 			elif self.scan_type.value == "single_satellite":
 				self.updateSatList()
-				print self.scan_satselection[index_to_scan]
+				print(self.scan_satselection[index_to_scan])
 				self.list.append(getConfigListEntry(_("Satellite"), self.scan_satselection[index_to_scan]))
 				self.scan_networkScan.value = True
 			elif self.scan_type.value.find("multisat") != -1:
@@ -431,7 +431,7 @@
 
 	def newConfig(self):
 		cur = self["config"].getCurrent()
-		print "cur is", cur
+		print("cur is", cur)
 		if cur == self.typeOfScanEntry or \
 			cur == self.tunerEntry or \
 			cur == self.systemEntry or \
@@ -694,11 +694,11 @@
 		self.newConfig()
 
 	def updateStatus(self):
-		print "updatestatus"
+		print("updatestatus")
 
 	def addSatTransponder(self, tlist, frequency, symbol_rate, polarisation, fec, inversion, orbital_position, system, modulation, rolloff, pilot):
-		print "Add Sat: frequ: " + str(frequency) + " symbol: " + str(symbol_rate) + " pol: " + str(polarisation) + " fec: " + str(fec) + " inversion: " + str(inversion) + " modulation: " + str(modulation) + " system: " + str(system) + " rolloff" + str(rolloff) + " pilot" + str(pilot)
-		print "orbpos: " + str(orbital_position)
+		print("Add Sat: frequ: " + str(frequency) + " symbol: " + str(symbol_rate) + " pol: " + str(polarisation) + " fec: " + str(fec) + " inversion: " + str(inversion) + " modulation: " + str(modulation) + " system: " + str(system) + " rolloff" + str(rolloff) + " pilot" + str(pilot))
+		print("orbpos: " + str(orbital_position))
 		parm = eDVBFrontendParametersSatellite()
 		parm.modulation = modulation
 		parm.system = system
@@ -713,7 +713,7 @@
 		tlist.append(parm)
 
 	def addCabTransponder(self, tlist, frequency, symbol_rate, modulation, fec, inversion):
-		print "Add Cab: frequ: " + str(frequency) + " symbol: " + str(symbol_rate) + " pol: " + str(modulation) + " fec: " + str(fec) + " inversion: " + str(inversion)
+		print("Add Cab: frequ: " + str(frequency) + " symbol: " + str(symbol_rate) + " pol: " + str(modulation) + " fec: " + str(fec) + " inversion: " + str(inversion))
 		parm = eDVBFrontendParametersCable()
 		parm.frequency = frequency * 1000
 		parm.symbol_rate = symbol_rate * 1000
@@ -739,9 +739,9 @@
 			return
 
 		nim = nimmanager.nim_slots[index_to_scan]
-		print "nim", nim.slot
+		print("nim", nim.slot)
 		if nim.isCompatible("DVB-S"):
-			print "is compatible with DVB-S"
+			print("is compatible with DVB-S")
 			if self.scan_type.value == "single_transponder":
 				# these lists are generated for each tuner, so this has work.
 				assert len(self.satList) > index_to_scan
@@ -757,7 +757,7 @@
 						fec = self.scan_sat.fec.value
 					else:
 						fec = self.scan_sat.fec_s2.value
-					print "add sat transponder"
+					print("add sat transponder")
 					self.addSatTransponder(tlist, self.scan_sat.frequency.value,
 								self.scan_sat.symbolrate.value,
 								self.scan_sat.polarization.value,
@@ -776,7 +776,7 @@
 				SatList = nimmanager.getSatListForNim(index_to_scan)
 				for x in self.multiscanlist:
 					if x[1].value:
-						print "   " + str(x[0])
+						print("   " + str(x[0]))
 						getInitialTransponderList(tlist, x[0])
 
 		elif nim.isCompatible("DVB-C"):
@@ -903,15 +903,15 @@
 			need_scan = False
 			networks = self.getNetworksForNim(nim)
 
-			print "nim %d provides" % nim.slot, networks
-			print "known:", known_networks
+			print("nim %d provides" % nim.slot, networks)
+			print("known:", known_networks)
 
 			# we only need to scan on the first tuner which provides a network.
 			# this gives the first tuner for each network priority for scanning.
 			for x in networks:
 				if x not in known_networks:
 					need_scan = True
-					print x, "not in ", known_networks
+					print(x, "not in ", known_networks)
 					known_networks.append(x)
 
 			# don't offer to scan nims if nothing is connected
--- enigma2-nightly.org/lib/python/Screens/Screen.py
+++ enigma2-nightly.patched/lib/python/Screens/Screen.py
@@ -11,7 +11,7 @@
 
 class Screen(dict, GUISkin):
 
-	False, SUSPEND_STOPS, SUSPEND_PAUSES = range(3)
+	False, SUSPEND_STOPS, SUSPEND_PAUSES = list(range(3))
 	ALLOW_SUSPEND = False
 
 	global_screen = None
@@ -85,7 +85,7 @@
 #			assert self.session == None, "a screen can only exec once per time"
 #			self.session = session
 
-			for val in self.values() + self.renderer:
+			for val in list(self.values()) + self.renderer:
 				val.execBegin()
 				if not self.stand_alone and self.session.current_dialog != self:
 					return
@@ -124,7 +124,7 @@
 			val.disconnectAll()  # disconnected converter/sources and probably destroy them. Sources will not be destroyed.
 
 		del self.session
-		for (name, val) in self.items():
+		for (name, val) in list(self.items()):
 			val.destroy()
 			del self[name]
 
@@ -150,7 +150,7 @@
 		self.instance.show()
 		for x in self.onShow:
 			x()
-		for val in self.values() + self.renderer:
+		for val in list(self.values()) + self.renderer:
 			if isinstance(val, GUIComponent) or isinstance(val, Source):
 				val.onShow()
 
@@ -161,7 +161,7 @@
 		self.instance.hide()
 		for x in self.onHide:
 			x()
-		for val in self.values() + self.renderer:
+		for val in list(self.values()) + self.renderer:
 			if isinstance(val, GUIComponent) or isinstance(val, Source):
 				val.onHide()
 
--- enigma2-nightly.org/lib/python/Screens/ServiceInfo.py
+++ enigma2-nightly.patched/lib/python/Screens/ServiceInfo.py
@@ -1,6 +1,6 @@
 from Components.HTMLComponent import HTMLComponent
 from Components.GUIComponent import GUIComponent
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import ActionMap
 from Components.Label import Label
 from ServiceReference import ServiceReference
@@ -20,7 +20,7 @@
 	return x & 0xFFFFFFFF
 
 def ServiceInfoListEntry(a, b, valueType=TYPE_TEXT, param=4):
-	print "b:", b
+	print("b:", b)
 	if not isinstance(b, str):
 		if valueType == TYPE_VALUE_HEX:
 			b = ("0x%0" + str(param) + "x") % to_unsigned(b)
@@ -158,7 +158,7 @@
 						 "transmission_mode": _("Transmission mode"),
 						 "guard_interval" 	: _("Guard interval"),
 						 "hierarchy_information": _("Hierarchy information") }
-				Labels = [(conv[i], tp_info[i], i == "orbital_position" and TYPE_VALUE_ORBIT_DEC or TYPE_VALUE_DEC) for i in tp_info.keys() if i in conv]
+				Labels = [(conv[i], tp_info[i], i == "orbital_position" and TYPE_VALUE_ORBIT_DEC or TYPE_VALUE_DEC) for i in list(tp_info.keys()) if i in conv]
 				self.fillList(Labels)
 
 	def pids(self):
--- enigma2-nightly.org/lib/python/Screens/ServiceStopScreen.py
+++ enigma2-nightly.patched/lib/python/Screens/ServiceStopScreen.py
@@ -5,7 +5,7 @@
 		try:
 			self.session
 		except:
-			print "[ServiceStopScreen] ERROR: no self.session set"
+			print("[ServiceStopScreen] ERROR: no self.session set")
 
 		self.oldref = None
 		self.onClose.append(self.__onClose)
--- enigma2-nightly.org/lib/python/Screens/Setup.py
+++ enigma2-nightly.patched/lib/python/Screens/Setup.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import NumberActionMap
 from Components.config import config, ConfigNothing
 from Components.Label import Label
--- enigma2-nightly.org/lib/python/Screens/SoftwareUpdate.py
+++ enigma2-nightly.patched/lib/python/Screens/SoftwareUpdate.py
@@ -7,7 +7,7 @@
 from Components.Sources.StaticText import StaticText
 from Components.Slider import Slider
 from enigma import eTimer, getBoxType, eDVBDB
-from urllib import urlopen
+from urllib.request import urlopen
 import socket
 import os
 import re
@@ -124,7 +124,7 @@
 		if event == IpkgComponent.EVENT_DOWNLOAD:
 			self.status.setText(_("Downloading"))
 		elif event == IpkgComponent.EVENT_UPGRADE:
-			if self.sliderPackages.has_key(param):
+			if param in self.sliderPackages:
 				self.slider.setValue(self.sliderPackages[param])
 			self.package.setText(param)
 			self.status.setText(_("Upgrading") + ": %s/%s" % (self.packages, self.total_packages))
--- enigma2-nightly.org/lib/python/Screens/Standby.py
+++ enigma2-nightly.patched/lib/python/Screens/Standby.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ActionMap import ActionMap
 from Components.config import config
 from Components.AVSwitch import AVSwitch
@@ -11,7 +11,7 @@
 
 class Standby(Screen):
 	def Power(self):
-		print "leave standby"
+		print("leave standby")
 #+++>
 		call("/bin/vdstandby -d &", shell="true")
 #+++<
@@ -26,7 +26,7 @@
 	def setMute(self):
 		if (eDVBVolumecontrol.getInstance().isMuted()):
 			self.wasMuted = 1
-			print "mute already active"
+			print("mute already active")
 		else:
 			self.wasMuted = 0
 			eDVBVolumecontrol.getInstance().volumeToggleMute()
@@ -39,7 +39,7 @@
 		Screen.__init__(self, session)
 		self.avswitch = AVSwitch()
 
-		print "enter standby"
+		print("enter standby")
 
 		self["actions"] = ActionMap( [ "StandbyActions" ],
 		{
--- enigma2-nightly.org/lib/python/Screens/StartWizard.py
+++ enigma2-nightly.patched/lib/python/Screens/StartWizard.py
@@ -1,11 +1,11 @@
-from Wizard import wizardManager
+from .Wizard import wizardManager
 from Screens.WizardLanguage import WizardLanguage
 from Screens.Rc import Rc
 
 from Components.Pixmap import Pixmap, MovingPixmap, MultiPixmap
 from Components.config import config, ConfigBoolean, configfile, ConfigSubsection
 
-from LanguageSelection import LanguageWizard
+from .LanguageSelection import LanguageWizard
 
 config.misc.firstrun = ConfigBoolean(default = True)
 config.misc.languageselected = ConfigBoolean(default = True)
--- enigma2-nightly.org/lib/python/Screens/SubservicesQuickzap.py
+++ enigma2-nightly.patched/lib/python/Screens/SubservicesQuickzap.py
@@ -4,7 +4,7 @@
 
 from Screens.ChoiceBox import ChoiceBox
 from Screens.MessageBox import MessageBox
-from InfoBarGenerics import InfoBarShowHide, InfoBarMenu, InfoBarInstantRecord, InfoBarTimeshift, InfoBarSeek, InfoBarTimeshiftState, InfoBarExtensions, InfoBarSubtitleSupport, InfoBarAudioSelection
+from .InfoBarGenerics import InfoBarShowHide, InfoBarMenu, InfoBarInstantRecord, InfoBarTimeshift, InfoBarSeek, InfoBarTimeshiftState, InfoBarExtensions, InfoBarSubtitleSupport, InfoBarAudioSelection
 from Components.ServiceEventTracker import InfoBarBase
 
 from enigma import eTimer
@@ -94,7 +94,7 @@
 				return x
 	
 	def keyNumberGlobal(self, number):
-		print number, "pressed"
+		print(number, "pressed")
 		self.updateSubservices()
 		if number == 0:
 			self.playSubservice(self.lastservice)
@@ -116,7 +116,7 @@
 		self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a subservice..."), list = tlist, selection = self.currentlyPlayingSubservice, keys = keys)
 	
 	def subserviceSelected(self, service):
-		print "playing subservice number", service
+		print("playing subservice number", service)
 		if service is not None:
 			self.playSubservice(service[1])
 	
--- enigma2-nightly.org/lib/python/Screens/TaskView.py
+++ enigma2-nightly.patched/lib/python/Screens/TaskView.py
@@ -1,9 +1,9 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ConfigList import ConfigListScreen
 from Components.config import config, ConfigSubsection, ConfigSelection, getConfigListEntry
 from Components.SystemInfo import SystemInfo
 from Components.Task import job_manager
-from InfoBarGenerics import InfoBarNotifications
+from .InfoBarGenerics import InfoBarNotifications
 import Screens.Standby
 from Tools import Notifications
 
--- enigma2-nightly.org/lib/python/Screens/TimeDateInput.py
+++ enigma2-nightly.patched/lib/python/Screens/TimeDateInput.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.config import ConfigClock, ConfigDateTime, getConfigListEntry
 from Components.ActionMap import NumberActionMap
 from Components.ConfigList import ConfigListScreen
--- enigma2-nightly.org/lib/python/Screens/TimerEdit.py
+++ enigma2-nightly.patched/lib/python/Screens/TimerEdit.py
@@ -6,11 +6,11 @@
 from Components.TimerSanityCheck import TimerSanityCheck
 from Components.UsageConfig import preferredTimerPath
 from RecordTimer import RecordTimerEntry, parseEvent, AFTEREVENT
-from Screen import Screen
+from .Screen import Screen
 from Screens.ChoiceBox import ChoiceBox
 from Screens.MessageBox import MessageBox
 from ServiceReference import ServiceReference
-from TimerEntry import TimerEntry, TimerLog
+from .TimerEntry import TimerEntry, TimerLog
 from Tools.BoundFunction import boundFunction
 from time import time
 from timer import TimerEntry as RealTimerEntry
@@ -40,7 +40,7 @@
 		self["key_yellow"] = Button(" ")
 		self["key_blue"] = Button(" ")
 
-		print "key_red_choice:",self.key_red_choice
+		print("key_red_choice:",self.key_red_choice)
 
 		self["actions"] = ActionMap(["OkCancelActions", "DirectionActions", "ShortcutActions", "TimerEditActions"], 
 			{
@@ -78,17 +78,17 @@
 		if cur:
 			t = cur
 			if t.disabled:
-				print "try to ENABLE timer"
+				print("try to ENABLE timer")
 				t.enable()
 				timersanitycheck = TimerSanityCheck(self.session.nav.RecordTimer.timer_list, cur)
 				if not timersanitycheck.check():
 					t.disable()
-					print "Sanity check failed"
+					print("Sanity check failed")
 					simulTimerList = timersanitycheck.getSimulTimerList()
 					if simulTimerList is not None:
 						self.session.openWithCallback(self.finishedEdit, TimerSanityConflict, simulTimerList)
 				else:
-					print "Sanity check passed"
+					print("Sanity check passed")
 					if timersanitycheck.doubleCheck():
 						t.disable()
 			else:
@@ -258,10 +258,10 @@
 			
 		
 	def finishedEdit(self, answer):
-		print "finished edit"
+		print("finished edit")
 		
 		if answer[0]:
-			print "Edited timer"
+			print("Edited timer")
 			entry = answer[1]
 			timersanitycheck = TimerSanityCheck(self.session.nav.RecordTimer.timer_list, entry)
 			success = False
@@ -280,16 +280,16 @@
 			else:
 				success = True
 			if success:
-				print "Sanity check passed"
+				print("Sanity check passed")
 				self.session.nav.RecordTimer.timeChanged(entry)
 			
 			self.fillTimerList()
 			self.updateState()
 		else:
-			print "Timeredit aborted"
+			print("Timeredit aborted")
 
 	def finishedAdd(self, answer):
-		print "finished add"
+		print("finished add")
 		if answer[0]:
 			entry = answer[1]
 			simulTimerList = self.session.nav.RecordTimer.record(entry)
@@ -303,7 +303,7 @@
 			self.fillTimerList()
 			self.updateState()
 		else:
-			print "Timeredit aborted"
+			print("Timeredit aborted")
 
 	def finishSanityCorrection(self, answer):
 		self.finishedAdd(answer)
@@ -325,7 +325,7 @@
 	def __init__(self, session, timer):
 		Screen.__init__(self, session)
 		self.timer = timer
-		print "TimerSanityConflict"
+		print("TimerSanityConflict")
 			
 		self["timer1"] = TimerList(self.getTimerList(timer[0]))
 		self.list = []
--- enigma2-nightly.org/lib/python/Screens/TimerEntry.py
+++ enigma2-nightly.patched/lib/python/Screens/TimerEntry.py
@@ -1,5 +1,5 @@
-from Screen import Screen
-import ChannelSelection
+from .Screen import Screen
+from . import ChannelSelection
 from ServiceReference import ServiceReference
 from Components.config import config, ConfigSelection, ConfigText, ConfigSubList, ConfigDateTime, ConfigClock, ConfigYesNo, getConfigListEntry
 from Components.ActionMap import NumberActionMap
@@ -86,7 +86,7 @@
 					count = 0
 					for x in (0, 1, 2, 3, 4, 5, 6):
 						if flags == 1: # weekly
-							print "Set to weekday " + str(x)
+							print("Set to weekday " + str(x))
 							weekday = x
 						if flags & 1 == 1: # set user defined flags
 							day[x] = 1
@@ -208,7 +208,7 @@
 		self[widget].l.setList(self.list)
 
 	def newConfig(self):
-		print "newConfig", self["config"].getCurrent()
+		print("newConfig", self["config"].getCurrent())
 		if self["config"].getCurrent() in (self.timerTypeEntry, self.timerJustplayEntry, self.frequencyEntry, self.entryShowEndTime):
 			self.createSetup("config")
 
--- enigma2-nightly.org/lib/python/Screens/TimerSelection.py
+++ enigma2-nightly.patched/lib/python/Screens/TimerSelection.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.TimerList import TimerList
 from Components.ActionMap import ActionMap
 
--- enigma2-nightly.org/lib/python/Screens/UnhandledKey.py
+++ enigma2-nightly.patched/lib/python/Screens/UnhandledKey.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.Pixmap import Pixmap
 
 class UnhandledKey(Screen):
--- enigma2-nightly.org/lib/python/Screens/Volume.py
+++ enigma2-nightly.patched/lib/python/Screens/Volume.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.VolumeBar import VolumeBar
 		
 class Volume(Screen):
@@ -10,5 +10,5 @@
 		self["Volume"] = self.volumeBar
 		
 	def setValue(self, vol):
-		print "setValue", vol
+		print("setValue", vol)
 		self.volumeBar.setValue(vol)
--- enigma2-nightly.org/lib/python/Screens/Wizard.py
+++ enigma2-nightly.patched/lib/python/Screens/Wizard.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Screens.HelpMenu import HelpableScreen
 from Screens.MessageBox import MessageBox
 from Components.config import config, ConfigText, ConfigPassword, KEY_LEFT, KEY_RIGHT, KEY_HOME, KEY_END, KEY_0, KEY_DELETE, KEY_BACKSPACE, KEY_OK, KEY_TOGGLEOW, KEY_ASCII, KEY_TIMEOUT, KEY_NUMBERS
@@ -16,6 +16,7 @@
 from xml.sax.handler import ContentHandler
 #+++>
 from enigma import evfd
+import collections
 #+++<
 
 class WizardSummary(Screen):
@@ -34,7 +35,7 @@
 	instance = None
 
 	def createSummary(self):
-			print "WizardCreateSummary"
+			print("WizardCreateSummary")
 			return WizardSummary
 
 	class parseWizard(ContentHandler):
@@ -49,44 +50,44 @@
 			self.currContent = name
 			if (name == "step"):
 				self.lastStep += 1
-				if attrs.has_key('id'):
+				if 'id' in attrs:
 					id = str(attrs.get('id'))
 				else:
 					id = ""
 				#print "id:", id
-				if attrs.has_key('nextstep'):
+				if 'nextstep' in attrs:
 					nextstep = str(attrs.get('nextstep'))
 				else:
 					nextstep = None
-				if attrs.has_key('timeout'):
+				if 'timeout' in attrs:
 					timeout = int(attrs.get('timeout'))
 				else:
 					timeout = None
-				if attrs.has_key('timeoutaction'):
+				if 'timeoutaction' in attrs:
 					timeoutaction = str(attrs.get('timeoutaction'))
 				else:
 					timeoutaction = 'nextpage'
 
-				if attrs.has_key('timeoutstep'):
+				if 'timeoutstep' in attrs:
 					timeoutstep = str(attrs.get('timeoutstep'))
 				else:
 					timeoutstep = ''
 				self.wizard[self.lastStep] = {"id": id, "condition": "", "text": "", "timeout": timeout, "timeoutaction": timeoutaction, "timeoutstep": timeoutstep, "list": [], "config": {"screen": None, "args": None, "type": "" }, "code": "", "codeafter": "", "code_async": "", "codeafter_async": "", "nextstep": nextstep}
-				if attrs.has_key('laststep'):
+				if 'laststep' in attrs:
 					self.wizard[self.lastStep]["laststep"] = str(attrs.get('laststep'))
 			elif (name == "text"):
 				self.wizard[self.lastStep]["text"] = str(attrs.get('value')).replace("\\n", "\n")
 			elif (name == "displaytext"):
 				self.wizard[self.lastStep]["displaytext"] = str(attrs.get('value')).replace("\\n", "\n")
 			elif (name == "list"):
-				if (attrs.has_key('type')):
+				if ('type' in attrs):
 					if attrs["type"] == "dynamic":
 						self.wizard[self.lastStep]["dynamiclist"] = attrs.get("source")
 					#self.wizard[self.lastStep]["list"].append(("Hallo", "test"))
-				if (attrs.has_key("evaluation")):
+				if ("evaluation" in attrs):
 					#print "evaluation"
 					self.wizard[self.lastStep]["listevaluation"] = attrs.get("evaluation")
-				if (attrs.has_key("onselect")):
+				if ("onselect" in attrs):
 					self.wizard[self.lastStep]["onselect"] = attrs.get("onselect")			
 			elif (name == "listentry"):
 				self.wizard[self.lastStep]["list"].append((str(attrs.get('caption')), str(attrs.get('step'))))
@@ -95,21 +96,21 @@
 				self.wizard[self.lastStep]["config"]["type"] = type
 				if type == "ConfigList" or type == "standalone":
 					try:
-						exec "from Screens." + str(attrs.get('module')) + " import *"
+						exec("from Screens." + str(attrs.get('module')) + " import *")
 					except:
-						exec "from " + str(attrs.get('module')) + " import *"
+						exec("from " + str(attrs.get('module')) + " import *")
 				
 					self.wizard[self.lastStep]["config"]["screen"] = eval(str(attrs.get('screen')))
-					if (attrs.has_key('args')):
+					if ('args' in attrs):
 						#print "has args"
 						self.wizard[self.lastStep]["config"]["args"] = str(attrs.get('args'))
 				elif type == "dynamic":
 					self.wizard[self.lastStep]["config"]["source"] = str(attrs.get('source'))
-					if (attrs.has_key('evaluation')):
+					if ('evaluation' in attrs):
 						self.wizard[self.lastStep]["config"]["evaluation"] = str(attrs.get('evaluation'))
 			elif (name == "code"):
-				self.async_code = attrs.has_key('async') and str(attrs.get('async')) == "yes"
-				if attrs.has_key('pos') and str(attrs.get('pos')) == "after":
+				self.async_code = 'async' in attrs and str(attrs.get('async')) == "yes"
+				if 'pos' in attrs and str(attrs.get('pos')) == "after":
 					self.codeafter = True
 				else:
 					self.codeafter = False
@@ -161,7 +162,7 @@
 		parser = make_parser()
 		if not isinstance(self.xmlfile, list):
 			self.xmlfile = [self.xmlfile]
-		print "Reading ", self.xmlfile
+		print("Reading ", self.xmlfile)
 		wizardHandler = self.parseWizard(self.wizard)
 		parser.setContentHandler(wizardHandler)
 		for xmlfile in self.xmlfile:
@@ -244,19 +245,19 @@
 		self["VirtualKB"].setEnabled(False)
 		
 	def red(self):
-		print "red"
+		print("red")
 		pass
 
 	def green(self):
-		print "green"
+		print("green")
 		pass
 	
 	def yellow(self):
-		print "yellow"
+		print("yellow")
 		pass
 	
 	def blue(self):
-		print "blue"
+		print("blue")
 		pass
 	
 	def deleteForward(self):
@@ -265,7 +266,7 @@
 			self.configInstance.keyDelete()
 		elif (self.wizard[self.currStep]["config"]["type"] == "dynamic"):
 			self["config"].handleKey(KEY_DELETE)
-		print "deleteForward"
+		print("deleteForward")
 
 	def deleteBackward(self):
 		self.resetCounter()
@@ -273,7 +274,7 @@
 			self.configInstance.keyBackspace()
 		elif (self.wizard[self.currStep]["config"]["type"] == "dynamic"):
 			self["config"].handleKey(KEY_BACKSPACE)
-		print "deleteBackward"
+		print("deleteBackward")
 	
 	def setLCDTextCallback(self, callback):
 		self.lcdCallbacks.append(callback)
@@ -281,8 +282,8 @@
 	def back(self):
 		if self.disableKeys:
 			return
-		print "getting back..."
-		print "stepHistory:", self.stepHistory
+		print("getting back...")
+		print("stepHistory:", self.stepHistory)
 		if len(self.stepHistory) > 1:
 			self.currStep = self.stepHistory[-2]
 			self.stepHistory = self.stepHistory[:-2]
@@ -290,10 +291,10 @@
 			self.session.openWithCallback(self.exitWizardQuestion, MessageBox, (_("Are you sure you want to exit this wizard?") ) )
 		if self.currStep < 1:
 			self.currStep = 1
-		print "currStep:", self.currStep
-		print "new stepHistory:", self.stepHistory
+		print("currStep:", self.currStep)
+		print("new stepHistory:", self.stepHistory)
 		self.updateValues()
-		print "after updateValues stepHistory:", self.stepHistory
+		print("after updateValues stepHistory:", self.stepHistory)
 		
 	def exitWizardQuestion(self, ret = False):
 		if (ret):
@@ -308,18 +309,18 @@
 		self.close()
 
 	def getStepWithID(self, id):
-		print "getStepWithID:", id
+		print("getStepWithID:", id)
 		count = 0
-		for x in self.wizard.keys():
+		for x in list(self.wizard.keys()):
 			if self.wizard[x]["id"] == id:
-				print "result:", count
+				print("result:", count)
 				return count
 			count += 1
-		print "result: nothing"
+		print("result: nothing")
 		return 0
 
 	def finished(self, gotoStep = None, *args, **kwargs):
-		print "finished"
+		print("finished")
 		currStep = self.currStep
 
 		if self.updateValues not in self.onShown:
@@ -331,16 +332,16 @@
 
 		if self.showList:
 			if (len(self.wizard[currStep]["evaluatedlist"]) > 0):
-				print "current:", self["list"].current
+				print("current:", self["list"].current)
 				nextStep = self["list"].current[1]
-				if (self.wizard[currStep].has_key("listevaluation")):
+				if ("listevaluation" in self.wizard[currStep]):
 					exec("self." + self.wizard[self.currStep]["listevaluation"] + "('" + nextStep + "')")
 				else:
 					self.currStep = self.getStepWithID(nextStep)
 
 		print_now = True
 		if ((currStep == self.numSteps and self.wizard[currStep]["nextstep"] is None) or self.wizard[currStep]["id"] == "end"): # wizard finished
-			print "wizard finished"
+			print("wizard finished")
 			self.markDone()
 			self.exit()
 		else:
@@ -358,10 +359,10 @@
 		open("/proc/progress", "w").write("100")
 #+++<
 		if print_now:
-			print "Now: " + str(self.currStep)
+			print("Now: " + str(self.currStep))
 
 	def ok(self):
-		print "OK"
+		print("OK")
 		if self.disableKeys:
 			return
 		currStep = self.currStep
@@ -372,7 +373,7 @@
 				# there was a try/except here, but i can't see a reason
 				# for this. If there is one, please do a more specific check
 				# and/or a comment in which situation there is no run()
-				if callable(getattr(self.configInstance, "runAsync", None)):
+				if isinstance(getattr(self.configInstance, "runAsync", None), collections.Callable):
 					if self.updateValues in self.onShown:
 						self.onShown.remove(self.updateValues)
 					self.configInstance.runAsync(self.finished)
@@ -399,7 +400,7 @@
 			self.configInstance.keyLeft()
 		elif (self.wizard[self.currStep]["config"]["type"] == "dynamic"):
 			self["config"].handleKey(KEY_LEFT)
-		print "left"
+		print("left")
 	
 	def right(self):
 		self.resetCounter()
@@ -407,7 +408,7 @@
 			self.configInstance.keyRight()
 		elif (self.wizard[self.currStep]["config"]["type"] == "dynamic"):
 			self["config"].handleKey(KEY_RIGHT)	
-		print "right"
+		print("right")
 
 	def up(self):
 		self.resetCounter()
@@ -416,12 +417,12 @@
 			self.handleInputHelpers()
 		elif (self.showList and len(self.wizard[self.currStep]["evaluatedlist"]) > 0):
 			self["list"].selectPrevious()
-			if self.wizard[self.currStep].has_key("onselect"):
-				print "current:", self["list"].current
+			if "onselect" in self.wizard[self.currStep]:
+				print("current:", self["list"].current)
 				self.selection = self["list"].current[-1]
 				#self.selection = self.wizard[self.currStep]["evaluatedlist"][self["list"].l.getCurrentSelectionIndex()][1]
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
-		print "up"
+		print("up")
 		
 	def down(self):
 		self.resetCounter()
@@ -431,14 +432,14 @@
 		elif (self.showList and len(self.wizard[self.currStep]["evaluatedlist"]) > 0):
 			#self["list"].instance.moveSelection(self["list"].instance.moveDown)
 			self["list"].selectNext()
-			if self.wizard[self.currStep].has_key("onselect"):
-				print "current:", self["list"].current
+			if "onselect" in self.wizard[self.currStep]:
+				print("current:", self["list"].current)
 				#self.selection = self.wizard[self.currStep]["evaluatedlist"][self["list"].l.getCurrentSelectionIndex()][1]
 				#exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 				self.selection = self["list"].current[-1]
 				#self.selection = self.wizard[self.currStep]["evaluatedlist"][self["list"].l.getCurrentSelectionIndex()][1]
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
-		print "down"
+		print("down")
 		
 	def selChanged(self):
 		self.resetCounter()
@@ -446,9 +447,9 @@
 		if (self.showConfig and self.wizard[self.currStep]["config"]["screen"] != None):
 			self["config"].instance.moveSelection(self["config"].instance.moveUp)
 		elif (self.showList and len(self.wizard[self.currStep]["evaluatedlist"]) > 0):
-			if self.wizard[self.currStep].has_key("onselect"):
+			if "onselect" in self.wizard[self.currStep]:
 				self.selection = self["list"].current[-1]
-				print "self.selection:", self.selection
+				print("self.selection:", self.selection)
 #+++>
 				evfd.getInstance().vfd_write_string("-> " + self.selection)
 #+++<
@@ -459,7 +460,7 @@
 		
 	def runCode(self, code):
 		if code != "":
-			print "code", code
+			print("code", code)
 			exec(code)
 			return True
 		return False
@@ -477,7 +478,7 @@
 				self["text"].setText(text)
 
 	def updateValues(self):
-		print "Updating values in step " + str(self.currStep)
+		print("Updating values in step " + str(self.currStep))
 		# calling a step which doesn't exist can only happen if the condition in the last step is not fulfilled
 		# if a non-existing step is called, end the wizard 
 		if self.currStep > len(self.wizard):
@@ -497,8 +498,8 @@
 		self.condition = True
 		exec (self.wizard[self.currStep]["condition"])
 		if not self.condition:
-			print "keys*******************:", self.wizard[self.currStep].keys()
-			if self.wizard[self.currStep].has_key("laststep"): # exit wizard, if condition of laststep doesn't hold
+			print("keys*******************:", list(self.wizard[self.currStep].keys()))
+			if "laststep" in self.wizard[self.currStep]: # exit wizard, if condition of laststep doesn't hold
 				self.markDone()
 				self.exit()
 				return
@@ -506,14 +507,14 @@
 				self.currStep += 1
 				self.updateValues()
 		else:
-			if self.wizard[self.currStep].has_key("displaytext"):
+			if "displaytext" in self.wizard[self.currStep]:
 				displaytext = self.wizard[self.currStep]["displaytext"]
-				print "set LCD text"
+				print("set LCD text")
 				for x in self.lcdCallbacks:
 					x(displaytext)
 			if len(self.stepHistory) == 0 or self.stepHistory[-1] != self.currStep:
 				self.stepHistory.append(self.currStep)
-			print "wizard step:", self.wizard[self.currStep]
+			print("wizard step:", self.wizard[self.currStep])
 			
 			if self.showSteps:
 				self["step"].setText(self.getTranslation("Step ") + str(self.currStep) + "/" + str(self.numSteps))
@@ -524,11 +525,11 @@
 				self.resetCounter() 
 				self.timeoutTimer.start(1000)
 			
-			print "wizard text", self.getTranslation(self.wizard[self.currStep]["text"])
+			print("wizard text", self.getTranslation(self.wizard[self.currStep]["text"]))
 			self.updateText(firstset = True)
-			if self.wizard[self.currStep].has_key("displaytext"):
+			if "displaytext" in self.wizard[self.currStep]:
 				displaytext = self.wizard[self.currStep]["displaytext"]
-				print "set LCD text"
+				print("set LCD text")
 				for x in self.lcdCallbacks:
 					x(displaytext)
 				
@@ -551,23 +552,23 @@
 				self.currStep = self.getStepWithID(self.gotoStep)
 			self.currStep += 1
 			self.updateValues()
-			print "Now: " + str(self.currStep)
+			print("Now: " + str(self.currStep))
 		else:
 			if self.showList:
-				print "showing list,", self.currStep
+				print("showing list,", self.currStep)
 				for renderer in self.renderer:
 					rootrenderer = renderer
 					while renderer.source is not None:
-						print "self.list:", self["list"]
+						print("self.list:", self["list"])
 						if renderer.source is self["list"]:
-							print "setZPosition"
+							print("setZPosition")
 							rootrenderer.instance.setZPosition(1)
 						renderer = renderer.source
 
 				#self["list"].instance.setZPosition(1)
 				self.list = []
-				if (self.wizard[self.currStep].has_key("dynamiclist")):
-					print "dynamic list, calling",  self.wizard[self.currStep]["dynamiclist"]
+				if ("dynamiclist" in self.wizard[self.currStep]):
+					print("dynamic list, calling",  self.wizard[self.currStep]["dynamiclist"])
 					newlist = eval("self." + self.wizard[self.currStep]["dynamiclist"] + "()")
 					#self.wizard[self.currStep]["evaluatedlist"] = []
 					for entry in newlist:
@@ -585,19 +586,19 @@
 				self["list"].hide()
 	
 			if self.showConfig:
-				print "showing config"
+				print("showing config")
 				self["config"].instance.setZPosition(1)
 				if self.wizard[self.currStep]["config"]["type"] == "dynamic":
-						print "config type is dynamic"
+						print("config type is dynamic")
 						self["config"].instance.setZPosition(2)
 						self["config"].l.setList(eval("self." + self.wizard[self.currStep]["config"]["source"])())
 				elif (self.wizard[self.currStep]["config"]["screen"] != None):
 					if self.wizard[self.currStep]["config"]["type"] == "standalone":
-						print "Type is standalone"
+						print("Type is standalone")
 						self.session.openWithCallback(self.ok, self.wizard[self.currStep]["config"]["screen"])
 					else:
 						self["config"].instance.setZPosition(2)
-						print "wizard screen", self.wizard[self.currStep]["config"]["screen"]
+						print("wizard screen", self.wizard[self.currStep]["config"]["screen"])
 						if self.wizard[self.currStep]["config"]["args"] == None:
 							self.configInstance = self.session.instantiateDialog(self.wizard[self.currStep]["config"]["screen"])
 						else:
@@ -605,25 +606,25 @@
 						self["config"].l.setList(self.configInstance["config"].list)
 						callbacks = self.configInstance["config"].onSelectionChanged
 						self.configInstance["config"].destroy()
-						print "clearConfigList", self.configInstance["config"], self["config"]
+						print("clearConfigList", self.configInstance["config"], self["config"])
 						self.configInstance["config"] = self["config"]
 						self.configInstance["config"].onSelectionChanged = callbacks
-						print "clearConfigList", self.configInstance["config"], self["config"]
+						print("clearConfigList", self.configInstance["config"], self["config"])
 				else:
 					self["config"].l.setList([])
 					self.handleInputHelpers()
 					
 					
 			else:
-				if self.has_key("config"):
+				if "config" in self:
 					self["config"].hide()
 
 	def timeoutCounterFired(self):
 		self.timeoutCounter -= 1
-		print "timeoutCounter:", self.timeoutCounter
+		print("timeoutCounter:", self.timeoutCounter)
 		if self.timeoutCounter == 0:
 			if self.wizard[self.currStep]["timeoutaction"] == "selectnext":
-				print "selection next item"
+				print("selection next item")
 				self.down()
 			else:
 				if self.wizard[self.currStep]["timeoutaction"] == "changestep":
@@ -633,20 +634,20 @@
 	def handleInputHelpers(self):
 		if self["config"].getCurrent() is not None:
 			if isinstance(self["config"].getCurrent()[1], ConfigText) or isinstance(self["config"].getCurrent()[1], ConfigPassword):
-				if self.has_key("VKeyIcon"):
+				if "VKeyIcon" in self:
 					self["VirtualKB"].setEnabled(True)
 					self["VKeyIcon"].boolean = True
-				if self.has_key("HelpWindow"):
+				if "HelpWindow" in self:
 					if self["config"].getCurrent()[1].help_window.instance is not None:
 						helpwindowpos = self["HelpWindow"].getPosition()
 						from enigma import ePoint
 						self["config"].getCurrent()[1].help_window.instance.move(ePoint(helpwindowpos[0],helpwindowpos[1]))
 			else:
-				if self.has_key("VKeyIcon"):
+				if "VKeyIcon" in self:
 					self["VirtualKB"].setEnabled(False)
 					self["VKeyIcon"].boolean = False
 		else:
-			if self.has_key("VKeyIcon"):
+			if "VKeyIcon" in self:
 				self["VirtualKB"].setEnabled(False)
 				self["VKeyIcon"].boolean = False
 
@@ -658,7 +659,7 @@
 	def VirtualKeyBoardCallback(self, callback = None):
 		if callback is not None and len(callback):
 			if isinstance(self["config"].getCurrent()[1], ConfigText) or isinstance(self["config"].getCurrent()[1], ConfigPassword):
-				if self.has_key("HelpWindow"):
+				if "HelpWindow" in self:
 					if self["config"].getCurrent()[1].help_window.instance is not None:
 						helpwindowpos = self["HelpWindow"].getPosition()
 						from enigma import ePoint
--- enigma2-nightly.org/lib/python/Screens/WizardLanguage.py
+++ enigma2-nightly.patched/lib/python/Screens/WizardLanguage.py
@@ -1,4 +1,4 @@
-from Wizard import Wizard
+from .Wizard import Wizard
 from Components.Label import Label
 from Components.Language import language
 
@@ -13,7 +13,7 @@
 		self.languageSelect()
 		
 	def languageSelect(self):
-		print "languageSelect"
+		print("languageSelect")
 		newlanguage = language.getActiveLanguageIndex() + 1
 		if newlanguage >= len(language.getLanguageList()):
 			newlanguage = 0
@@ -21,11 +21,11 @@
 		self.updateTexts()
 
 	def updateLanguageDescription(self):
-		print language.getLanguageList()[language.getActiveLanguageIndex()]
+		print(language.getLanguageList()[language.getActiveLanguageIndex()])
 		self["languagetext"].setText(self.getTranslation(language.getLanguageList()[language.getActiveLanguageIndex()][1][0]))
 
 	def updateTexts(self):
-		print "updateTexts"
+		print("updateTexts")
 		self.updateText(firstset = True)
 		self.updateValues()
 		self.updateLanguageDescription()
--- enigma2-nightly.org/lib/python/Tools/Directories.py
+++ enigma2-nightly.patched/lib/python/Tools/Directories.py
@@ -120,7 +120,7 @@
 			try:
 				mkdir(path)
 			except OSError:
-				print "resolveFilename: Couldn't create %s" % path
+				print("resolveFilename: Couldn't create %s" % path)
 				return None
 
 	fallbackPath = fallbackPaths.get(scope)
@@ -149,8 +149,8 @@
 					if pathExists(x[0]):
 						os.rename(x[0], path + base)
 						break
-			except Exception, e:
-				print "[D] Failed to recover %s:" % (path+base), e
+			except Exception as e:
+				print("[D] Failed to recover %s:" % (path+base), e)
 
 	# FIXME: we also have to handle DATADIR etc. here.
 	return path + base
@@ -255,7 +255,7 @@
 		if have_utime:
 			utime(dst, (st.st_atime, st.st_mtime))
 	except:
-		print "copy", src, "to", dst, "failed!"
+		print("copy", src, "to", dst, "failed!")
 		return -1
 	return 0
 
@@ -279,7 +279,7 @@
 			else:
 				copyfile(srcname, dstname)
 		except:
-			print "dont copy srcname (no file or link or folder)"
+			print("dont copy srcname (no file or link or folder)")
 	try:
 		st = os_stat(src)
 		mode = S_IMODE(st.st_mode)
@@ -288,7 +288,7 @@
 		if have_utime:
 			utime(dst, (st.st_atime, st.st_mtime))
 	except:
-		print "copy stats for", src, "failed!"
+		print("copy stats for", src, "failed!")
 
 def getSize(path, pattern=".*"):
 	path_size = 0
--- enigma2-nightly.org/lib/python/Tools/Downloader.py
+++ enigma2-nightly.patched/lib/python/Tools/Downloader.py
@@ -11,14 +11,14 @@
 
 	def noPage(self, reason):
 		if self.status == "304":
-			print reason.getErrorMessage()
+			print(reason.getErrorMessage())
 			client.HTTPDownloader.page(self, "")
 		else:
 			client.HTTPDownloader.noPage(self, reason)
 
 	def gotHeaders(self, headers):
 		if self.status == "200":
-			if headers.has_key("content-length"):
+			if "content-length" in headers:
 				self.totalbytes = int(headers["content-length"][0])
 			else:
 				self.totalbytes = 0
@@ -45,9 +45,9 @@
 		return self.factory.deferred
 
 	def stop(self):
-		print "[stop]"
+		print("[stop]")
 		self.connection.disconnect()
 
 	def addProgress(self, progress_callback):
-		print "[addProgress]"
+		print("[addProgress]")
 		self.factory.progress_callback = progress_callback
--- enigma2-nightly.org/lib/python/Tools/FuzzyDate.py
+++ enigma2-nightly.patched/lib/python/Tools/FuzzyDate.py
@@ -34,8 +34,8 @@
 
 if __name__ == "__main__":
         def _(x): return x
-	print "now: %s %s" % FuzzyTime(time())
+	print("now: %s %s" % FuzzyTime(time()))
 	for i in range(1, 14):
-        	print "+%2s day(s):  %s " % (i, FuzzyTime(time() + 86400 * i))
+        	print("+%2s day(s):  %s " % (i, FuzzyTime(time() + 86400 * i)))
 	for i in range(1, 14):
-        	print "-%2s day(s):  %s " % (i, FuzzyTime(time() - 86400 * i, True))
+        	print("-%2s day(s):  %s " % (i, FuzzyTime(time() - 86400 * i, True)))
--- enigma2-nightly.org/lib/python/Tools/HardwareInfo.py
+++ enigma2-nightly.patched/lib/python/Tools/HardwareInfo.py
@@ -19,21 +19,21 @@
 			except:
 				pass
 		except:
-			print "----------------"
-			print "you should upgrade to new drivers for the hardware detection to work properly"
-			print "----------------"
-			print "fallback to detect hardware via /proc/cpuinfo!!"
+			print("----------------")
+			print("you should upgrade to new drivers for the hardware detection to work properly")
+			print("----------------")
+			print("fallback to detect hardware via /proc/cpuinfo!!")
 			try:
 				rd = open("/proc/cpuinfo", "r").read()
 				if rd.find("Brcm4380 V4.2") != -1:
 					HardwareInfo.device_name = "dm8000"
-					print "dm8000 detected!"
+					print("dm8000 detected!")
 				elif rd.find("Brcm7401 V0.0") != -1:
 					HardwareInfo.device_name = "dm800"
-					print "dm800 detected!"
+					print("dm800 detected!")
 				elif rd.find("MIPS 4KEc V4.8") != -1:
 					HardwareInfo.device_name = "dm7025"
-					print "dm7025 detected!"
+					print("dm7025 detected!")
 			except:
 				pass
 
--- enigma2-nightly.org/lib/python/Tools/KeyBindings.py
+++ enigma2-nightly.patched/lib/python/Tools/KeyBindings.py
@@ -160,4 +160,4 @@
 def removeKeyBindings(domain):
 	# remove all entries of domain 'domain'
 	for x in keyBindings:
-		keyBindings[x] = filter(lambda e: e[1] != domain, keyBindings[x])
+		keyBindings[x] = [e for e in keyBindings[x] if e[1] != domain]
--- enigma2-nightly.org/lib/python/Tools/Notifications.py
+++ enigma2-nightly.patched/lib/python/Tools/Notifications.py
@@ -7,7 +7,7 @@
 current_notifications = [ ]
 
 def __AddNotification(fnc, screen, id, *args, **kwargs):
-	if ".MessageBox'>" in `screen`:
+	if ".MessageBox'>" in repr(screen):
 		kwargs["simple"] = True
 	notifications.append((fnc, screen, args, kwargs, id))
 	for x in notificationAdded:
@@ -27,15 +27,15 @@
 
 def RemovePopup(id):
 	# remove similiar notifications
-	print "RemovePopup, id =", id
+	print("RemovePopup, id =", id)
 	for x in notifications:
 		if x[4] and x[4] == id:
-			print "(found in notifications)"
+			print("(found in notifications)")
 			notifications.remove(x)
 
 	for x in current_notifications:
 		if x[0] == id:
-			print "(found in current notifications)"
+			print("(found in current notifications)")
 			x[1].close()
 
 from Screens.MessageBox import MessageBox
@@ -43,5 +43,5 @@
 def AddPopup(text, type, timeout, id = None):
 	if id is not None:
 		RemovePopup(id)
-	print "AddPopup, id =", id
+	print("AddPopup, id =", id)
 	AddNotificationWithID(id, MessageBox, text = text, type = type, timeout = timeout, close_on_any_key = True)
--- enigma2-nightly.org/lib/python/Tools/Profile.py
+++ enigma2-nightly.patched/lib/python/Tools/Profile.py
@@ -1,6 +1,6 @@
 # the implementation here is a bit crappy.
 import time
-from Directories import resolveFilename, SCOPE_CONFIG
+from .Directories import resolveFilename, SCOPE_CONFIG
 
 PERCENTAGE_START = 50
 PERCENTAGE_END = 100
@@ -21,12 +21,12 @@
 		total_time = t
 		profile_data[id] = t
 except:
-	print "no profile data available"
+	print("no profile data available")
 
 try:
 	profile_file = open(resolveFilename(SCOPE_CONFIG, "profile"), "w")
 except IOError:
-	print "WARNING: couldn't open profile file!"
+	print("WARNING: couldn't open profile file!")
 
 def profile(id):
 	now = time.time() - profile_start
--- enigma2-nightly.org/lib/python/Tools/RedirectOutput.py
+++ enigma2-nightly.patched/lib/python/Tools/RedirectOutput.py
@@ -3,7 +3,7 @@
 
 class EnigmaOutput:
 	def write(self, data):
-		if isinstance(data, unicode):
+		if isinstance(data, str):
 			data = data.encode("UTF-8")
 		ePythonOutput(data)
 
--- enigma2-nightly.org/lib/python/Tools/StbHardware.py
+++ enigma2-nightly.patched/lib/python/Tools/StbHardware.py
@@ -4,13 +4,13 @@
 def getFPVersion():
 	ret = None
 	try:
-		ret = long(open("/proc/stb/fp/version", "r").read())
+		ret = int(open("/proc/stb/fp/version", "r").read())
 	except IOError:
 		try:
 			fp = open("/dev/dbox/fp0")
 			ret = ioctl(fp.fileno(),0)
 		except IOError:
-			print "getFPVersion failed!"
+			print("getFPVersion failed!")
 	return ret
 
 def setFPWakeuptime(wutime):
@@ -21,7 +21,7 @@
 			fp = open("/dev/dbox/fp0")
 			ioctl(fp.fileno(), 6, pack('L', wutime)) # set wake up
 		except IOError:
-			print "setFPWakeupTime failed!"
+			print("setFPWakeupTime failed!")
 
 def setRTCtime(wutime):
 	try:
@@ -31,18 +31,18 @@
 			fp = open("/dev/dbox/fp0")
 			ioctl(fp.fileno(), 0x101, pack('L', wutime)) # set wake up
 		except IOError:
-			print "setRTCtime failed!"
+			print("setRTCtime failed!")
 
 def getFPWakeuptime():
 	ret = 0
 	try:
-		ret = long(open("/proc/stb/fp/wakeup_time", "r").read())
+		ret = int(open("/proc/stb/fp/wakeup_time", "r").read())
 	except IOError:
 		try:
 			fp = open("/dev/dbox/fp0")
 			ret = unpack('L', ioctl(fp.fileno(), 5, '    '))[0] # get wakeuptime
 		except IOError:
-			print "getFPWakeupTime failed!"
+			print("getFPWakeupTime failed!")
 	return ret
 
 wasTimerWakeup = None
@@ -59,7 +59,7 @@
 			fp = open("/dev/dbox/fp0")
 			wasTimerWakeup = unpack('B', ioctl(fp.fileno(), 9, ' '))[0] and True or False
 		except IOError:
-			print "wasTimerWakeup failed!"
+			print("wasTimerWakeup failed!")
 	if wasTimerWakeup:
 		# clear hardware status
 		clearFPWasTimerWakeup()
@@ -73,4 +73,4 @@
 			fp = open("/dev/dbox/fp0")
 			ioctl(fp.fileno(), 10)
 		except IOError:
-			print "clearFPWasTimerWakeup failed!"
+			print("clearFPWasTimerWakeup failed!")
--- enigma2-nightly.org/lib/python/Tools/Transponder.py
+++ enigma2-nightly.patched/lib/python/Tools/Transponder.py
@@ -156,8 +156,8 @@
 			eDVBFrontendParametersATSC.System_ATSC : "ATSC",
 			eDVBFrontendParametersATSC.System_DVB_C_ANNEX_B : "DVB-C ANNEX B"}.get(tp.get("system"))
 	elif type != "None":
-		print "ConvertToHumanReadable: no or unknown type in tpdata dict for type:", type
-	for k,v in tp.items():
+		print("ConvertToHumanReadable: no or unknown type in tpdata dict for type:", type)
+	for k,v in list(tp.items()):
 		if k not in ret:
 			ret[k] = v
 	return ret
--- enigma2-nightly.org/lib/python/Tools/Trashcan.py
+++ enigma2-nightly.patched/lib/python/Tools/Trashcan.py
@@ -17,7 +17,7 @@
 	# Create and return trash folder for given file or dir
 	trash = getTrashFolder(path)
 	if not os.path.isdir(trash):
-		print "[Trashcan] create:", trash
+		print("[Trashcan] create:", trash)
 		os.mkdir(trash)
 	return trash
 
@@ -72,7 +72,7 @@
 		if not self.dirty:
 			return
 		if self.isCleaning:
-			print "[Trashcan] Cleanup already running"
+			print("[Trashcan] Cleanup already running")
 			return
 		if (self.session is not None) and self.session.nav.getRecordings():
 			return
@@ -89,7 +89,7 @@
 		self.cleanIfIdle()
 
 	def cleanFail(self, failure):
-		print "[Trashcan] ERROR in clean:", failure
+		print("[Trashcan] ERROR in clean:", failure)
 		self.isCleaning = False
 
 def purge(cleanset, ctimeLimit, reserveBytes):
@@ -97,13 +97,13 @@
 	# reserveBytes of free disk space.
 	for trash in cleanset:
 		if not os.path.isdir(trash):
-			print "[Trashcan] No trash.", trash
+			print("[Trashcan] No trash.", trash)
 			return 0
 		diskstat = os.statvfs(trash)
 		free = diskstat.f_bfree * diskstat.f_bsize
 		bytesToRemove = reserveBytes - free 
 		candidates = []
-		print "[Trashcan] bytesToRemove", bytesToRemove, trash
+		print("[Trashcan] bytesToRemove", bytesToRemove, trash)
 		size = 0
 		for root, dirs, files in os.walk(trash, topdown=False):
 			for name in files:
@@ -111,14 +111,14 @@
 					fn = os.path.join(root, name)
 					st = os.stat(fn)
 					if st.st_ctime < ctimeLimit:
-						print "[Trashcan] Too old:", name, st.st_ctime
+						print("[Trashcan] Too old:", name, st.st_ctime)
 						enigma.eBackgroundFileEraser.getInstance().erase(fn)
 						bytesToRemove -= st.st_size
 					else:
 						candidates.append((st.st_ctime, fn, st.st_size))
 						size += st.st_size
-				except Exception, e:
-					print "[Trashcan] Failed to stat %s:"% name, e 
+				except Exception as e:
+					print("[Trashcan] Failed to stat %s:"% name, e) 
 			# Remove empty directories if possible
 			for name in dirs:
 				try:
@@ -127,26 +127,26 @@
 					pass
 		candidates.sort()
 		# Now we have a list of ctime, candidates, size. Sorted by ctime (=deletion time)
-		print "[Trashcan] Bytes to remove remaining:", bytesToRemove, trash
+		print("[Trashcan] Bytes to remove remaining:", bytesToRemove, trash)
 		for st_ctime, fn, st_size in candidates:
 			if bytesToRemove < 0:
 				break
 			enigma.eBackgroundFileEraser.getInstance().erase(fn)
 			bytesToRemove -= st_size
 			size -= st_size
-		print "[Trashcan] Size after purging:", size, trash
+		print("[Trashcan] Size after purging:", size, trash)
  
 def cleanAll(trash):
 	if not os.path.isdir(trash):
-		print "[Trashcan] No trash.", trash
+		print("[Trashcan] No trash.", trash)
 		return 0
 	for root, dirs, files in os.walk(trash, topdown=False):
 		for name in files:
 			fn = os.path.join(root, name)
 			try:
 				enigma.eBackgroundFileEraser.getInstance().erase(fn)
-			except Exception, e:
-				print "[Trashcan] Failed to erase %s:"% name, e
+			except Exception as e:
+				print("[Trashcan] Failed to erase %s:"% name, e)
 		# Remove empty directories if possible
 		for name in dirs:
 			try:
--- enigma2-nightly.org/mytest.py
+++ enigma2-nightly.patched/mytest.py
@@ -79,7 +79,7 @@
 	def runReactor():
 		reactor.run(installSignalHandlers=False)
 except ImportError:
-	print "twisted not available"
+	print("twisted not available")
 	def runReactor():
 		enigma.runMainloop()
 
@@ -100,17 +100,17 @@
 
 def dump(dir, p = ""):
 	if isinstance(dir, dict):
-		for (entry, val) in dir.items():
+		for (entry, val) in list(dir.items()):
 			dump(val, p + "(dict)/" + entry)
 	if hasattr(dir, "__dict__"):
-		for name, value in dir.__dict__.items():
-			if not had.has_key(str(value)):
+		for name, value in list(dir.__dict__.items()):
+			if str(value) not in had:
 				had[str(value)] = 1
 				dump(value, p + "/" + str(name))
 			else:
-				print p + "/" + str(name) + ":" + str(dir.__class__) + "(cycle)"
+				print(p + "/" + str(name) + ":" + str(dir.__class__) + "(cycle)")
 	else:
-		print p + ":" + str(dir)
+		print(p + ":" + str(dir))
 
 # + ":" + str(dir.__class__)
 
@@ -171,7 +171,7 @@
 			try:
 				p(reason=0, session=self)
 			except:
-				print "Plugin raised exception at WHERE_SESSIONSTART"
+				print("Plugin raised exception at WHERE_SESSIONSTART")
 				import traceback
 				traceback.print_exc()
 
@@ -226,7 +226,7 @@
 			return screen(self, *arguments, **kwargs)
 		except:
 			errstr = "Screen %s(%s, %s): %s" % (str(screen), str(arguments), str(kwargs), exc_info()[0])
-			print errstr
+			print(errstr)
 			print_exc(file=stdout)
 			enigma.quitMainloop(5)
 
@@ -251,11 +251,11 @@
 		try:
 			dlg = self.create(screen, arguments, **kwargs)
 		except:
-			print 'EXCEPTION IN DIALOG INIT CODE, ABORTING:'
-			print '-'*60
+			print('EXCEPTION IN DIALOG INIT CODE, ABORTING:')
+			print('-'*60)
 			print_exc(file=stdout)
 			enigma.quitMainloop(5)
-			print '-'*60
+			print('-'*60)
 
 		if dlg is None:
 			return
@@ -313,7 +313,7 @@
 
 	def close(self, screen, *retval):
 		if not self.in_exec:
-			print "close after exec!"
+			print("close after exec!")
 			return
 
 		# be sure that the close is for the right dialog!
@@ -363,7 +363,7 @@
 		self.session.infobar = None
 
 	def shutdown(self):
-		print "PowerOff - Now!"
+		print("PowerOff - Now!")
 		if not Screens.Standby.inTryQuitMainloop and self.session.current_dialog and self.session.current_dialog.ALLOW_SUSPEND:
 			self.session.open(Screens.Standby.TryQuitMainloop, 1)
 
@@ -377,7 +377,7 @@
 		if action == "shutdown":
 			self.shutdown()
 		elif action == "show_menu":
-			print "Show shutdown Menu"
+			print("Show shutdown Menu")
 			root = mdom.getroot()
 			for x in root.findall("menu"):
 				y = x.find("id")
@@ -520,9 +520,9 @@
 		else:
 			wptime = startTime[0] - 300
 		if not config.misc.useTransponderTime.value:
-			print "dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))
+			print("dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime)))
 			setRTCtime(nowTime)
-		print "set wakeup time to", strftime("%Y/%m/%d %H:%M", localtime(wptime))
+		print("set wakeup time to", strftime("%Y/%m/%d %H:%M", localtime(wptime)))
 		setFPWakeuptime(wptime)
 		recordTimerWakeupAuto = startTime[1] == 0 and startTime[2]
 	config.misc.isNextRecordTimerAfterEventActionAuto.value = recordTimerWakeupAuto
@@ -601,8 +601,8 @@
 
 	Components.ParentalControl.parentalControl.save()
 except:
-	print 'EXCEPTION IN PYTHON STARTUP CODE:'
-	print '-'*60
+	print('EXCEPTION IN PYTHON STARTUP CODE:')
+	print('-'*60)
 	print_exc(file=stdout)
 	enigma.quitMainloop(5)
-	print '-'*60
+	print('-'*60)
--- enigma2-nightly.org/Navigation.py
+++ enigma2-nightly.patched/Navigation.py
@@ -62,9 +62,9 @@
 	def playService(self, ref, checkParentalControl = True, forceRestart = False):
 		oldref = self.currentlyPlayingServiceReference
 		if ref and oldref and ref == oldref and not forceRestart:
-			print "ignore request to play already running service(1)"
+			print("ignore request to play already running service(1)")
 			return 0
-		print "playing", ref and ref.toString()
+		print("playing", ref and ref.toString())
 		if ref is None:
 			self.stopService()
 			return 0
@@ -73,9 +73,9 @@
 				if not oldref:
 					oldref = eServiceReference()
 				playref = getBestPlayableServiceReference(ref, oldref)
-				print "playref", playref
+				print("playref", playref)
 				if playref and oldref and playref == oldref and not forceRestart:
-					print "ignore request to play already running service(2)"
+					print("ignore request to play already running service(2)")
 					return 0
 				if not playref or (checkParentalControl and not parentalControl.isServicePlayable(playref, boundFunction(self.playService, checkParentalControl = False))):
 					self.stopService()
@@ -90,7 +90,7 @@
 				if InfoBarInstance is not None:
 					InfoBarInstance.servicelist.servicelist.setCurrent(ref)
 				if self.pnav.playService(playref):
-					print "Failed to start", playref
+					print("Failed to start", playref)
 					self.currentlyPlayingServiceReference = None
 					self.currentlyPlayingServiceOrGroup = None
 				return 0
@@ -106,7 +106,7 @@
 
 	def recordService(self, ref, simulate=False):
 		service = None
-		if not simulate: print "recording service: %s" % (str(ref))
+		if not simulate: print("recording service: %s" % (str(ref)))
 		if isinstance(ref, ServiceReference.ServiceReference):
 			ref = ref.ref
 		if ref:
@@ -114,7 +114,7 @@
 				ref = getBestPlayableServiceReference(ref, eServiceReference(), simulate)
 			service = ref and self.pnav and self.pnav.recordService(ref, simulate)
 			if service is None:
-				print "record returned non-zero"
+				print("record returned non-zero")
 		return service
 
 	def stopRecordService(self, service):
--- enigma2-nightly.org/po/xml2po.py
+++ enigma2-nightly.patched/po/xml2po.py
@@ -55,13 +55,13 @@
 	attrlist.sort(key=lambda a: a[0])
 
 	for (k,c) in attrlist:
-		print
-		print '#: ' + arg
+		print()
+		print('#: ' + arg)
 		string.replace(k, "\\n", "\"\n\"")
 		if c:
 			for l in c.split('\n'):
-				print "#. ", l
-		print 'msgid "' + str(k) + '"'
-		print 'msgstr ""'
+				print("#. ", l)
+		print('msgid "' + str(k) + '"')
+		print('msgstr ""')
 
 	attrlist = set()
--- enigma2-nightly.org/RecordTimer.py
+++ enigma2-nightly.patched/RecordTimer.py
@@ -57,15 +57,11 @@
 		return None
 	from Components import Harddisk
 	dirname = os.path.realpath(dirname)
-	mountpoint = Harddisk.findMountPoint(dirname)
-	if mountpoint in ('/', '/media'):
-		print '[RecordTimer] media is not mounted:', dirname
-		return None
 	if not os.path.isdir(dirname):
 		try:
 			os.makedirs(dirname)
-		except Exception, ex:
-			print '[RecordTimer] Failed to create dir "%s":' % dirname, ex
+		except Exception as ex:
+			print('[RecordTimer] Failed to create dir "%s":' % dirname, ex)
 			return None
 	return dirname
 
@@ -79,28 +79,28 @@
 	@staticmethod
 	def staticGotRecordEvent(recservice, event):
 		if event == iRecordableService.evEnd:
-			print "RecordTimer.staticGotRecordEvent(iRecordableService.evEnd)"
+			print("RecordTimer.staticGotRecordEvent(iRecordableService.evEnd)")
 			recordings = NavigationInstance.instance.getRecordings()
 			if not recordings: # no more recordings exist
 				rec_time = NavigationInstance.instance.RecordTimer.getNextRecordingTime()
 				if rec_time > 0 and (rec_time - time()) < 360:
-					print "another recording starts in", rec_time - time(), "seconds... do not shutdown yet"
+					print("another recording starts in", rec_time - time(), "seconds... do not shutdown yet")
 				else:
-					print "no starting records in the next 360 seconds... immediate shutdown"
+					print("no starting records in the next 360 seconds... immediate shutdown")
 					RecordTimerEntry.shutdown() # immediate shutdown
 		elif event == iRecordableService.evStart:
-			print "RecordTimer.staticGotRecordEvent(iRecordableService.evStart)"
+			print("RecordTimer.staticGotRecordEvent(iRecordableService.evStart)")
 
 	@staticmethod
 	def stopTryQuitMainloop():
-		print "RecordTimer.stopTryQuitMainloop"
+		print("RecordTimer.stopTryQuitMainloop")
 		NavigationInstance.instance.record_event.remove(RecordTimerEntry.staticGotRecordEvent)
 		RecordTimerEntry.receiveRecordEvents = False
 
 	@staticmethod
 	def TryQuitMainloop(default_yes = True):
 		if not RecordTimerEntry.receiveRecordEvents:
-			print "RecordTimer.TryQuitMainloop"
+			print("RecordTimer.TryQuitMainloop")
 			NavigationInstance.instance.record_event.append(RecordTimerEntry.staticGotRecordEvent)
 			RecordTimerEntry.receiveRecordEvents = True
 			# send fake event.. to check if another recordings are running or
@@ -152,16 +152,16 @@
 
 	def log(self, code, msg):
 		self.log_entries.append((int(time()), code, msg))
-		print "[TIMER]", msg
+		print("[TIMER]", msg)
 
 	def calculateFilename(self):
 		service_name = self.service_ref.getServiceName()
 		begin_date = strftime("%Y%m%d %H%M", localtime(self.begin))
 
-		print "begin_date: ", begin_date
-		print "service_name: ", service_name
-		print "name:", self.name
-		print "description: ", self.description
+		print("begin_date: ", begin_date)
+		print("service_name: ", service_name)
+		print("name:", self.name)
+		print("description: ", self.description)
 
 		filename = begin_date + " - " + service_name
 		if self.name:
@@ -268,9 +268,9 @@
 					# Give the Trashcan a chance to clean up
 					try:
 						Trashcan.instance.cleanIfIdle(self.Filename)
-					except Exception, e:
-						 print "[TIMER] Failed to call Trashcan.instance.cleanIfIdle()"
-						 print "[TIMER] Error:", e
+					except Exception as e:
+						 print("[TIMER] Failed to call Trashcan.instance.cleanIfIdle()")
+						 print("[TIMER] Error:", e)
 				# fine. it worked, resources are allocated.
 				self.next_activation = self.begin
 				self.backoff = 0
@@ -407,7 +407,7 @@
 			return
 		self.log(16, "record event %d" % event)
 		if event == iRecordableService.evRecordWriteError:
-			print "WRITE ERROR on recording, disk full?"
+			print("WRITE ERROR on recording, disk full?")
 			# show notification. the 'id' will make sure that it will be
 			# displayed only once, even if more timers are failing at the
 			# same time. (which is very likely in case of disk fullness)
@@ -429,13 +429,13 @@
 	# we have record_service as property to automatically subscribe to record service events
 	def setRecordService(self, service):
 		if self.__record_service is not None:
-			print "[remove callback]"
+			print("[remove callback]")
 			NavigationInstance.instance.record_event.remove(self.gotRecordEvent)
 
 		self.__record_service = service
 
 		if self.__record_service is not None:
-			print "[add callback]"
+			print("[add callback]")
 			NavigationInstance.instance.record_event.append(self.gotRecordEvent)
 
 	record_service = property(lambda self: self.__record_service, setRecordService)
@@ -446,8 +446,8 @@
 	serviceref = ServiceReference(xml.get("serviceref").encode("utf-8"))
 	description = xml.get("description").encode("utf-8")
 	repeated = xml.get("repeated").encode("utf-8")
-	disabled = long(xml.get("disabled") or "0")
-	justplay = long(xml.get("justplay") or "0")
+	disabled = int(xml.get("disabled") or "0")
+	justplay = int(xml.get("justplay") or "0")
 	afterevent = str(xml.get("afterevent") or "nothing")
 	afterevent = {
 		"nothing": AFTEREVENT.NONE,
@@ -457,7 +457,7 @@
 		}[afterevent]
 	eit = xml.get("eit")
 	if eit and eit != "None":
-		eit = long(eit);
+		eit = int(eit);
 	else:
 		eit = None
 	location = xml.get("location")
@@ -495,7 +495,7 @@
 		try:
 			self.loadTimer()
 		except IOError:
-			print "unable to load timers from file!"
+			print("unable to load timers from file!")
 
 	def doActivate(self, w):
 		# when activating a timer which has already passed,
@@ -545,15 +545,15 @@
 
 			AddPopup(_("The timer file (timers.xml) is corrupt and could not be loaded."), type = MessageBox.TYPE_ERROR, timeout = 0, id = "TimerLoadFailed")
 
-			print "timers.xml failed to load!"
+			print("timers.xml failed to load!")
 			try:
 				import os
 				os.rename(self.Filename, self.Filename + "_old")
 			except (IOError, OSError):
-				print "renaming broken timer failed"
+				print("renaming broken timer failed")
 			return
 		except IOError:
-			print "timers.xml not found!"
+			print("timers.xml not found!")
 			return
 
 		root = doc.getroot()
@@ -698,16 +698,16 @@
 		timersanitycheck = TimerSanityCheck(self.timer_list,entry)
 		if not timersanitycheck.check():
 			if ignoreTSC != True:
-				print "timer conflict detected!"
-				print timersanitycheck.getSimulTimerList()
+				print("timer conflict detected!")
+				print(timersanitycheck.getSimulTimerList())
 				return timersanitycheck.getSimulTimerList()
 			else:
-				print "ignore timer conflict"
+				print("ignore timer conflict")
 		elif timersanitycheck.doubleCheck():
-			print "ignore double timer"
+			print("ignore double timer")
 			return None
 		entry.timeChanged()
-		print "[Timer] Record " + str(entry)
+		print("[Timer] Record " + str(entry))
 		entry.Timer = self
 		self.addTimerEntry(entry)
 		if dosave:
@@ -800,7 +800,7 @@
 			return None
 
 	def removeEntry(self, entry):
-		print "[Timer] Remove " + str(entry)
+		print("[Timer] Remove " + str(entry))
 		
 		# avoid re-enqueuing
 		entry.repeated = False
@@ -813,9 +813,9 @@
 		if entry.state != entry.StateEnded:
 			self.timeChanged(entry)
 		
-		print "state: ", entry.state
-		print "in processed: ", entry in self.processed_timers
-		print "in running: ", entry in self.timer_list
+		print("state: ", entry.state)
+		print("in processed: ", entry in self.processed_timers)
+		print("in running: ", entry in self.timer_list)
 		# autoincrease instanttimer if possible
 		if not entry.dontSave:
 			for x in self.timer_list:
--- enigma2-nightly.org/skin.py
+++ enigma2-nightly.patched/skin.py
@@ -23,7 +23,7 @@
 }
 
 def dump(x, i=0):
-	print " " * i + str(x)
+	print(" " * i + str(x))
 	try:
 		for n in x.childNodes:
 			dump(n, i + 1)
@@ -82,8 +82,8 @@
 		addSkin(name, SCOPE_CONFIG)
 	else:
 		addSkin('skin_user.xml', SCOPE_CONFIG)
-except (SkinError, IOError, AssertionError), err:
-	print "not loading user skin: ", err
+except (SkinError, IOError, AssertionError) as err:
+	print("not loading user skin: ", err)
 
 # some boxes lie about their dimensions
 addSkin('skin_box.xml')
@@ -101,13 +101,13 @@
 
 try:
 	if not addSkin(config.skin.primary_skin.value):
-		raise SkinError, "primary skin not found"
-except Exception, err:
-	print "SKIN ERROR:", err
+		raise SkinError("primary skin not found")
+except Exception as err:
+	print("SKIN ERROR:", err)
 	skin = DEFAULT_SKIN
 	if config.skin.primary_skin.value == skin:
 		skin = 'skin.xml'
-	print "defaulting to standard skin...", skin
+	print("defaulting to standard skin...", skin)
 	config.skin.primary_skin.value = skin
 	addSkin(skin)
 	del skin
@@ -204,7 +204,7 @@
 	size = None
 	pos = None
 	font = None
-	for attrib, value in node.items():
+	for attrib, value in list(node.items()):
 		if attrib not in ignore:
 			if attrib in filenames:
 				value = resolveFilename(SCOPE_SKIN_IMAGE, value, path_prefix=skin_path_prefix)
@@ -256,17 +256,17 @@
 		try:
 			getattr(self, attrib)(value)
 		except AttributeError:
-			print "[Skin] Attribute not implemented:", attrib, "value:", value
-		except SkinError, ex:
-			print "[Skin] Error:", ex
+			print("[Skin] Attribute not implemented:", attrib, "value:", value)
+		except SkinError as ex:
+			print("[Skin] Error:", ex)
 	def applyAll(self, attrs):
 		for attrib, value in attrs:
 			try:
 				getattr(self, attrib)(value)
 			except AttributeError:
-				print "[Skin] Attribute not implemented:", attrib, "value:", value
-			except SkinError, ex:
-				print "[Skin] Error:", ex
+				print("[Skin] Attribute not implemented:", attrib, "value:", value)
+			except SkinError as ex:
+				print("[Skin] Error:", ex)
 	def position(self, value):
 		if isinstance(value, tuple):
 			self.guiObject.move(ePoint(*value))
@@ -321,7 +321,7 @@
 					"orRightToLeft": (self.guiObject.orHorizontal, True),
 				}[value])
 		except KeyError:
-			print "oprientation must be either orVertical or orHorizontal!"
+			print("oprientation must be either orVertical or orHorizontal!")
 	def valign(self, value):
 		try:
 			self.guiObject.setVAlign(
@@ -330,7 +330,7 @@
 					"bottom": self.guiObject.alignBottom
 				}[value])
 		except KeyError:
-			print "valign must be either top, center or bottom!"
+			print("valign must be either top, center or bottom!")
 	def halign(self, value):
 		try:
 			self.guiObject.setHAlign(
@@ -340,7 +340,7 @@
 					"block": self.guiObject.alignBlock
 				}[value])
 		except KeyError:
-			print "halign must be either left, center, right or block!"
+			print("halign must be either left, center, right or block!")
 	def textOffset(self, value):
 		x, y = value.split(',')
 		self.guiObject.setTextOffset(ePoint(int(x) * self.scale[0][0] / self.scale[0][1], int(y) * self.scale[1][0] / self.scale[1][1]))
@@ -351,7 +351,7 @@
 				fv = eWindow.__dict__[f]
 				self.guiObject.setFlag(fv)
 			except KeyError:
-				print "illegal flag %s!" % f
+				print("illegal flag %s!" % f)
 	def backgroundColor(self, value):
 		self.guiObject.setBackgroundColor(parseColor(value))
 	def backgroundColorSelected(self, value):
@@ -482,8 +482,8 @@
 				width = int(get("width", size))
 				global fonts
 				fonts[name] = (font, size, height, width)
-			except Exception, ex:
-				print "[SKIN] bad font alias", ex
+			except Exception as ex:
+				print("[SKIN] bad font alias", ex)
 
 
 	for c in skin.findall("subtitles"):
@@ -594,7 +594,7 @@
 						elem.clear()
 						continue
 					if name in dom_screens:
-						print "loadSkin: Screen already defined elsewhere:", name
+						print("loadSkin: Screen already defined elsewhere:", name)
 						elem.clear()
 					else:
 						dom_screens[name] = (elem, path)
@@ -743,7 +743,7 @@
 	# try uncompiled embedded skin
 	if myscreen is None and getattr(screen, "skin", None):
 		skin = screen.skin
-		print "[SKIN] Parsing embedded skin", name
+		print("[SKIN] Parsing embedded skin", name)
 		if (isinstance(skin, tuple)):
 			for s in skin:
 				candidate = xml.etree.cElementTree.fromstring(s)
@@ -753,13 +753,13 @@
 						myscreen = candidate 
 						break;
 			else:
-				print "[SKIN] Hey, no suitable screen!"
+				print("[SKIN] Hey, no suitable screen!")
 		else:
 			myscreen = xml.etree.cElementTree.fromstring(skin)
 		if myscreen:
 			screen.parsedSkin = myscreen
 	if myscreen is None:
-		print "[SKIN] No skin to read..."
+		print("[SKIN] No skin to read...")
 		myscreen = screen.parsedSkin = xml.etree.cElementTree.fromstring("<screen></screen>")
 
 	screen.skinAttributes = [ ]
@@ -790,7 +790,7 @@
 		wname = get_attr('name')
 		wsource = get_attr('source')
 		if wname is None and wsource is None:
-			print "widget has no name and no source!"
+			print("widget has no name and no source!")
 			return
 		if wname:
 			#print "Widget name=", wname
@@ -822,10 +822,10 @@
 				source = scr.get(path[0])
 				if isinstance(source, ObsoleteSource):
 					# however, if we found an "obsolete source", issue warning, and resolve the real source.
-					print "WARNING: SKIN '%s' USES OBSOLETE SOURCE '%s', USE '%s' INSTEAD!" % (name, wsource, source.new_source)
-					print "OBSOLETE SOURCE WILL BE REMOVED %s, PLEASE UPDATE!" % (source.removal_date)
+					print("WARNING: SKIN '%s' USES OBSOLETE SOURCE '%s', USE '%s' INSTEAD!" % (name, wsource, source.new_source))
+					print("OBSOLETE SOURCE WILL BE REMOVED %s, PLEASE UPDATE!" % (source.removal_date))
 					if source.description:
-						print source.description
+						print(source.description)
 					wsource = source.new_source
 				else:
 					# otherwise, use that source.
@@ -868,7 +868,7 @@
 			codeText = widget.text.strip()
 			widgetType = widget.attrib.get('type')
 			code = compile(codeText, "skin applet", "exec")
-		except Exception, ex:
+		except Exception as ex:
 			raise SkinError("applet failed to compile: " + str(ex))
 		if widgetType == "onLayoutFinish":
 			screen.onLayoutFinish.append(code)
@@ -894,8 +894,8 @@
 	                p = processors.get(w.tag, process_none)
 			try:
 		                p(w, context)
-			except SkinError, e:
-				print "[Skin] SKIN ERROR in screen '%s' widget '%s':" % (name, w.tag), e
+			except SkinError as e:
+				print("[Skin] SKIN ERROR in screen '%s' widget '%s':" % (name, w.tag), e)
 
 	def process_panel(widget, context):
 	        n = widget.attrib.get('name')
@@ -903,7 +903,7 @@
 			try:
 				s = dom_screens[n]
 			except KeyError:
-				print "[SKIN] Unable to find screen '%s' referred in screen '%s'" % (n, name)
+				print("[SKIN] Unable to find screen '%s' referred in screen '%s'" % (n, name))
 			else:
 				process_screen(s[0], context)
 		layout = widget.attrib.get('layout')
@@ -913,7 +913,7 @@
 		        cc = SkinContext
 		try:
 			c = cc(context, widget.attrib.get('position'), widget.attrib.get('size'), widget.attrib.get('font'))
-		except Exception, ex:
+		except Exception as ex:
 		        raise SkinError("Failed to create skincontext (%s,%s,%s) in %s: %s" % (widget.attrib.get('position'), widget.attrib.get('size'), widget.attrib.get('font'), context, ex) )
 		process_screen(widget, c)
 
@@ -930,8 +930,8 @@
 		context.x = 0 # reset offsets, all components are relative to screen
 		context.y = 0 # coordinates.
 		process_screen(myscreen, context)
-	except Exception, e:
-		print "[Skin] SKIN ERROR in %s:" % name, e
+	except Exception as e:
+		print("[Skin] SKIN ERROR in %s:" % name, e)
 
 	from Components.GUIComponent import GUIComponent
 	nonvisited_components = [x for x in set(screen.keys()) - visited_components if isinstance(x, GUIComponent)]
--- enigma2-nightly.org/tests/enigma.py
+++ enigma2-nightly.patched/tests/enigma.py
@@ -25,10 +25,10 @@
 	def __init__(self):
 		self.timeout = slot()
 		self.next_activation = None
-		print "NEW TIMER"
+		print("NEW TIMER")
 	
 	def start(self, msec, singleshot = False):
-		print "start timer", msec
+		print("start timer", msec)
 		self.next_activation = time.time() + msec / 1000.0
 		self.msec = msec
 		self.singleshot = singleshot
@@ -51,7 +51,7 @@
 	assert len(running_timers), "no running timers, so nothing will ever happen!"
 	running_timers.sort(key=lambda x: x.next_activation)
 	
-	print "running:", running_timers
+	print("running:", running_timers)
 	
 	next_timer = running_timers[0]
 
@@ -192,22 +192,22 @@
 		eAVSwitch.instance = self
 
 	def setColorFormat(self, value):
-		print "[eAVSwitch] color format set to %d" % value
+		print("[eAVSwitch] color format set to %d" % value)
 
 	def setAspectRatio(self, value):
-		print "[eAVSwitch] aspect ratio set to %d" % value
+		print("[eAVSwitch] aspect ratio set to %d" % value)
 
 	def setWSS(self, value):
-		print "[eAVSwitch] wss set to %d" % value
+		print("[eAVSwitch] wss set to %d" % value)
 
 	def setSlowblank(self, value):
-		print "[eAVSwitch] wss set to %d" % value
+		print("[eAVSwitch] wss set to %d" % value)
 
 	def setVideomode(self, value):
-		print "[eAVSwitch] wss set to %d" % value
+		print("[eAVSwitch] wss set to %d" % value)
 
 	def setInput(self, value):
-		print "[eAVSwitch] wss set to %d" % value
+		print("[eAVSwitch] wss set to %d" % value)
 
 eAVSwitch()
 
@@ -224,22 +224,22 @@
 		eRFmod.instance = self
 
 	def setFunction(self, value):
-		print "[eRFmod] set function to %d" % value
+		print("[eRFmod] set function to %d" % value)
 
 	def setTestmode(self, value):
-		print "[eRFmod] set testmode to %d" % value
+		print("[eRFmod] set testmode to %d" % value)
 
 	def setSoundFunction(self, value):
-		print "[eRFmod] set sound function to %d" % value
+		print("[eRFmod] set sound function to %d" % value)
 
 	def setSoundCarrier(self, value):
-		print "[eRFmod] set sound carrier to %d" % value
+		print("[eRFmod] set sound carrier to %d" % value)
 
 	def setChannel(self, value):
-		print "[eRFmod] set channel to %d" % value
+		print("[eRFmod] set channel to %d" % value)
 
 	def setFinetune(self, value):
-		print "[eRFmod] set finetune to %d" % value
+		print("[eRFmod] set finetune to %d" % value)
 
 eRFmod()
 
@@ -255,13 +255,13 @@
 		eDBoxLCD.instance = self
 
 	def setLCDBrightness(self, value):
-		print "[eDBoxLCD] set brightness to %d" % value
+		print("[eDBoxLCD] set brightness to %d" % value)
 
 	def setLCDContrast(self, value):
-		print "[eDBoxLCD] set contrast to %d" % value
+		print("[eDBoxLCD] set contrast to %d" % value)
 
 	def setInverted(self, value):
-		print "[eDBoxLCD] set inverted to %d" % value
+		print("[eDBoxLCD] set inverted to %d" % value)
 
 eDBoxLCD();
 
@@ -284,13 +284,13 @@
 
 ##################### ENIGMA CHROOT
 
-print "import directories"
+print("import directories")
 import Tools.Directories
-print "done"
+print("done")
 
 chroot="."
 
-for (x, (y, z)) in Tools.Directories.defaultPaths.items():
+for (x, (y, z)) in list(Tools.Directories.defaultPaths.items()):
 	Tools.Directories.defaultPaths[x] = (chroot + y, z)
 
 Tools.Directories.defaultPaths[Tools.Directories.SCOPE_SKIN] = ("../data/", Tools.Directories.PATH_DONTCREATE)
@@ -298,9 +298,9 @@
 
 ##################### ENIGMA CONFIG
 
-print "import config"
+print("import config")
 import Components.config
-print "done"
+print("done")
 
 my_config = [
 "config.skin.primary_skin=None\n"
@@ -318,17 +318,17 @@
 ##################### ENIGMA STARTUP:
 
 def init_nav():
-	print "init nav"
+	print("init nav")
 	import Navigation, NavigationInstance
 	NavigationInstance.instance = Navigation.Navigation()
 
 def init_record_config():
-	print "init recording"
+	print("init recording")
 	import Components.RecordingConfig
 	Components.RecordingConfig.InitRecordingConfig()
 
 def init_parental_control():
-	print "init parental"
+	print("init parental")
 	from Components.ParentalControl import InitParentalControl
 	InitParentalControl()
 
--- enigma2-nightly.org/tests/events.py
+++ enigma2-nightly.patched/tests/events.py
@@ -5,7 +5,7 @@
 
 def event(self, name, args, kwargs):
 	global recorded_events
-	print "*EVENT*", time.time(), self, name, args, kwargs
+	print("*EVENT*", time.time(), self, name, args, kwargs)
 	recorded_events.append((time.time(), self, name, args, kwargs))
 
 def eventfnc(f):
@@ -40,22 +40,22 @@
 		expected = f.read()
 		f.close()
 	except:
-		print "NO TEST RESULT FOUND, creating new"
+		print("NO TEST RESULT FOUND, creating new")
 		f = open(test_name + ".new_results", "wb")
 		f.write(results)
 		f.close()
 	
-	print results
+	print(results)
 	
 	if expected is not None:
-		print "expected:"
+		print("expected:")
 		if expected != results:
 			open(test_name + ".bogus_results", "wb").write(results)
 			raise tests.TestError("test data does not match")
 		else:
-			print "test compared ok"
+			print("test compared ok")
 	else:
-		print "no test data to compare with."
+		print("no test data to compare with.")
 
 def log(fnc, base_time = 0, test_name = "test", *args, **kwargs):
 	import fake_time
@@ -65,6 +65,6 @@
 	try:
 		fnc(*args, **kwargs)
 		event(None, "test_completed", [], {"test_name": test_name})
-	except tests.TestError,c:
+	except tests.TestError as c:
 		event(None, "test_failed", [], {"test_name": test_name, "reason": str(c)})
 	end_log(test_name)
--- enigma2-nightly.org/tests/fake_time.py
+++ enigma2-nightly.patched/tests/fake_time.py
@@ -26,6 +26,6 @@
 def my_sleep(sleep):
 	global time_offset
 	time_offset -= sleep
-	print "(faking %f seconds)" % sleep
+	print("(faking %f seconds)" % sleep)
 
 time.sleep = my_sleep
--- enigma2-nightly.org/tests/test_timer.py
+++ enigma2-nightly.patched/tests/test_timer.py
@@ -12,8 +12,8 @@
 	at = time.time()
 	
 	t = NavigationInstance.instance.RecordTimer
-	print t
-	print "old mwt:", t.MaxWaitTime
+	print(t)
+	print("old mwt:", t.MaxWaitTime)
 	t.MaxWaitTime = 86400 * 1000
 	
 	# hack:
@@ -48,25 +48,25 @@
 	# run virtual environment
 	enigma.run(sim_length)
 	
-	print "done."
+	print("done.")
 	
 	timers = t.processed_timers  + t.timer_list
 	
-	print "start: %s" % (time.ctime(at + 10))
+	print("start: %s" % (time.ctime(at + 10)))
 	
 	assert len(timers) == 1
 	
 	for t in timers:
-		print "begin=%d, end=%d, repeated=%d, state=%d" % (t.begin - at, t.end - at, t.repeated, t.state)
-		print "begin: %s" % (time.ctime(t.begin))
-		print "end: %s" % (time.ctime(t.end))
+		print("begin=%d, end=%d, repeated=%d, state=%d" % (t.begin - at, t.end - at, t.repeated, t.state))
+		print("begin: %s" % (time.ctime(t.begin)))
+		print("end: %s" % (time.ctime(t.end)))
 
 	# if repeat, check if the calculated repeated time of day matches the initial time of day
 	if repeat:
 		t_initial = time.localtime(at + timer_start)
 		t_repeated = time.localtime(timers[0].begin)
-		print t_initial
-		print t_repeated
+		print(t_initial)
+		print(t_repeated)
 		
 	if t_initial[3:6] != t_repeated[3:6]:
 		raise tests.TestError("repeated timer time of day does not match")
@@ -92,5 +92,5 @@
 time.tzset()
 
 #log(test_timer, test_name = "test_timer_repeating", base_time = calendar.timegm((2007, 3, 1, 12, 0, 0)), repeat=0x7f, sim_length = 86400 * 7)
-log(test_timer, test_name = "test_timer_repeating_dst_skip", base_time = calendar.timegm((2007, 03, 20, 0, 0, 0)), timer_start = 3600, repeat=0x7f, sim_length = 86400 * 7)
+log(test_timer, test_name = "test_timer_repeating_dst_skip", base_time = calendar.timegm((2007, 0o3, 20, 0, 0, 0)), timer_start = 3600, repeat=0x7f, sim_length = 86400 * 7)
 #log(test_timer, test_name = "test_timer_repeating_dst_start", base_time = calendar.timegm((2007, 03, 20, 0, 0, 0)), timer_start = 10000, repeat=0x7f, sim_length = 86400 * 7)
--- enigma2-nightly.org/timer.py
+++ enigma2-nightly.patched/timer.py
@@ -191,7 +191,7 @@
 	def calcNextActivation(self):
 		now = time()
 		if self.lastActivation > now:
-			print "[timer.py] timewarp - re-evaluating all processed timers."
+			print("[timer.py] timewarp - re-evaluating all processed timers.")
 			tl = self.processed_timers
 			self.processed_timers = [ ]
 			for x in tl:
@@ -217,7 +217,7 @@
 		self.setNextActivation(now, min)
 
 	def timeChanged(self, timer):
-		print "time changed"
+		print("time changed")
 		timer.timeChanged()
 		if timer.state == TimerEntry.StateEnded:
 			self.processed_timers.remove(timer)
@@ -225,7 +225,7 @@
 			try:
 				self.timer_list.remove(timer)
 			except:
-				print "[timer] Failed to remove, not in list"
+				print("[timer] Failed to remove, not in list")
 				return
 		# give the timer a chance to re-enqueue
 		if timer.state == TimerEntry.StateEnded:
--- enigma2-nightly.org/tools/create_picon_e1_to_e2.py
+++ enigma2-nightly.patched/tools/create_picon_e1_to_e2.py
@@ -66,7 +66,7 @@
 	except:
 		pass
 
-	print sat[0:2] + '.' + sat[-1:] + 'E' + '_' + "%X" % ref[0] + '.png'
+	print(sat[0:2] + '.' + sat[-1:] + 'E' + '_' + "%X" % ref[0] + '.png')
 	try:
 		os.rename(sat[0:-1] + 'E' + '_' + "%X" % ref[0] + '.png', sat + '/' + servicetype + '/' + filename)
 	except:
--- enigma2-nightly.org/tools/create_picon_links.py
+++ enigma2-nightly.patched/tools/create_picon_links.py
@@ -39,5 +39,5 @@
 	if os.access(filename, os.F_OK) and not os.access(linkname, os.F_OK):
 		os.symlink(filename, linkname)
 	else:
-		print "could not find %s (%s)" % (filename, name)
+		print("could not find %s (%s)" % (filename, name))
 	f =f[3:]
--- enigma2-nightly.org/tools/svg2skin.py
+++ enigma2-nightly.patched/tools/svg2skin.py
@@ -79,7 +79,7 @@
 			font = ' font="Regular;%d"' % px(styles["font-size"])
 		else:
 			font = ""
-		print """\t\t<widget source="%s" render="Label" position="%d,%d" size="%d,%d" %s />""" % (id, x, y, width, height, font)
+		print("""\t\t<widget source="%s" render="Label" position="%d,%d" size="%d,%d" %s />""" % (id, x, y, width, height, font))
 
 parser = make_parser()
 contentHandler = parseXML()
@@ -88,6 +88,6 @@
 parser.parse(sys.argv[1])
 bboxi = tuple([int(x) for x in contentHandler.bbox])
 contentHandler.find_bbox = False
-print '\t<screen name="" position="%d,%d" size="%d,%d" title="">' % bboxi
+print('\t<screen name="" position="%d,%d" size="%d,%d" title="">' % bboxi)
 parser.parse(sys.argv[1])
-print '\t</screen>'
+print('\t</screen>')
--- enigma2-nightly.org/tools/host_tools/FormatConverter/datasource.py
+++ enigma2-nightly.patched/tools/host_tools/FormatConverter/datasource.py
@@ -14,15 +14,15 @@
 		return "N/A"
 	
 	def getStatus(self):
-		text = str(len(self.transponderlist.keys())) + " Satellites" + "\n"
+		text = str(len(list(self.transponderlist.keys()))) + " Satellites" + "\n"
 		return text
 	
 	def printAll(self):
-		for sat in self.transponderlist.keys():
-			print "***********"
-			print "sat:", sat, self.satnames[sat]
+		for sat in list(self.transponderlist.keys()):
+			print("***********")
+			print("sat:", sat, self.satnames[sat])
 			for transponder in self.transponderlist[sat]:
-				print transponder
+				print(transponder)
 	
 	def clear(self):
 		self.transponderlist = {}
@@ -35,12 +35,12 @@
 		pass
 	
 	def addSat(self, satname, satpos):
-		if not self.transponderlist.has_key(satpos):
+		if satpos not in self.transponderlist:
 			self.transponderlist[satpos] = []
 			self.satnames[satpos] = satname
 			
 	def addTransponder(self, satpos, transponder):
-		if len(transponder.keys()) >= 6:
+		if len(list(transponder.keys())) >= 6:
 			self.transponderlist[satpos].append(transponder)
 			
 class genericdatasource(datasource):
@@ -65,43 +65,43 @@
 		while choice is not None:
 			choice = inputChoices(["select source", "select destination", "copy now!"])
 			if choice == 0:
-				print "\nselect source:"
+				print("\nselect source:")
 				self.source = self.selectDatasource()
 			elif choice == 1:
-				print "\nselect destination"
+				print("\nselect destination")
 				self.destination = self.selectDatasource()
 			elif choice == 2:
 				self.docopymerge(action)
 
 	def docopymerge(self, action = "copy"):
 		if self.source is None:
-			print "select a source first!"
+			print("select a source first!")
 		elif self.destination is None:
-			print "select a destination first!"
+			print("select a destination first!")
 		else:
 			if action == "copy":
-				print "copying ",
+				print("copying ", end=' ')
 			elif action == "merge":
-				print "merging ",
-			print "from %s to %s" % (self.source.getName(), self.destination.getName())
+				print("merging ", end=' ')
+			print("from %s to %s" % (self.source.getName(), self.destination.getName()))
 			countsat = 0
 			counttransponder = 0
 			if action == "copy":
 				self.destination.clear()
-			for satpos in self.source.transponderlist.keys():
+			for satpos in list(self.source.transponderlist.keys()):
 				countsat += 1
 				self.destination.addSat(self.source.satnames[satpos], satpos)
 				for transponder in self.source.transponderlist[satpos]:
 					counttransponder += 1
 					self.destination.addTransponder(satpos, transponder)
-			print "copied %d sats with %d transponders" % (countsat, counttransponder)
+			print("copied %d sats with %d transponders" % (countsat, counttransponder))
 				
 	def selectDatasource(self):
 		list = []
 		sources = []
 		for source in self.datasources:
 			if source != self:
-				list.append(source.getName() + (" (%d sats)" % len(source.transponderlist.keys())))
+				list.append(source.getName() + (" (%d sats)" % len(list(source.transponderlist.keys()))))
 				sources.append(source)
 		choice = inputChoices(list)
 		if choice is None:
--- enigma2-nightly.org/tools/host_tools/FormatConverter/input.py
+++ enigma2-nightly.patched/tools/host_tools/FormatConverter/input.py
@@ -10,9 +10,9 @@
 		repeat = False
 		count = 0
 		for item in list:
-			print count, "-", item
+			print(count, "-", item)
 			count += 1
-		print backcmd, "-", backtext
+		print(backcmd, "-", backtext)
 		input = inputText()
 		if input == backcmd:
 			return None
--- enigma2-nightly.org/tools/host_tools/FormatConverter/lamedb.py
+++ enigma2-nightly.patched/tools/host_tools/FormatConverter/lamedb.py
@@ -22,7 +22,7 @@
 		versionstring = lines[0].split('/')
 		version = int(versionstring[1])
 		if 3 > version or 4 < version:
-		        print "unsupported lamedb version"
+		        print("unsupported lamedb version")
 		        return
 
 		transpondersreading = False
@@ -39,7 +39,7 @@
 				if ord(line[0]) == 9:
 					transponder = line.strip().split(' ')[1].split(':')
 					sat = transponder[4]
-					if not sats.has_key(sat):
+					if sat not in sats:
 						sats[sat] = []
 					sats[sat].append((transponder, tsid, onid))
 					tsid = None
@@ -48,11 +48,11 @@
 					data = line.strip().split(":")
 					tsid = str(int(data[1], 16))
 					onid = str(int(data[2], 16))
-		satlist = sats.keys()
+		satlist = list(sats.keys())
 		satlist.sort()
 		
 		for sat in satlist:
-			print sat
+			print(sat)
 			self.addSat(sat, sat)
 			transponders = sats[sat]
 			transponders.sort(key = lambda a: a[0])
@@ -60,7 +60,7 @@
 				transponder = transpondertuple[0]
 				tsid = transpondertuple[1]
 				onid = transpondertuple[2]
-				print transponder, tsid, onid
+				print(transponder, tsid, onid)
 				tmp_transponder = {}
 				tmp_transponder["frequency"] = transponder[0]
 				tmp_transponder["symbol_rate"] = transponder[1]
--- enigma2-nightly.org/tools/host_tools/FormatConverter/lamedb2satxml.py
+++ enigma2-nightly.patched/tools/host_tools/FormatConverter/lamedb2satxml.py
@@ -6,7 +6,7 @@
 import sys
 
 if len(sys.argv) != 3:
-	print "usage: %s <lamedb> <satellites.xml>" % sys.argv[0]
+	print("usage: %s <lamedb> <satellites.xml>" % sys.argv[0])
 	sys.exit()
 
 gen = genericdatasource()
--- enigma2-nightly.org/tools/host_tools/FormatConverter/main.py
+++ enigma2-nightly.patched/tools/host_tools/FormatConverter/main.py
@@ -22,13 +22,13 @@
 	os.system("/usr/bin/clear")
 	list = []
 	for index in range(len(datasources)):
-		list.append(datasources[index].getName() + (" (%d sats)" % len(datasources[index].transponderlist.keys())))
+		list.append(datasources[index].getName() + (" (%d sats)" % len(list(datasources[index].transponderlist.keys()))))
 	index = inputChoices(list, "q", "quit")
 	if index is None:
 		break		
 	
 	while(True):
-		print datasources[index].getStatus()
+		print(datasources[index].getStatus())
 		list = []
 		for action in datasources[index].getCapabilities():
 			list.append(action[0])
--- enigma2-nightly.org/tools/host_tools/FormatConverter/satxml.py
+++ enigma2-nightly.patched/tools/host_tools/FormatConverter/satxml.py
@@ -10,7 +10,7 @@
 		datasource.__init__(self)
 		
 		if not os.path.isfile(filename):
-			print "File %s doesn't exist. Creating it." % filename
+			print("File %s doesn't exist. Creating it." % filename)
 		
 	def getStatus(self):
 		text = datasource.getStatus(self)
@@ -23,20 +23,20 @@
 		return "satellites.xml"
 	
 	def setFilename(self):
-		print "Please give a filename <satellites.xml>:"
+		print("Please give a filename <satellites.xml>:")
 		filename = inputText()
 		if filename == "":
 			self.filename = "satellites.xml"
 		else:
 			self.filename = filename
-		print "Filename set to %s" % self.filename
+		print("Filename set to %s" % self.filename)
 
 	def read(self):
 		basicsatxml = minidom.parse(self.filename)
 
 		for sat in basicsatxml.firstChild.childNodes:
 			if sat.nodeType == sat.ELEMENT_NODE and sat.localName == "sat":
-				print sat.localName
+				print(sat.localName)
 				satname = str(sat.getAttribute("name"))
 				satpos = str(sat.getAttribute("position"))
 				self.addSat(satname, satpos)
@@ -48,16 +48,16 @@
 							entry = str(transponder.getAttribute(param))
 							if entry != "":
 								parameters[param] = entry
-						if len(parameters.keys()) > 1:
+						if len(list(parameters.keys())) > 1:
 							self.addTransponder(satpos, parameters)
-		print self.transponderlist
+		print(self.transponderlist)
 	
 	def write(self):
 		satxml = Document()
 		satellites = satxml.createElement("satellites")
 		satxml.appendChild(satellites)
-		satlist = self.transponderlist.keys()
-		print self.transponderlist
+		satlist = list(self.transponderlist.keys())
+		print(self.transponderlist)
 		satlist.sort()
 
 		for sat in satlist:
@@ -73,11 +73,11 @@
 				xmltransponder = satxml.createElement("transponder")
 				paramlist = ["frequency", "symbol_rate", "polarization", "fec", "system", "modulation", "tsid", "onid"]
 				for param in paramlist:
-					if transponder.has_key(param):
+					if param in transponder:
 						xmltransponder.setAttribute(param, transponder[param])
 				xmlsat.appendChild(xmltransponder)
 		prettyxml = satxml.toprettyxml()
-		print prettyxml
+		print(prettyxml)
 		file = open(self.filename, "w")
 		file.write(prettyxml)
 		file.close()
--- enigma2-nightly.org/lib/python/Components/Netlink.py
+++ enigma2-nightly.patched/lib/python/Components/Netlink.py
@@ -27,7 +27,7 @@
 # Quick unit test (you can run this on any Linux machine)
 if __name__ == '__main__':
 	nls = NetlinkSocket()
-	print "socket no:", nls.fileno()
+	print("socket no:", nls.fileno())
 	while 1:
 		for item in nls.parse():
-			print repr(item)
\
+			print(repr(item))
--- enigma2-nightly.org/lib/python/Screens/Scart.py
+++ enigma2-nightly.patched/lib/python/Screens/Scart.py
@@ -1,5 +1,5 @@
-from Screen import Screen
-from MessageBox import MessageBox
+from .Screen import Screen
+from .MessageBox import MessageBox
 from Components.AVSwitch import AVSwitch
 from Tools import Notifications
 
@@ -50,5 +50,5 @@
 					if notification[1].msgBoxID == "scart_msgbox":
 						notification[1].close()
 				except:
-					print "other notification is open. try another one."
+					print("other notification is open. try another one.")
 			
\
--- enigma2-nightly.org/lib/python/Screens/ServiceScan.py
+++ enigma2-nightly.patched/lib/python/Screens/ServiceScan.py
@@ -1,4 +1,4 @@
-from Screen import Screen
+from .Screen import Screen
 from Components.ServiceScan import ServiceScan as CScan
 from Components.ProgressBar import ProgressBar
 from Components.Label import Label
@@ -31,9 +31,9 @@
 class ServiceScan(Screen):
 
 	def ok(self):
-		print "ok"
+		print("ok")
 		if self["scan"].isDone():
-			if `self.currentInfobar`.endswith(".InfoBar'>"):
+			if repr(self.currentInfobar).endswith(".InfoBar'>"):
 				if self.currentServiceList is not None:
 					self.currentServiceList.setTvMode()
 					bouquets = self.currentServiceList.getBouquetList()
@@ -89,5 +89,5 @@
 		self["scan"] = CScan(self["scan_progress"], self["scan_state"], self["servicelist"], self["pass"], self.scanList, self["network"], self["transponder"], self["FrontendInfo"], self.session.summary)
 
 	def createSummary(self):
-		print "ServiceScanCreateSummary"
+		print("ServiceScanCreateSummary")
 		return ServiceScanSummary
\
--- enigma2-nightly.org/lib/python/Screens/VirtualKeyBoard.py
+++ enigma2-nightly.patched/lib/python/Screens/VirtualKeyBoard.py
@@ -1,6 +1,6 @@
 # -*- coding: UTF-8 -*-
 from enigma import eListboxPythonMultiContent, gFont, RT_HALIGN_CENTER, RT_VALIGN_CENTER, getPrevAsciiCode
-from Screen import Screen
+from .Screen import Screen
 from Components.Language import language
 from Components.ActionMap import NumberActionMap
 from Components.Sources.StaticText import StaticText
@@ -125,117 +125,117 @@
 	def setLang(self):
 		if self.lang == 'de_DE':
 			self.keys_list = [
-				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
-				[u"q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
-				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
-				[u"<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"@", u"", u"OK"]]
+				["EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
+				["q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
+				["a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
+				["<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
+				["SHIFT", u"SPACE", u"@", u"", u"OK"]]
 			self.shiftkeys_list = [
-				[u"EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
-				[u"Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
-				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
-				[u">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"?", u"\\", u"OK"]]
+				["EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
+				["Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
+				["A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
+				[">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
+				["SHIFT", u"SPACE", u"?", u"\\", u"OK"]]
 			self.nextLang = 'es_ES'
 		elif self.lang == 'es_ES':
 			#still missing keys (u"")
 			self.keys_list = [
-				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
-				[u"q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
-				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
-				[u"<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"@", u"", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
+				["EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
+				["q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
+				["a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
+				["<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
+				["SHIFT", u"SPACE", u"@", u"", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
 			self.shiftkeys_list = [
-				[u"EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
-				[u"Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
-				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
-				[u">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"?", u"\\", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
+				["EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
+				["Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
+				["A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
+				[">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
+				["SHIFT", u"SPACE", u"?", u"\\", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
 			self.nextLang = 'fi_FI'
 		elif self.lang == 'fi_FI':
 			self.keys_list = [
-				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
-				[u"q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
-				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
-				[u"<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"@", u"", u"", u"OK"]]
+				["EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
+				["q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
+				["a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
+				["<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
+				["SHIFT", u"SPACE", u"@", u"", u"", u"OK"]]
 			self.shiftkeys_list = [
-				[u"EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
-				[u"Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
-				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
-				[u">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"?", u"\\", u"", u"OK"]]
+				["EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
+				["Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
+				["A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
+				[">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
+				["SHIFT", u"SPACE", u"?", u"\\", u"", u"OK"]]
 			self.nextLang = 'ru_RU'
 		elif self.lang == 'ru_RU':
 			self.keys_list = [
-				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
-				[u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"+"],
-				[u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"#"],
-				[u"<", u"", u"", u"", u"", u"", u"", u"", u",", ".", u"-", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"@", u"", u"", u"", u"OK"]]
+				["EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
+				["", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"+"],
+				["", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"#"],
+				["<", u"", u"", u"", u"", u"", u"", u"", u",", ".", u"-", u"CLEAR"],
+				["SHIFT", u"SPACE", u"@", u"", u"", u"", u"OK"]]
 			self.shiftkeys_list = [
-				[u"EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
-				[u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"I", u"", u"*"],
-				[u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"'"],
-				[u">", u"", u"", u"", u"", u"", u"", u"", u";", u":", u"_", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"?", u"\\", u"", u"", u"",  u"", u"OK"]]
+				["EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
+				["", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"I", u"", u"*"],
+				["", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"'"],
+				[">", u"", u"", u"", u"", u"", u"", u"", u";", u":", u"_", u"CLEAR"],
+				["SHIFT", u"SPACE", u"?", u"\\", u"", u"", u"",  u"", u"OK"]]
 			self.nextLang = 'sv_SE'
 		elif self.lang == 'sv_SE':
 			self.keys_list = [
-				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
-				[u"q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
-				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
-				[u"<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"@", u"", u"", u"OK"]]
+				["EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
+				["q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
+				["a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"", u"#"],
+				["<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
+				["SHIFT", u"SPACE", u"@", u"", u"", u"OK"]]
 			self.shiftkeys_list = [
-				[u"EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
-				[u"Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
-				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
-				[u">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"?", u"\\", u"", u"OK"]]
+				["EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
+				["Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
+				["A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
+				[">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
+				["SHIFT", u"SPACE", u"?", u"\\", u"", u"OK"]]
 			self.nextLang = 'sk_SK'
 		elif self.lang =='sk_SK':
 			self.keys_list = [
-				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
-				[u"q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
-				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"@", u"#"],
-				[u"<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
+				["EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
+				["q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
+				["a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"@", u"#"],
+				["<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
+				["SHIFT", u"SPACE", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
 			self.shiftkeys_list = [
-				[u"EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
-				[u"Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
-				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
-				[u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u""],
-				[u">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"?", u"\\", u"", u"", u"", u"", u"", u"", u"OK"]]
+				["EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
+				["Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
+				["A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
+				["", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"", u""],
+				[">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
+				["SHIFT", u"SPACE", u"?", u"\\", u"", u"", u"", u"", u"", u"", u"OK"]]
 			self.nextLang = 'cs_CZ'
 		elif self.lang == 'cs_CZ':
 			self.keys_list = [
-				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
-				[u"q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
-				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"@", u"#"],
-				[u"<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
+				["EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
+				["q", u"w", u"e", u"r", u"t", u"z", u"u", u"i", u"o", u"p", u"", u"+"],
+				["a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u"", u"@", u"#"],
+				["<", u"y", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"-", u"CLEAR"],
+				["SHIFT", u"SPACE", u"", u"", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
 			self.shiftkeys_list = [
-				[u"EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
-				[u"Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
-				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
-				[u">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"?", u"\\", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
+				["EXIT", u"!", u'"', u"", u"$", u"%", u"&", u"/", u"(", u")", u"=", u"BACKSPACE"],
+				["Q", u"W", u"E", u"R", u"T", u"Z", u"U", u"I", u"O", u"P", u"", u"*"],
+				["A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"", u"", u"'"],
+				[">", u"Y", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
+				["SHIFT", u"SPACE", u"?", u"\\", u"", u"", u"", u"", u"", u"", u"", u"OK"]]
 			self.nextLang = 'en_EN'
 		else:
 			self.keys_list = [
-				[u"EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
-				[u"q", u"w", u"e", u"r", u"t", u"y", u"u", u"i", u"o", u"p", u"-", u"["],
-				[u"a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u";", u"'", u"\\"],
-				[u"<", u"z", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"/", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"OK"]]
+				["EXIT", u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"0", u"BACKSPACE"],
+				["q", u"w", u"e", u"r", u"t", u"y", u"u", u"i", u"o", u"p", u"-", u"["],
+				["a", u"s", u"d", u"f", u"g", u"h", u"j", u"k", u"l", u";", u"'", u"\\"],
+				["<", u"z", u"x", u"c", u"v", u"b", u"n", u"m", u",", ".", u"/", u"CLEAR"],
+				["SHIFT", u"SPACE", u"OK"]]
 			self.shiftkeys_list = [
-				[u"EXIT", u"!", u"@", u"#", u"$", u"%", u"^", u"&", u"(", u")", u"=", u"BACKSPACE"],
-				[u"Q", u"W", u"E", u"R", u"T", u"Y", u"U", u"I", u"O", u"P", u"*", u"]"],
-				[u"A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"?", u'"', u"|"],
-				[u">", u"Z", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
-				[u"SHIFT", u"SPACE", u"OK"]]
+				["EXIT", u"!", u"@", u"#", u"$", u"%", u"^", u"&", u"(", u")", u"=", u"BACKSPACE"],
+				["Q", u"W", u"E", u"R", u"T", u"Y", u"U", u"I", u"O", u"P", u"*", u"]"],
+				["A", u"S", u"D", u"F", u"G", u"H", u"J", u"K", u"L", u"?", u'"', u"|"],
+				[">", u"Z", u"X", u"C", u"V", u"B", u"N", u"M", u";", u":", u"_", u"CLEAR"],
+				["SHIFT", u"SPACE", u"OK"]]
 			self.lang = 'en_EN'
 			self.nextLang = 'de_DE'		
 		self["country"].setText(self.lang)
@@ -301,7 +301,7 @@
 			self.close(None)
 		
 		elif text == "BACKSPACE":
-			ss=unicode(self["text"].getText(),"utf-8")
+			ss=str(self["text"].getText(),"utf-8")
 			ss=ss[:-1]
 			self.text = str(ss.encode("utf-8"))
 			self["text"].setText(self.text)
@@ -384,18 +384,18 @@
 
 	def keyNumberGlobal(self, number):
 		self.smsChar = self.sms.getKey(number)
-		print "SMS", number, self.smsChar
+		print("SMS", number, self.smsChar)
 		self.selectAsciiKey(self.smsChar)
 
 	def smsOK(self):
-		print "SMS ok", self.smsChar
+		print("SMS ok", self.smsChar)
 		if self.smsChar and self.selectAsciiKey(self.smsChar):
-			print "pressing ok now"
+			print("pressing ok now")
 			self.okClicked()
 
 	def keyGotAscii(self):
 		self.smsChar = None
-		if self.selectAsciiKey(str(unichr(getPrevAsciiCode()).encode('utf-8'))):
+		if self.selectAsciiKey(str(chr(getPrevAsciiCode()).encode('utf-8'))):
 			self.okClicked()
 
 	def selectAsciiKey(self, char):
--- enigma2-nightly.org/lib/python/Tools/NumericalTextInput.py
+++ enigma2-nightly.patched/lib/python/Tools/NumericalTextInput.py
@@ -4,112 +4,112 @@
 
 # Dict languageCode -> array of strings
 MAP_SEARCH = (
-	u"%_0",
-	u" 1",
-	u"abc2",
-	u"def3",
-	u"ghi4",
-	u"jkl5",
-	u"mno6",
-	u"pqrs7",
-	u"tuv8",
-	u"wxyz9",
+	"%_0",
+	" 1",
+	"abc2",
+	"def3",
+	"ghi4",
+	"jkl5",
+	"mno6",
+	"pqrs7",
+	"tuv8",
+	"wxyz9",
 	)
 MAP_SEARCH_UPCASE = (
-	U"0%_",
-	U"1 ",
-	U"ABC2",
-	U"DEF3",
-	U"GHI4",
-	U"JKL5",
-	U"MNO6",
-	U"PQRS7",
-	U"TUV8",
-	U"WXYZ9",
+	"0%_",
+	"1 ",
+	"ABC2",
+	"DEF3",
+	"GHI4",
+	"JKL5",
+	"MNO6",
+	"PQRS7",
+	"TUV8",
+	"WXYZ9",
 	)
 MAP_DEFAULT = (
-	u"0,?!&@=*'+\"()$~%",
-	u" 1.:;/-_",
-	u"abc2ABC",
-	u"def3DEF",
-	u"ghi4GHI",
-	u"jkl5JKL",
-	u"mno6MNO",
-	u"pqrs7PQRS",
-	u"tuv8TUV",
-	u"wxyz9WXYZ",
+	"0,?!&@=*'+\"()$~%",
+	" 1.:;/-_",
+	"abc2ABC",
+	"def3DEF",
+	"ghi4GHI",
+	"jkl5JKL",
+	"mno6MNO",
+	"pqrs7PQRS",
+	"tuv8TUV",
+	"wxyz9WXYZ",
 	)
 MAP_DE = (
-	u"0,?!&@=*'+\"()$~%",
-	u" 1.:;/-_",
-	u"abc2ABC",
-	u"def3DEF",
-	u"ghi4GHI",
-	u"jkl5JKL",
-	u"mno6MNO",
-	u"pqrs7PQRS",
-	u"tuv8TUV",
-	u"wxyz9WXYZ",
+	"0,?!&@=*'+\"()$~%",
+	" 1.:;/-_",
+	"abc2ABC",
+	"def3DEF",
+	"ghi4GHI",
+	"jkl5JKL",
+	"mno6MNO",
+	"pqrs7PQRS",
+	"tuv8TUV",
+	"wxyz9WXYZ",
 	)
 MAP_ES = (
-	u"0,?!&@=*'+\"()$~%",
-	u" 1.:;/-_",
-	u"abc2ABC",
-	u"def3DEF",
-	u"ghi4GHI",
-	u"jkl5JKL",
-	u"mno6MNO",
-	u"pqrs7PQRS",
-	u"tuv8TUV",
-	u"wxyz9WXYZ",
+	"0,?!&@=*'+\"()$~%",
+	" 1.:;/-_",
+	"abc2ABC",
+	"def3DEF",
+	"ghi4GHI",
+	"jkl5JKL",
+	"mno6MNO",
+	"pqrs7PQRS",
+	"tuv8TUV",
+	"wxyz9WXYZ",
 	)
 MAP_SE = (
-	u"0,?!&@=*'+\"()$~%",
-	u" 1.:;/-_",
-	u"abc2ABC",
-	u"def3DEF",
-	u"ghi4GHI",
-	u"jkl5JKL",
-	u"mno6MNO",
-	u"pqrs7PQRS",
-	u"tuv8TUV",
-	u"wxyz9WXYZ",
+	"0,?!&@=*'+\"()$~%",
+	" 1.:;/-_",
+	"abc2ABC",
+	"def3DEF",
+	"ghi4GHI",
+	"jkl5JKL",
+	"mno6MNO",
+	"pqrs7PQRS",
+	"tuv8TUV",
+	"wxyz9WXYZ",
 	)
 MAP_CZ = (
-	u"0,?'+\"()@$!=&*%",
-	u" 1.:;/-_",
-	u"abc2ABC",
-	u"def3DEF",
-	u"ghi4GHI",
-	u"jkl5JKL",
-	u"mno6MNO",
-	u"pqrs7PQRS",
-	u"tuv8TUV",
-	u"wxyz9WXYZ",
+	"0,?'+\"()@$!=&*%",
+	" 1.:;/-_",
+	"abc2ABC",
+	"def3DEF",
+	"ghi4GHI",
+	"jkl5JKL",
+	"mno6MNO",
+	"pqrs7PQRS",
+	"tuv8TUV",
+	"wxyz9WXYZ",
 	)
 MAP_PL = (
-	u"0,?'+\"()@$!=&*%",
-	u" 1.:;/-_",
-	u"abc2ABC",
-	u"def3DEF",
-	u"ghi4GHI",
-	u"jkl5JKL",
-	u"mno6MNO",
-	u"pqrs7PQRS",
-	u"tuv8TUV",
-	u"wxyz9WXYZ",
+	"0,?'+\"()@$!=&*%",
+	" 1.:;/-_",
+	"abc2ABC",
+	"def3DEF",
+	"ghi4GHI",
+	"jkl5JKL",
+	"mno6MNO",
+	"pqrs7PQRS",
+	"tuv8TUV",
+	"wxyz9WXYZ",
 	)
 MAP_RU = (
-	u"0,?'+\"()@$!=&*%",
-	u" 1.:;/-_",
-	u"abc2ABC",
-	u"def3DEF",
-	u"ghi4GHI",
-	u"jkl5JKL",
-	u"mno6MNO",
-	u"pqrs7PQRS",
-	u"tuv8TUV",
-	u"wxyz9WXYZ",
+	"0,?'+\"()@$!=&*%",
+	" 1.:;/-_",
+	"abc2ABC",
+	"def3DEF",
+	"ghi4GHI",
+	"jkl5JKL",
+	"mno6MNO",
+	"pqrs7PQRS",
+	"tuv8TUV",
+	"wxyz9WXYZ",
 	)
 MAPPINGS = {
 	'de_DE': MAP_DE,
@@ -141,7 +141,7 @@
 			self.mapping = MAPPINGS.get(language.getLanguage(), MAP_DEFAULT)
 
 	def setUseableChars(self, useable):
-		self.useableChars = unicode(useable)
+		self.useableChars = str(useable)
 
 	def getKey(self, num):
 		cnt=0
